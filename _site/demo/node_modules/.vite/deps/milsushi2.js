import {
  __commonJS,
  __require
} from "./chunk-7FP5O474.js";

// node_modules/milsushi2/src/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/milsushi2/src/polyfill.js"(exports2) {
    "use strict";
    function polyfill() {
      typedarray_fill_all();
    }
    exports2.polyfill = polyfill;
    function typedarray_fill_all() {
      typedarray_fill(Int8Array);
      typedarray_fill(Uint8Array);
      typedarray_fill(Uint8ClampedArray);
      typedarray_fill(Int16Array);
      typedarray_fill(Uint16Array);
      typedarray_fill(Int32Array);
      typedarray_fill(Uint32Array);
      typedarray_fill(Float32Array);
      typedarray_fill(Float64Array);
    }
    function typedarray_fill(type) {
      if (!type.prototype.fill) {
        type.prototype.fill = function(value) {
          if (this == null) {
            throw new TypeError("this is null or not defined");
          }
          var O = Object(this);
          var len = O.length >>> 0;
          var start = arguments[1];
          var relativeStart = start >> 0;
          var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
          var end = arguments[2];
          var relativeEnd = end === void 0 ? len : end >> 0;
          var final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
          while (k < final) {
            O[k] = value;
            k++;
          }
          return O;
        };
      }
    }
  }
});

// node_modules/milsushi2/src/colon.js
var require_colon = __commonJS({
  "node_modules/milsushi2/src/colon.js"(exports, module) {
    "use strict";
    var Colon = function() {
      function Colon(start, stop_step, stop) {
        this.start = start;
        this.step = 1;
        if (this.start == null) {
          this.all = true;
        } else {
          if (stop != null) {
            this.step = stop_step;
            this.stop = stop;
          } else {
            this.stop = stop_step;
          }
        }
      }
      Colon.fromstring = function(s) {
        var elements = s.replace("end", "-1").split(":");
        var nums = [];
        for (var i = 0; i < elements.length; i++) {
          nums.push(eval(elements[i] || "null"));
        }
        if (elements.length == 2) {
          return new Colon(nums[0], nums[1]);
        } else if (elements.length == 3) {
          return new Colon(nums[0], nums[1], nums[2]);
        } else {
          throw new Error("Invalid format");
        }
      };
      Colon.prototype.tojsa = function(size) {
        var start = this.start;
        var stop = this.stop;
        var step = this.step;
        if (this.all) {
          start = 1;
          stop = size;
          step = 1;
        }
        if (start < 0) {
          start += size + 1;
        }
        if (stop < 0) {
          stop += size + 1;
        }
        var jsa = [];
        if (step > 0) {
          for (var i2 = start; i2 <= stop; i2 += step) {
            jsa.push(i2);
          }
        } else if (step < 0) {
          for (var i2 = start; i2 >= stop; i2 += step) {
            jsa.push(i2);
          }
        }
        return jsa;
      };
      Colon.prototype.toString = function() {
        if (this.start == null) {
          return ":";
        } else {
          if (this.step == null) {
            return colonedge2str(this.start) + ":" + colonedge2str(this.stop);
          } else {
            return colonedge2str(this.start) + ":" + this.step + ":" + colonedge2str(this.stop);
          }
        }
      };
      return Colon;
    }();
    function colonedge2str(val) {
      if (val >= 0) {
        return "" + val;
      } else {
        if (val == 0) {
          return "end";
        }
        return "end-" + (-1 - val);
      }
    }
    module.exports = Colon;
  }
});

// node_modules/milsushi2/src/matrix.js
var require_matrix = __commonJS({
  "node_modules/milsushi2/src/matrix.js"(exports2, module2) {
    "use strict";
    var Colon2 = require_colon();
    var Matrix2 = function() {
      function Matrix3(size, klass, noalloc) {
        if (klass === void 0) {
          klass = "single";
        }
        if (noalloc === void 0) {
          noalloc = false;
        }
        var _size = Array.prototype.slice.call(size);
        var tmpnumel = 1;
        var strides = [];
        var last_none_one_dim = 0;
        if (_size.length < 2) {
          throw new Error("matrix must have at least 2 dimensions");
        }
        for (var i2 = 0; i2 < _size.length; i2++) {
          var dimsize = _size[i2];
          if (typeof dimsize !== "number" || dimsize < 0 || !Matrix3._isinteger(dimsize)) {
            throw new Error("size is invalid");
          }
          if (dimsize != 1) {
            last_none_one_dim = i2;
          }
          strides.push(tmpnumel);
          tmpnumel *= dimsize;
        }
        if (tmpnumel >= 2147483648) {
          throw new Error("Matrix of equal to or more than 2G elements is not supported");
        }
        this._numel = tmpnumel;
        last_none_one_dim = Math.max(last_none_one_dim, 1) + 1;
        _size.splice(last_none_one_dim);
        strides.splice(last_none_one_dim);
        this._size = _size;
        this._ndims = _size.length;
        this._strides = strides;
        if (!Matrix3._isvalidklass(klass)) {
          throw new Error("unknown klass");
        }
        this._klass = klass;
        this._data_ctor = Matrix3.data_ctors[klass];
        if (!noalloc) {
          this._alloccpu();
        }
        if (Matrix3._autodestruct_stack_top) {
          Matrix3._autodestruct_stack_top.push(this);
        }
      }
      Matrix3.autodestruct_push = function() {
        var array = [];
        Matrix3._autodestruct_stack_top = array;
        Matrix3._autodestruct_stack.push(array);
      };
      Matrix3.autodestruct_pop = function() {
        if (Matrix3._autodestruct_stack_top) {
          for (var i2 = 0; i2 < Matrix3._autodestruct_stack_top.length; i2++) {
            Matrix3._autodestruct_stack_top[i2].destruct();
          }
          Matrix3._autodestruct_stack.pop();
          Matrix3._autodestruct_stack_top = Matrix3._autodestruct_stack[Matrix3._autodestruct_stack.length - 1];
        }
      };
      Matrix3.prototype.destruct = function() {
        this._data = null;
      };
      Matrix3.prototype.inspect = function(depth) {
        var shape_str = this._size.join("x");
        if (this._numel <= 100) {
          return "Matrix " + shape_str + " " + this._klass + "\n" + this.toString();
        } else {
          return "Matrix " + shape_str + " " + this._klass;
        }
      };
      Matrix3.typedarray2mat = function(size, klass, data) {
        if (klass === void 0) {
          klass = "single";
        }
        if (!(data instanceof Matrix3.data_ctors[klass])) {
          throw Error("klass and data type mismatch");
        }
        var m = new Matrix3(size, klass, true);
        if (data.length < m._numel) {
          throw Error("The length of data is smaller than matrix size");
        }
        m._data = data;
        if (klass === "logical") {
          for (var i2 = 0; i2 < m._numel; i2++) {
            data[i2] = Number(data[i2] != 0);
          }
        }
        return m;
      };
      Matrix3._isinteger = function(x) {
        return Math.round(x) == x;
      };
      Matrix3._isvalidklass = function(klass) {
        return klass == "single" || klass == "int32" || klass == "uint8" || klass == "logical";
      };
      Matrix3._logical_cast_required = function(klass_dst, klass_src) {
        return klass_dst == "logical" && klass_src != "logical";
      };
      Matrix3._logical_cast = function(val) {
        return Number(Boolean(val));
      };
      Matrix3.prototype._alloccpu = function() {
        if (!this._data) {
          this._data = new this._data_ctor(this._numel);
        }
        return this._data;
      };
      Matrix3.prototype.to_cpu = function() {
        return this;
      };
      Matrix3.prototype._getdata = function() {
        return this._data;
      };
      Matrix3.prototype.getdataref = function(src_offset, length) {
        if (src_offset === void 0) {
          src_offset = 0;
        }
        if (!src_offset && length == null) {
          return this._data;
        } else {
          if (length == null) {
            length = this._numel;
          }
          return new this._data_ctor(this._data.buffer, src_offset * this._data.BYTES_PER_ELEMENT, length);
        }
      };
      Matrix3.prototype.getdatacopy = function(src_offset, length, dst) {
        if (src_offset === void 0) {
          src_offset = 0;
        }
        if (length == null) {
          length = this._numel - src_offset;
        }
        if (!dst) {
          dst = new this._data_ctor(length);
        }
        var range_view = new this._data_ctor(this._data.buffer, src_offset * this._data.BYTES_PER_ELEMENT, length);
        dst.set(range_view);
        return dst;
      };
      Matrix3.prototype.setdata = function(src, dst_offset) {
        if (dst_offset === void 0) {
          dst_offset = 0;
        }
        this._data.set(src, dst_offset);
      };
      Matrix3.prototype._isvalidindex = function(inds) {
        if (this._numel == 0) {
          return false;
        }
        if (inds.length == 0) {
          return false;
        } else if (inds.length == 1) {
          return Matrix3._isinteger(inds[0]) && (inds[0] > 0 && inds[0] <= this._numel || inds[0] < 0 && -inds[0] <= this._numel);
        } else {
          if (inds.length < this._ndims) {
            for (var dim = 0; dim < inds.length; dim++) {
              var ind = inds[dim];
              var dimsize;
              if (dim == inds.length - 1) {
                dimsize = 1;
                for (var dimex = dim; dimex < this._ndims; dimex++) {
                  dimsize *= this._size[dimex];
                }
              } else {
                dimsize = this._size[dim];
              }
              if (Matrix3._isinteger(ind) && (ind > 0 && ind <= dimsize || ind < 0 && -ind <= dimsize)) {
              } else {
                return false;
              }
            }
          } else {
            for (var dim = 0; dim < inds.length; dim++) {
              var ind = inds[dim];
              var dimsize = this._size[dim] || 1;
              if (Matrix3._isinteger(ind) && (ind > 0 && ind <= dimsize || ind < 0 && -ind <= dimsize)) {
              } else {
                return false;
              }
            }
          }
        }
        return true;
      };
      Matrix3.prototype._isvalidindexerr = function(inds) {
        if (!this._isvalidindex(inds)) {
          throw new Error("Invalid index");
        }
      };
      Matrix3.prototype._getarrayindex = function(inds) {
        var idx = 0;
        if (inds.length == 1) {
          var ind = inds[0];
          if (ind < 0) {
            ind += this._numel + 1;
          }
          idx = ind - 1;
        } else {
          if (inds.length < this._ndims) {
            for (var dim = 0; dim < inds.length; dim++) {
              var ind = inds[dim];
              if (ind < 0) {
                var dimsize;
                if (dim == inds.length - 1) {
                  dimsize = 1;
                  for (var dimex = dim; dimex < this._ndims; dimex++) {
                    dimsize *= this._size[dimex];
                  }
                } else {
                  dimsize = this._size[dim];
                }
                ind += dimsize + 1;
              }
              idx += (ind - 1) * (this._strides[dim] || 0);
            }
          } else {
            for (var dim = 0; dim < inds.length; dim++) {
              var ind = inds[dim];
              if (ind < 0) {
                ind += (this._size[dim] || 1) + 1;
              }
              idx += (ind - 1) * (this._strides[dim] || 0);
            }
          }
        }
        return idx;
      };
      Matrix3.numel = function(A) {
        return A._numel;
      };
      Matrix3.size = function(X, dim) {
        if (dim == void 0) {
          return Matrix3.jsa2mat([X._size]);
        } else {
          return X._size[dim - 1];
        }
      };
      Matrix3.sizejsa = function(X) {
        return X._size.slice();
      };
      Matrix3.jsa2mat = function(ary, one_d_column, klass) {
        if (one_d_column === void 0) {
          one_d_column = false;
        }
        if (klass === void 0) {
          klass = "single";
        }
        var mat;
        if (typeof ary === "number") {
          mat = new Matrix3([1, 1], klass);
          mat.set_scalar(ary, [1]);
        } else if (ary instanceof Matrix3) {
          mat = ary.copy();
        } else if (!ary.length) {
          mat = new Matrix3([0, 0], klass);
        } else {
          var arysize = [];
          var cur_ary = ary;
          var numel = 1;
          while (cur_ary.length !== void 0) {
            arysize.push(cur_ary.length);
            numel *= cur_ary.length;
            cur_ary = cur_ary[0];
          }
          var ndims = arysize.length;
          var size = arysize.slice();
          size.reverse();
          if (size.length >= 2) {
            var swap = size[1];
            size[1] = size[0];
            size[0] = swap;
          }
          var cstride;
          if (size.length >= 2) {
            cstride = [1, size[0]];
            var last_cstride = size[0];
            for (var dim = 2; dim < ndims; dim++) {
              last_cstride *= size[dim - 1];
              cstride.unshift(last_cstride);
            }
          } else {
            cstride = [1];
          }
          var data_ctor = Matrix3.data_ctors[klass];
          var data = new data_ctor(numel);
          var flat_i = 0;
          var n = function(a, dim2, fidx_ofs) {
            if (a.length != arysize[dim2]) {
              throw Error("Inconsistent size of n-d array");
            }
            if (dim2 == ndims - 1) {
              for (var i2 = 0; i2 < arysize[dim2]; i2++) {
                var val = a[i2];
                var fidx = fidx_ofs + i2 * cstride[dim2];
                data[fidx] = val;
                flat_i++;
              }
            } else {
              for (var i2 = 0; i2 < arysize[dim2]; i2++) {
                n(a[i2], dim2 + 1, fidx_ofs + i2 * cstride[dim2]);
              }
            }
          };
          n(ary, 0, 0);
          if (ndims == 1) {
            if (one_d_column) {
              size = [size[0], 1];
            } else {
              size = [1, size[0]];
            }
          }
          mat = Matrix3.typedarray2mat(size, klass, data);
        }
        return mat;
      };
      Matrix3.prototype.mat2jsa = function(one_d_flatten) {
        if (one_d_flatten === void 0) {
          one_d_flatten = false;
        }
        var ary = [];
        if (one_d_flatten && this._ndims == 2 && (this._size[0] == 1 || this._size[1] == 1)) {
          var data = this.getdataref();
          for (var i2 = 0; i2 < data.length; i2++) {
            ary.push(data[i2]);
          }
        } else {
          var size = this._size;
          var ndims = this._ndims;
          var data = this.getdataref();
          var cstride;
          if (size.length >= 2) {
            cstride = [1, size[0]];
            var last_cstride = size[0];
            for (var dim = 2; dim < ndims; dim++) {
              last_cstride *= size[dim - 1];
              cstride.unshift(last_cstride);
            }
          } else {
            cstride = [1];
          }
          var arysize = size.slice();
          arysize.reverse();
          var swap = arysize[arysize.length - 1];
          arysize[arysize.length - 1] = arysize[arysize.length - 2];
          arysize[arysize.length - 2] = swap;
          var flat_i = 0;
          var n = function(a, dim2, fidx_ofs) {
            if (dim2 == ndims - 1) {
              for (var i3 = 0; i3 < arysize[dim2]; i3++) {
                var fidx = fidx_ofs + i3 * cstride[dim2];
                a.push(data[fidx]);
                flat_i++;
              }
            } else {
              for (var i3 = 0; i3 < arysize[dim2]; i3++) {
                var newa = [];
                a.push(newa);
                n(newa, dim2 + 1, fidx_ofs + i3 * cstride[dim2]);
              }
            }
          };
          n(ary, 0, 0);
        }
        return ary;
      };
      Matrix3.prototype.get = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (this._numel == 0) {
          throw Error("Matrix with no element");
        }
        if (args.length == 0) {
          return this._alloccpu()[0];
        }
        var all_number = args.every(function(v) {
          return typeof v === "number";
        });
        if (all_number) {
          return this.get_scalar(args);
        } else {
          return this.get_matrix_nd(args);
        }
      };
      Matrix3.prototype.valueOf = function() {
        if (this._numel > 0) {
          return this.get();
        } else {
          return 0;
        }
      };
      Matrix3.prototype.copy = function(klass) {
        var clone = new Matrix3(this._size, klass || this._klass);
        var clone_data = clone._getdata();
        var rawdata = this._alloccpu();
        if (Matrix3._logical_cast_required(clone._klass, this._klass)) {
          for (var i2 = 0, length = clone_data.length; i2 < length; i2++) {
            clone_data[i2] = Matrix3._logical_cast(rawdata[i2]);
          }
        } else {
          clone_data.set(rawdata);
        }
        return clone;
      };
      Matrix3.prototype.get_scalar = function(inds) {
        var rawdata = this._alloccpu();
        this._isvalidindexerr(inds);
        var arrayidx = this._getarrayindex(inds);
        return rawdata[arrayidx];
      };
      Matrix3._get_ind_iterator = function(ind, dim_size) {
        if (typeof ind === "number") {
          var ind_positive = ind;
          if (ind_positive < 0) {
            ind_positive += dim_size + 1;
          }
          if (ind_positive <= 0 || ind_positive > dim_size) {
            throw Error("Index exceeds matrix dimension");
          }
          return {
            iter: function(index) {
              return ind_positive;
            },
            length: 1
          };
        } else if (ind instanceof Colon2) {
          var start = ind.start;
          var stop = ind.stop;
          var step = ind.step;
          if (ind.all) {
            start = 1;
            stop = dim_size;
            step = 1;
          }
          if (start < 0) {
            start += dim_size + 1;
          }
          if (stop < 0) {
            stop += dim_size + 1;
          }
          var length = 0;
          if (step > 0 && stop >= start || step < 0 && stop <= start) {
            length = Math.floor((stop - start) / step) + 1;
            var final_value = start + step * (length - 1);
            if (start <= 0 || start > dim_size || (final_value <= 0 || final_value > dim_size)) {
              throw Error("Index exceeds matrix dimension");
            }
          }
          return {
            iter: function(index) {
              return start + step * index;
            },
            length
          };
        } else if (ind instanceof Matrix3) {
          var dataref = ind.getdataref();
          for (var i2 = 0; i2 < dataref.length; i2++) {
            var element = dataref[i2];
            if (element == 0 || element > dim_size || element < -dim_size) {
              throw Error("Index exceeds matrix dimension");
            }
          }
          return {
            iter: function(index) {
              var val = dataref[index];
              if (val < 0) {
                val += dim_size;
              }
              return val;
            },
            length: dataref.length
          };
        }
      };
      Matrix3.prototype.get_matrix_nd = function(inds) {
        var inds_ndim = inds.length;
        for (var i2 = 0; i2 < inds_ndim; i2++) {
          var ind = inds[i2];
          if (ind instanceof Matrix3) {
            if (ind._klass == "logical") {
              inds[i2] = ind._find();
            }
          }
        }
        var virtual_input_shape = [];
        if (this._ndims <= inds_ndim) {
          virtual_input_shape = this._size.concat();
          while (virtual_input_shape.length < inds_ndim) {
            virtual_input_shape.push(1);
          }
        } else {
          var cur_prod = 1;
          for (var dim_1 = 0; dim_1 < inds_ndim - 1; dim_1++) {
            virtual_input_shape.push(this._size[dim_1]);
            cur_prod *= this._size[dim_1];
          }
          virtual_input_shape.push(this._numel / cur_prod);
        }
        var virtual_input_stride = [];
        var stride_tmp = 1;
        for (var dim = 0; dim < inds_ndim; dim++) {
          virtual_input_stride.push(stride_tmp);
          stride_tmp *= virtual_input_shape[dim];
        }
        var ind_iters = [];
        var dst_shape = [];
        var dst_stride = [];
        var dst_stride_tmp = 1;
        for (var dim = 0; dim < inds_ndim; dim++) {
          var iter_and_length = Matrix3._get_ind_iterator(inds[dim], virtual_input_shape[dim]);
          ind_iters.push(iter_and_length.iter);
          dst_shape.push(iter_and_length.length);
          dst_stride.push(dst_stride_tmp);
          dst_stride_tmp *= iter_and_length.length;
        }
        var dst_reshape_shape = null;
        if (inds_ndim == 1) {
          dst_shape.push(1);
          var is_ind_vector = false;
          var only_ind = inds[0];
          if (only_ind instanceof Matrix3) {
            if (only_ind._ndims == 2 && (only_ind._size[0] == 1 || only_ind._size[1] == 1)) {
              is_ind_vector = true;
            }
          } else if (only_ind instanceof Colon2) {
            is_ind_vector = true;
          }
          var is_src_vector = false;
          if (this._ndims == 2 && (this._size[0] == 1 || this._size[1] == 1)) {
            is_src_vector = true;
          }
          if (is_src_vector && is_ind_vector) {
            if (this._size[0] == 1) {
              dst_reshape_shape = [1, dst_shape[0]];
            }
          } else {
            if (only_ind instanceof Matrix3) {
              dst_reshape_shape = only_ind._size;
            } else if (only_ind instanceof Colon2) {
              dst_reshape_shape = [1, dst_shape[0]];
            }
          }
        }
        var dst = new Matrix3(dst_shape, this._klass);
        var dst_data = dst._data;
        var src_data = this._data;
        var dst_numel = dst._numel;
        for (var dst_idx = 0; dst_idx < dst_numel; dst_idx++) {
          var input_linear_idx = 0;
          for (var dim = 0; dim < inds_ndim; dim++) {
            var dst_coord = Math.floor(dst_idx / dst_stride[dim]) % dst_shape[dim];
            var src_coord = ind_iters[dim](dst_coord) - 1;
            input_linear_idx += src_coord * virtual_input_stride[dim];
          }
          dst_data[dst_idx] = src_data[input_linear_idx];
        }
        if (dst_reshape_shape) {
          dst.reshape_inplace(dst_reshape_shape);
        }
        return dst;
      };
      Matrix3.prototype.get_matrix_nd_old = function(inds) {
        var eachdimidx = [];
        var eachdimstride = [];
        var output_size = [];
        var output_length = 1;
        var inputdimctr = [];
        for (var dim = 0; dim < inds.length; dim++) {
          var dimind = inds[dim];
          var dimidx;
          if (dimind instanceof Colon2) {
            dimidx = dimind.tojsa(this._size[dim] === void 0 ? 1 : this._size[dim]);
          } else if (dimind instanceof Matrix3) {
            dimidx = dimind._getdata();
          } else {
            dimidx = [dimind];
          }
          var dimsize;
          if (dim == inds.length - 1) {
            dimsize = 1;
            for (var dimex = dim; dimex < this._ndims; dimex++) {
              dimsize *= this._size[dimex];
            }
          } else {
            dimsize = this._size[dim] || 1;
          }
          for (var i2 = 0; i2 < dimidx.length; i2++) {
            var dimval = dimidx[i2];
            if (dimval < 0) {
              dimval += dimsize + 1;
              dimidx[i2] = dimval;
            }
            if (dimval > dimsize || dimval < 1) {
              throw new Error("Index exceeds matrix dimension");
            }
          }
          eachdimidx.push(dimidx);
          eachdimstride.push(this._strides[dim] || 0);
          output_size.push(dimidx.length);
          output_length *= dimidx.length;
          inputdimctr.push(0);
        }
        var output = new Matrix3(output_size, this._klass);
        var output_data = output._data;
        var input_data = this._data;
        for (var i2 = 0; i2 < output_length; i2++) {
          var input_raw_idx = 0;
          for (var dim = 0; dim < eachdimidx.length; dim++) {
            input_raw_idx += (eachdimidx[dim][inputdimctr[dim]] - 1) * eachdimstride[dim];
          }
          output_data[i2] = input_data[input_raw_idx];
          for (var dim = 0; dim < inputdimctr.length; dim++) {
            var element = ++inputdimctr[dim];
            if (element >= eachdimidx[dim].length) {
              inputdimctr[dim] = 0;
            } else {
              break;
            }
          }
        }
        return output;
      };
      Matrix3.prototype.get_matrix_single = function(singleind) {
        var single_idx_array;
        var output_size;
        if (singleind instanceof Colon2) {
          single_idx_array = singleind.tojsa(this._numel);
          output_size = [1, single_idx_array.length];
        } else if (singleind instanceof Matrix3) {
          single_idx_array = singleind._data;
          output_size = singleind._size;
        }
        var output = new Matrix3(output_size, this._klass);
        var output_data = output._data;
        var input_data = this._data;
        for (var i2 = 0, length = single_idx_array.length; i2 < length; i2++) {
          output_data[i2] = input_data[single_idx_array[i2] - 1];
        }
        return output;
      };
      Matrix3.prototype.get_matrix_logical = function(map) {
        var output_length = 0;
        var map_data = map._getdata();
        var max_i = -1;
        for (var i2 = 0, length = map_data.length; i2 < length; i2++) {
          if (map_data[i2]) {
            output_length++;
            max_i = i2;
          }
        }
        if (this._numel <= max_i) {
          throw new Error("Index out of bounds");
        }
        var output = new Matrix3([output_length, 1], this._klass);
        var output_data = output._data;
        var input_data = this._data;
        var ptr = 0;
        for (var i2 = 0, length = map_data.length; i2 < length; i2++) {
          if (map_data[i2]) {
            output_data[ptr++] = input_data[i2];
          }
        }
        return output;
      };
      Matrix3.prototype.set = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var val = args.pop();
        if (!(val instanceof Matrix3) && val.length !== void 0) {
          val = Matrix3.jsa2mat(val, false, this._klass);
        }
        if (val instanceof Matrix3 && val._numel == 1) {
          val = val.get_scalar([1]);
        }
        var all_number = args.every(function(v) {
          return typeof v === "number";
        });
        if (all_number) {
          this.set_scalar(val, args);
        } else {
          this.set_matrix_nd(val, args);
        }
      };
      Matrix3.prototype.set_scalar = function(val, inds) {
        var rawdata = this._alloccpu();
        this._isvalidindexerr(inds);
        var arrayidx = this._getarrayindex(inds);
        var scalar_val;
        if (val instanceof Matrix3) {
          if (val._numel != 1) {
            throw new Error("Value is not scalar");
          }
          scalar_val = val._getdata()[0];
        } else {
          scalar_val = val;
        }
        if (Matrix3._logical_cast_required(this._klass)) {
          scalar_val = Matrix3._logical_cast(scalar_val);
        }
        rawdata[arrayidx] = scalar_val;
      };
      Matrix3.prototype.set_matrix_single = function(val, singleind) {
        var single_idx_array;
        var output_size;
        if (singleind instanceof Colon2) {
          single_idx_array = singleind.tojsa(this._numel);
        } else if (singleind instanceof Matrix3) {
          single_idx_array = singleind.getdataref();
        }
        var rawdata = this._alloccpu();
        if (val instanceof Matrix3) {
          if (single_idx_array.length != val._numel) {
            throw new Error("Dimension mismatch");
          }
          var val_data = val._getdata();
          if (Matrix3._logical_cast_required(this._klass, val._klass)) {
            rawdata[single_idx_array[i2] - 1] = Matrix3._logical_cast(val_data[i2]);
          } else {
            for (var i2 = 0, length = single_idx_array.length; i2 < length; i2++) {
              rawdata[single_idx_array[i2] - 1] = val_data[i2];
            }
          }
        } else {
          var scalar_val;
          if (Matrix3._logical_cast_required(this._klass)) {
            scalar_val = Matrix3._logical_cast(val);
          } else {
            scalar_val = val;
          }
          for (var i2 = 0, length = single_idx_array.length; i2 < length; i2++) {
            rawdata[single_idx_array[i2] - 1] = scalar_val;
          }
        }
      };
      Matrix3.prototype.set_matrix_nd = function(val, inds) {
        var inds_ndim = inds.length;
        for (var i2 = 0; i2 < inds_ndim; i2++) {
          var ind = inds[i2];
          if (ind instanceof Matrix3) {
            if (ind._klass == "logical") {
              inds[i2] = ind._find();
            }
          }
        }
        var virtual_input_shape = [];
        if (this._ndims <= inds_ndim) {
          virtual_input_shape = this._size.concat();
          while (virtual_input_shape.length < inds_ndim) {
            virtual_input_shape.push(1);
          }
        } else {
          var cur_prod = 1;
          for (var dim_2 = 0; dim_2 < inds_ndim - 1; dim_2++) {
            virtual_input_shape.push(this._size[dim_2]);
            cur_prod *= this._size[dim_2];
          }
          virtual_input_shape.push(this._numel / cur_prod);
        }
        var virtual_input_stride = [];
        var stride_tmp = 1;
        for (var dim = 0; dim < inds_ndim; dim++) {
          virtual_input_stride.push(stride_tmp);
          stride_tmp *= virtual_input_shape[dim];
        }
        var ind_iters = [];
        var dst_shape = [];
        var dst_stride = [];
        var dst_stride_tmp = 1;
        for (var dim = 0; dim < inds_ndim; dim++) {
          var iter_and_length = Matrix3._get_ind_iterator(inds[dim], virtual_input_shape[dim]);
          ind_iters.push(iter_and_length.iter);
          dst_shape.push(iter_and_length.length);
          dst_stride.push(dst_stride_tmp);
          dst_stride_tmp *= iter_and_length.length;
        }
        var dst_numel = dst_stride_tmp;
        var scalar_val = null;
        if (typeof val === "number") {
          scalar_val = val;
        } else if (val instanceof Matrix3) {
          if (val._numel === 1) {
            scalar_val = val.valueOf();
          }
        }
        if (scalar_val == null) {
          var dst_shape_exclude_one = dst_shape.filter(function(v) {
            return v != 1;
          });
          var val_shape_exclude_one = val._size.filter(function(v) {
            return v != 1;
          });
          if (dst_shape_exclude_one.length != val_shape_exclude_one.length) {
            throw Error("Shape mismatch");
          }
          if (!dst_shape_exclude_one.every(function(v, i3) {
            return v == val_shape_exclude_one[i3];
          })) {
            throw Error("Shape mismatch");
          }
          var dst_data = val.getdataref();
          var src_data = this._data;
          for (var dst_idx = 0; dst_idx < dst_numel; dst_idx++) {
            var input_linear_idx = 0;
            for (var dim = 0; dim < inds_ndim; dim++) {
              var dst_coord = Math.floor(dst_idx / dst_stride[dim]) % dst_shape[dim];
              var src_coord = ind_iters[dim](dst_coord) - 1;
              input_linear_idx += src_coord * virtual_input_stride[dim];
            }
            src_data[input_linear_idx] = dst_data[dst_idx];
          }
        } else {
          var src_data = this._data;
          for (var dst_idx = 0; dst_idx < dst_numel; dst_idx++) {
            var input_linear_idx = 0;
            for (var dim = 0; dim < inds_ndim; dim++) {
              var dst_coord = Math.floor(dst_idx / dst_stride[dim]) % dst_shape[dim];
              var src_coord = ind_iters[dim](dst_coord) - 1;
              input_linear_idx += src_coord * virtual_input_stride[dim];
            }
            src_data[input_linear_idx] = scalar_val;
          }
        }
      };
      Matrix3.prototype.set_matrix_nd_old = function(val, inds) {
        var eachdimidx = [];
        var eachdimstride = [];
        var output_size = [];
        var output_length = 1;
        var inputdimctr = [];
        for (var dim = 0; dim < inds.length; dim++) {
          var dimind = inds[dim];
          var dimidx;
          if (dimind instanceof Colon2) {
            dimidx = dimind.tojsa(this._size[dim] || 1);
          } else if (dimind instanceof Matrix3) {
            dimidx = dimind._getdata();
          } else {
            dimidx = [dimind];
          }
          var dim_size = this._size[dim] || 1;
          for (var i2 = 0; i2 < dimidx.length; i2++) {
            if (dimidx[i2] > dim_size || dimidx[i2] < 1) {
              throw new Error("Index exceeds matrix dimension");
            }
          }
          eachdimidx.push(dimidx);
          eachdimstride.push(this._strides[dim] || 0);
          output_size.push(dimidx.length);
          output_length *= dimidx.length;
          inputdimctr.push(0);
        }
        var rawdata = this._alloccpu();
        if (val instanceof Matrix3) {
          var is_vector = output_size.filter(function(v) {
            return v != 1;
          }).length <= 1;
          if (is_vector) {
            if (val._numel != output_length) {
              throw new Error("Dimensions mismatch");
            }
          } else {
            for (var dim = 0; dim < Math.max(val._size.length, output_size.length); dim++) {
              if ((val._size[dim] || 1) != (output_size[dim] || 1)) {
                throw new Error("Dimensions mismatch");
              }
            }
          }
          var val_data = val._getdata();
          if (Matrix3._logical_cast_required(this._klass, val._klass)) {
            for (var i2 = 0; i2 < output_length; i2++) {
              var input_raw_idx = 0;
              for (var dim = 0; dim < eachdimidx.length; dim++) {
                input_raw_idx += (eachdimidx[dim][inputdimctr[dim]] - 1) * eachdimstride[dim];
              }
              rawdata[input_raw_idx] = Matrix3._logical_cast(val_data[i2]);
              for (var dim = 0; dim < inputdimctr.length; dim++) {
                var element = ++inputdimctr[dim];
                if (element >= eachdimidx[dim].length) {
                  inputdimctr[dim] = 0;
                } else {
                  break;
                }
              }
            }
          } else {
            for (var i2 = 0; i2 < output_length; i2++) {
              var input_raw_idx = 0;
              for (var dim = 0; dim < eachdimidx.length; dim++) {
                input_raw_idx += (eachdimidx[dim][inputdimctr[dim]] - 1) * eachdimstride[dim];
              }
              rawdata[input_raw_idx] = val_data[i2];
              for (var dim = 0; dim < inputdimctr.length; dim++) {
                var element = ++inputdimctr[dim];
                if (element >= eachdimidx[dim].length) {
                  inputdimctr[dim] = 0;
                } else {
                  break;
                }
              }
            }
          }
        } else {
          var scalar_val;
          if (Matrix3._logical_cast_required(this._klass)) {
            scalar_val = Matrix3._logical_cast(val);
          } else {
            scalar_val = val;
          }
          for (var i2 = 0; i2 < output_length; i2++) {
            var input_raw_idx = 0;
            for (var dim = 0; dim < eachdimidx.length; dim++) {
              input_raw_idx += (eachdimidx[dim][inputdimctr[dim]] - 1) * eachdimstride[dim];
            }
            rawdata[input_raw_idx] = scalar_val;
            for (var dim = 0; dim < inputdimctr.length; dim++) {
              var element = ++inputdimctr[dim];
              if (element >= eachdimidx[dim].length) {
                inputdimctr[dim] = 0;
              } else {
                break;
              }
            }
          }
        }
      };
      Matrix3.prototype.set_matrix_logical = function(val, map) {
        var output_length = 0;
        var map_data = map._getdata();
        var max_i = -1;
        for (var i2 = 0, length = map_data.length; i2 < length; i2++) {
          if (map_data[i2]) {
            output_length++;
            max_i = i2;
          }
        }
        if (this._numel < max_i) {
          throw new Error("Index out of bounds");
        }
        var rawdata = this._alloccpu();
        if (val instanceof Matrix3) {
          var val_data = val._getdata();
          var ptr = 0;
          if (Matrix3._logical_cast_required(this._klass, val._klass)) {
            for (var i2 = 0, length = map_data.length; i2 < length; i2++) {
              if (map_data[i2]) {
                rawdata[i2] = Matrix3._logical_cast(val_data[ptr++]);
              }
            }
          } else {
            for (var i2 = 0, length = map_data.length; i2 < length; i2++) {
              if (map_data[i2]) {
                rawdata[i2] = val_data[ptr++];
              }
            }
          }
        } else {
          var ptr = 0;
          var scalar_val;
          if (Matrix3._logical_cast_required(this._klass)) {
            scalar_val = Matrix3._logical_cast(val);
          } else {
            scalar_val = val;
          }
          for (var i2 = 0, length = map_data.length; i2 < length; i2++) {
            if (map_data[i2]) {
              rawdata[i2] = scalar_val;
            }
          }
        }
      };
      Matrix3.prototype.toString = function() {
        var s2 = "";
        var rows = this._size[0], cols = this._size[1];
        var rawdata = this.getdataref();
        for (var row = 0; row < rows; row++) {
          for (var col = 0; col < cols; col++) {
            s2 += rawdata[col * rows + row] + "	";
          }
          s2 += "\n";
        }
        return s2;
      };
      Matrix3.prototype.disp = function(X) {
        var s2 = "";
        if (this !== void 0) {
          s2 = this.toString();
        } else {
          s2 = X.toString();
        }
        console.log(s2);
      };
      Matrix3.prototype.reshape_inplace = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var _size;
        var first_arg = args[0];
        if (first_arg instanceof Matrix3) {
          var tarray = first_arg._getdata();
          _size = Array.prototype.slice.call(tarray);
        } else if (first_arg.length !== void 0) {
          _size = Array.prototype.slice.call(first_arg);
        } else {
          _size = Array.prototype.slice.call(args);
        }
        var tmpnumel = 1;
        var strides = [];
        var last_none_one_dim = 0;
        if (_size.length < 2) {
          throw new Error("matrix must have at least 2 dimensions");
        }
        var minus_pos = -1;
        var remaining_prod = 1;
        for (var i2 = 0; i2 < _size.length; i2++) {
          if (_size[i2] < 0) {
            if (minus_pos >= 0) {
              throw new Error("Only one free size is accepted");
            }
            minus_pos = i2;
          } else {
            remaining_prod *= _size[i2];
          }
        }
        if (minus_pos >= 0) {
          _size[minus_pos] = this._numel / remaining_prod;
        }
        for (var i2 = 0; i2 < _size.length; i2++) {
          var dimsize = _size[i2];
          if (typeof dimsize !== "number" || dimsize < 0 || !Matrix3._isinteger(dimsize)) {
            throw new Error("size is invalid");
          }
          if (dimsize != 1) {
            last_none_one_dim = i2;
          }
          strides.push(tmpnumel);
          tmpnumel *= dimsize;
        }
        if (tmpnumel !== this._numel) {
          throw new Error("New shape must have same elements");
        }
        last_none_one_dim = Math.max(last_none_one_dim, 1) + 1;
        _size.splice(last_none_one_dim);
        strides.splice(last_none_one_dim);
        this._size = _size;
        this._numel = tmpnumel;
        this._ndims = _size.length;
        this._strides = strides;
      };
      Matrix3.prototype.squeeze_inplace = function() {
        if (this._ndims == 2) {
          return;
        }
        var new_size = this._size.filter(function(v) {
          return v !== 1;
        });
        while (new_size.length < 2) {
          new_size.push(1);
        }
        var tmpnumel = 1;
        var strides = [];
        for (var dim = 0; dim < new_size.length; dim++) {
          var dimsize = new_size[dim];
          strides.push(tmpnumel);
          tmpnumel *= dimsize;
        }
        this._size = new_size;
        this._ndims = new_size.length;
        this._strides = strides;
      };
      Matrix3.prototype._find = function() {
        var output_length = 0;
        var src_data = this.getdataref();
        for (var i2 = 0; i2 < src_data.length; i2++) {
          if (src_data[i2]) {
            output_length++;
          }
        }
        var dst = new Matrix3([output_length, 1], "int32");
        var dst_idx = 0;
        var dst_data = dst._data;
        for (var i2 = 0; dst_idx < output_length; i2++) {
          if (src_data[i2]) {
            dst_data[dst_idx++] = i2 + 1;
          }
        }
        if (this._size[1] == this._numel) {
          dst.reshape_inplace(this._size);
        }
        return dst;
      };
      return Matrix3;
    }();
    Matrix2._autodestruct_stack = [];
    Matrix2._autodestruct_stack_top = null;
    Matrix2.data_ctors = { "single": Float32Array, "int32": Int32Array, "uint8": Uint8Array, "logical": Uint8Array };
    module2.exports = Matrix2;
  }
});

// node_modules/milsushi2/src/colonwrap.js
var require_colonwrap = __commonJS({
  "node_modules/milsushi2/src/colonwrap.js"(exports2, module2) {
    "use strict";
    var Colon2 = require_colon();
    function colon(start, stop_step, stop) {
      return new Colon2(start, stop_step, stop);
    }
    (function(colon2) {
      colon2.s = Colon2.fromstring;
    })(colon || (colon = {}));
    module2.exports = colon;
  }
});

// node_modules/milsushi2/src/util.js
var require_util = __commonJS({
  "node_modules/milsushi2/src/util.js"(exports2) {
    "use strict";
    var Matrix2 = require_matrix();
    function as_mat(A) {
      if (A instanceof Matrix2) {
        return A;
      } else {
        return Matrix2.jsa2mat(A);
      }
    }
    exports2.as_mat = as_mat;
    function as_mat_or_scalar(A) {
      if (A instanceof Matrix2) {
        return A;
      } else if (typeof A === "object" && A.length != null) {
        return Matrix2.jsa2mat(A);
      } else {
        return A;
      }
    }
    exports2.as_mat_or_scalar = as_mat_or_scalar;
    function commonklassstr() {
      var klasses = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        klasses[_i] = arguments[_i];
      }
      var klass_order = ["single", "int32", "uint8", "logical"];
      if (klasses.length == 0) {
        return klass_order[0];
      }
      var best_klass = 3;
      for (var i2 = 0; i2 < klasses.length; i2++) {
        var element = klasses[i2];
        var score = klass_order.indexOf(element);
        if (score < 0) {
          throw new Error("Unknown klass");
        }
        best_klass = Math.min(score, best_klass);
      }
      return klass_order[best_klass];
    }
    exports2.commonklassstr = commonklassstr;
    function commonklass() {
      var mats = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        mats[_i] = arguments[_i];
      }
      var klasses = [];
      for (var i2 = 0; i2 < mats.length; i2++) {
        var element = mats[i2];
        if (element instanceof Matrix2) {
          klasses.push(element._klass);
        }
      }
      return commonklassstr.apply(void 0, klasses);
    }
    exports2.commonklass = commonklass;
    function issamesize(sizea, sizeb) {
      for (var i2 = 0; i2 < sizea.length; i2++) {
        if (sizea[i2] != sizeb[i2]) {
          return false;
        }
      }
      return true;
    }
    exports2.issamesize = issamesize;
    function force_cpu(A) {
      if (A instanceof Matrix2) {
        return A.to_cpu();
      } else {
        return A;
      }
    }
    exports2.force_cpu = force_cpu;
    function force_cpu_scalar(A) {
      if (A instanceof Matrix2) {
        if (A._numel == 1) {
          return A.get();
        } else {
          return A.to_cpu();
        }
      } else {
        return A;
      }
    }
    exports2.force_cpu_scalar = force_cpu_scalar;
    function jsaequal(a, b) {
      if (a.length != b.length) {
        return false;
      }
      for (var i2 = 0; i2 < a.length; i2++) {
        if (a[i2] != b[i2]) {
          return false;
        }
      }
      return true;
    }
    exports2.jsaequal = jsaequal;
    function calc_zeros_size(args) {
      var size;
      var klass = "single";
      if (args.length >= 1 && typeof args[args.length - 1] === "string") {
        klass = args[args.length - 1];
        args.pop();
      } else if (args.length >= 2 && args[args.length - 2] == "like") {
        klass = args[args.length - 1]._klass;
        args.pop();
        args.pop();
      }
      if (args.length == 0) {
        size = [1, 1];
      } else {
        if (args.length == 1) {
          if (typeof args[0] === "number") {
            size = [args[0], args[0]];
          } else if (args[0] instanceof Matrix2) {
            var sizemat = args[0];
            if (sizemat._size.length == 2 && sizemat._size[0] == 1 && sizemat._size[1] >= 1) {
              size = Array.prototype.slice.call(sizemat._getdata());
            } else {
              throw new Error("matrix size is not valid row vector");
            }
          } else {
            throw new Error("Unknown data type of argument 0");
          }
        } else {
          size = args;
        }
      }
      return { size, klass };
    }
    exports2.calc_zeros_size = calc_zeros_size;
  }
});

// node_modules/milsushi2/src/func_generator.js
var require_func_generator = __commonJS({
  "node_modules/milsushi2/src/func_generator.js"(exports, module) {
    "use strict";
    var Matrix = require_matrix();
    var util = require_util();
    function make_compare_func_all(operation2) {
      var func_s_s = make_binary_arith_func(operation2, false, false, "logical");
      var func_s_m = make_binary_arith_func(operation2, false, true, "logical");
      var func_m_s = make_binary_arith_func(operation2, true, false, "logical");
      var func_m_m = make_binary_arith_func(operation2, true, true, "logical");
      return function(A, B) {
        A = util.force_cpu_scalar(A);
        B = util.force_cpu_scalar(B);
        if (A instanceof Matrix) {
          if (B instanceof Matrix) {
            return func_m_m(A, B);
          } else {
            return func_m_s(A, B);
          }
        } else {
          if (B instanceof Matrix) {
            return func_s_m(A, B);
          } else {
            return func_s_s(A, B);
          }
        }
      };
    }
    exports.make_compare_func_all = make_compare_func_all;
    function make_binary_arith_func(operation, a_mat, b_mat, dst_klass) {
      var l_shape;
      var l_size_check = "";
      var l_def_adata = "";
      var l_def_bdata = "";
      var l_get_a;
      var l_get_b;
      if (a_mat) {
        l_shape = "A._size";
        l_def_adata = "var a_data = A._data;";
        l_get_a = "a_data[i]";
        if (b_mat) {
          l_size_check = 'if (!e_util.jsaequal(A._size, B._size)) {throw new Error("Dimension mismatch");}';
        }
      } else {
        l_get_a = "A";
        if (b_mat) {
          l_shape = "B._size";
        } else {
          l_shape = "[1,1]";
        }
      }
      if (b_mat) {
        l_def_bdata = "var b_data = B._data;";
        l_get_b = "b_data[i]";
      } else {
        l_get_b = "B";
      }
      var l_opr_formatted = operation.replace("%a", l_get_a).replace("%b", l_get_b);
      var f;
      var e_Matrix = Matrix;
      var e_util = util;
      eval([
        "f = function(A, B) {",
        "var shape = " + l_shape + ";",
        l_size_check,
        l_def_adata,
        l_def_bdata,
        'var dst = new e_Matrix(shape, "' + dst_klass + '");',
        "var dst_data = dst._data;",
        "for (var i = 0, length = dst._numel; i < length; i++) {",
        "  dst_data[i] = " + l_opr_formatted + ";",
        "}",
        "return dst;",
        "}"
      ].join("\n"));
      return f;
    }
    exports.make_binary_arith_func = make_binary_arith_func;
    function make_binary_arith_func_all(operation2) {
      var funcs = {};
      return function(A, B) {
        var dst_klass2 = util.commonklass(A, B);
        A = util.force_cpu_scalar(A);
        B = util.force_cpu_scalar(B);
        if (dst_klass2 == "logical") {
          dst_klass2 = "single";
        }
        var a_mat2 = A instanceof Matrix;
        var b_mat2 = B instanceof Matrix;
        var func_name = "" + a_mat2 + "_" + b_mat2 + "_" + dst_klass2;
        var f2 = funcs[func_name];
        if (!f2) {
          f2 = make_binary_arith_func(operation2, a_mat2, b_mat2, dst_klass2);
          funcs[func_name] = f2;
        }
        return f2(A, B);
      };
    }
    exports.make_binary_arith_func_all = make_binary_arith_func_all;
    function make_unary_arith_func(operation, a_mat, dst_klass) {
      var l_shape;
      var l_def_adata = "";
      var l_get_a;
      if (a_mat) {
        l_shape = "A._size";
        l_def_adata = "var a_data = A._data;";
        l_get_a = "a_data[i]";
      } else {
        l_shape = "[1,1]";
        l_get_a = "A";
      }
      var l_opr_formatted = operation.replace(/%a/g, l_get_a);
      var f;
      var e_Matrix = Matrix;
      var e_util = util;
      eval([
        "f = function(A) {",
        "var shape = " + l_shape + ";",
        l_def_adata,
        'var dst = new e_Matrix(shape, "' + dst_klass + '");',
        "var dst_data = dst._data;",
        "for (var i = 0, length = dst._numel; i < length; i++) {",
        "  dst_data[i] = " + l_opr_formatted + ";",
        "}",
        "return dst;",
        "}"
      ].join("\n"));
      return f;
    }
    exports.make_unary_arith_func = make_unary_arith_func;
    function make_unary_arith_func_all(operation2) {
      var funcs = {};
      return function(A) {
        var dst_klass2;
        if (A instanceof Matrix) {
          dst_klass2 = A._klass;
          if (dst_klass2 == "logical") {
            dst_klass2 = "single";
          }
        } else {
          dst_klass2 = "single";
        }
        A = util.force_cpu_scalar(A);
        var a_mat2 = A instanceof Matrix;
        var func_name = "" + a_mat2 + "_" + dst_klass2;
        var f2 = funcs[func_name];
        if (!f2) {
          f2 = make_unary_arith_func(operation2, a_mat2, dst_klass2);
          funcs[func_name] = f2;
        }
        return f2(A);
      };
    }
    exports.make_unary_arith_func_all = make_unary_arith_func_all;
    function isequal_two(A, B) {
      A = A.to_cpu();
      B = B.to_cpu();
      if (!util.issamesize(A._size, B._size)) {
        return false;
      }
      var a_data = A._data;
      var b_data = B._data;
      for (var i2 = 0, length = a_data.length; i2 < length; i2++) {
        if (a_data[i2] !== b_data[i2]) {
          return false;
        }
      }
      return true;
    }
    function isequal() {
      var As = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        As[_i] = arguments[_i];
      }
      if (!(As[0] instanceof Matrix)) {
        return false;
      }
      for (var i2 = 1; i2 < As.length; i2++) {
        if (!(As[i2] instanceof Matrix)) {
          return false;
        }
        if (!isequal_two(As[0], As[i2])) {
          return false;
        }
      }
      return true;
    }
    exports.isequal = isequal;
    function isequaln_two(A, B) {
      A = A.to_cpu();
      B = B.to_cpu();
      if (!util.issamesize(A._size, B._size)) {
        return false;
      }
      var a_data = A._data;
      var b_data = B._data;
      for (var i2 = 0, length = a_data.length; i2 < length; i2++) {
        var val_a = a_data[i2], val_b = b_data[i2];
        if (val_a !== val_b) {
          if (val_a === val_a || val_b === val_b) {
            return false;
          }
        }
      }
      return true;
    }
    function isequaln() {
      var As = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        As[_i] = arguments[_i];
      }
      if (!(As[0] instanceof Matrix)) {
        return false;
      }
      for (var i2 = 1; i2 < As.length; i2++) {
        if (!(As[i2] instanceof Matrix)) {
          return false;
        }
        if (!isequaln_two(As[0], As[i2])) {
          return false;
        }
      }
      return true;
    }
    exports.isequaln = isequaln;
    function make_isclose_func_all() {
      var func_s_s = make_isclose_func(false, false);
      var func_s_m = make_isclose_func(false, true);
      var func_m_s = make_isclose_func(true, false);
      var func_m_m = make_isclose_func(true, true);
      return function(A, B, rtol, atol, equal_nan) {
        if (rtol === void 0) {
          rtol = 1e-5;
        }
        if (atol === void 0) {
          atol = 1e-8;
        }
        if (equal_nan === void 0) {
          equal_nan = false;
        }
        A = util.force_cpu_scalar(A);
        B = util.force_cpu_scalar(B);
        if (A instanceof Matrix) {
          if (B instanceof Matrix) {
            return func_m_m(A, B, rtol, atol, equal_nan);
          } else {
            return func_m_s(A, B, rtol, atol, equal_nan);
          }
        } else {
          if (B instanceof Matrix) {
            return func_s_m(A, B, rtol, atol, equal_nan);
          } else {
            return func_s_s(A, B, rtol, atol, equal_nan);
          }
        }
      };
    }
    function make_isclose_func(a_mat, b_mat) {
      var l_shape;
      var l_size_check = "";
      var l_def_adata = "";
      var l_def_bdata = "";
      var l_get_a;
      var l_get_b;
      if (a_mat) {
        l_shape = "A._size";
        l_def_adata = "var a_data = A._data;";
        l_get_a = "a_data[i]";
        if (b_mat) {
          l_size_check = 'if (!e_util.jsaequal(A._size, B._size)) {throw new Error("Dimension mismatch");}';
        }
      } else {
        l_get_a = "A";
        if (b_mat) {
          l_shape = "B._size";
        } else {
          l_shape = "[1,1]";
        }
      }
      if (b_mat) {
        l_def_bdata = "var b_data = B._data;";
        l_get_b = "b_data[i]";
      } else {
        l_get_b = "B";
      }
      var f;
      var e_Matrix = Matrix;
      var e_util = util;
      eval([
        "f = function(A, B, rtol, atol, equal_nan) {",
        "var shape = " + l_shape + ";",
        l_size_check,
        l_def_adata,
        l_def_bdata,
        'var dst = new e_Matrix(shape, "logical");',
        "var dst_data = dst._data;",
        "if (equal_nan) {",
        "  for (var i = 0, length = dst._numel; i < length; i++) {",
        "    var val_a = " + l_get_a + ";",
        "    var val_b = " + l_get_b + ";",
        "    var absdiff = val_a - val_b;",
        "    if (absdiff < 0) {absdiff = -absdiff}",
        "    var ret = 0;",
        "    if (absdiff <= atol + rtol * ((val_b > 0) ? val_b : -val_b)) {",
        "      ret = 1;",
        "    }",
        "    if ((val_a !== val_a) && (val_b !== val_b)) {",
        "      ret = 1;",
        "    }",
        "    dst_data[i] = ret;",
        "  }",
        "} else {",
        "  for (var i = 0, length = dst._numel; i < length; i++) {",
        "    var val_a = " + l_get_a + ";",
        "    var val_b = " + l_get_b + ";",
        "    var absdiff = val_a - val_b;",
        "    if (absdiff < 0) {absdiff = -absdiff}",
        "    var ret = 0;",
        "    if (absdiff <= atol + rtol * ((val_b > 0) ? val_b : -val_b)) {",
        "      ret = 1;",
        "    }",
        "    dst_data[i] = ret;",
        "  }",
        "}",
        "return dst;",
        "}"
      ].join("\n"));
      return f;
    }
    exports.make_isclose_func = make_isclose_func;
    exports.isclose = make_isclose_func_all();
    function allclose(A, B, rtol, atol, equal_nan) {
      var isclose_result = exports.isclose(A, B, rtol, atol, equal_nan);
      var data = isclose_result.getdataref();
      var prod2 = 1;
      for (var i2 = 0; i2 < data.length; i2++) {
        prod2 *= data[i2];
      }
      return prod2 != 0;
    }
    exports.allclose = allclose;
  }
});

// node_modules/milsushi2/src/shape_converter.js
var require_shape_converter = __commonJS({
  "node_modules/milsushi2/src/shape_converter.js"(exports2) {
    "use strict";
    var Matrix2 = require_matrix();
    var colon = require_colonwrap();
    function transpose(A) {
      if (A._ndims != 2) {
        throw new Error("Matrix must be two-dimensional");
      }
      A = A.to_cpu();
      var _a = A._size, dst_cols = _a[0], dst_rows = _a[1];
      var dst = new Matrix2([dst_rows, dst_cols], A._klass);
      var a_data = A._data;
      var dst_data = dst._data;
      var i2 = 0;
      for (var dst_col = 0; dst_col < dst_cols; dst_col++) {
        for (var dst_row = 0; dst_row < dst_rows; dst_row++) {
          dst_data[i2] = a_data[dst_row * dst_cols + dst_col];
          i2++;
        }
      }
      return dst;
    }
    exports2.transpose = transpose;
    function repmat(A) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      A = A.to_cpu();
      var _rs;
      var first_arg = args[0];
      if (first_arg instanceof Matrix2) {
        var tarray = first_arg._getdata();
        _rs = Array.prototype.slice.call(tarray);
      } else if (first_arg.length !== void 0) {
        _rs = Array.prototype.slice.call(first_arg);
      } else {
        _rs = Array.prototype.slice.call(args);
      }
      if (_rs.length === 1) {
        _rs.push(_rs[0]);
      }
      while (_rs.length < A._ndims) {
        _rs.push(1);
      }
      while (_rs.length > A._ndims && _rs[_rs.length - 1] == 1) {
        _rs.pop();
      }
      var newdims = _rs.length;
      var newsize = [];
      var input_strides = [];
      var output_strides = [];
      var tmp_in_stride = 1;
      var tmp_out_stride = 1;
      var n_copy = 1;
      var rs_strides = [];
      for (var dim = 0; dim < newdims; dim++) {
        var indimsize = A._ndims > dim ? A._size[dim] : 1;
        var outdimsize = indimsize * _rs[dim];
        rs_strides.push(n_copy);
        n_copy *= _rs[dim];
        newsize.push(outdimsize);
        input_strides.push(tmp_in_stride);
        output_strides.push(tmp_out_stride);
        tmp_in_stride *= indimsize;
        tmp_out_stride *= outdimsize;
      }
      input_strides.push(tmp_in_stride);
      rs_strides.push(n_copy);
      var output_steps = [];
      for (var i2 = 0; i2 < n_copy; i2++) {
        var out_offset = 0;
        for (var dim = 0; dim < newdims; dim++) {
          out_offset += Math.floor(i2 % rs_strides[dim + 1] / rs_strides[dim]) * output_strides[dim] * (A._size[dim] || 1);
        }
        output_steps.push(out_offset);
      }
      var dst = new Matrix2(newsize, A._klass);
      var a_data = A._data;
      var dst_data = dst._data;
      for (var i2 = 0, i_length = A._numel; i2 < i_length; i2++) {
        var a_i = a_data[i2];
        var out_offset = 0;
        for (var dim = 0; dim < newdims; dim++) {
          out_offset += Math.floor(i2 % input_strides[dim + 1] / input_strides[dim]) * output_strides[dim];
        }
        for (var j = 0; j < n_copy; j++) {
          var out_idx = out_offset + output_steps[j];
          dst_data[out_idx] = a_i;
        }
      }
      return dst;
    }
    exports2.repmat = repmat;
    function cat(dim) {
      var As = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        As[_i - 1] = arguments[_i];
      }
      var dst_size = As[0]._size.concat();
      while (dst_size.length < dim) {
        dst_size.push(1);
      }
      var concat_offsets = [1];
      for (var i2 = 1; i2 < As.length; i2++) {
        var A = As[i2];
        if (A._numel == 0) {
          concat_offsets.push(0);
          continue;
        }
        var a_size = A._size;
        if (a_size.length > dst_size.length) {
          throw Error("Dimension mismatch");
        }
        for (var d = 0; d < dst_size.length; d++) {
          var a_dim = a_size[d] || 1;
          if (d == dim - 1) {
            concat_offsets.push(dst_size[d] + 1);
            dst_size[d] += a_dim;
          } else {
            if (a_dim != dst_size[d]) {
              throw Error("Dimension mismatch");
            }
          }
        }
      }
      var dst = new Matrix2(dst_size, As[0]._klass);
      for (var i2 = 0; i2 < As.length; i2++) {
        var A = As[i2];
        if (A._numel == 0) {
          continue;
        }
        var args = [];
        for (var d = 0; d < dst_size.length; d++) {
          var element = A._size[d] || 1;
          if (d == dim - 1) {
            args.push(colon(concat_offsets[i2], concat_offsets[i2] + element - 1));
          } else {
            args.push(colon());
          }
        }
        args.push(A);
        dst.set.apply(dst, args);
      }
      return dst;
    }
    exports2.cat = cat;
    function horzcat() {
      var As = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        As[_i] = arguments[_i];
      }
      return cat.apply(void 0, [2].concat(As));
    }
    exports2.horzcat = horzcat;
    function vertcat() {
      var As = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        As[_i] = arguments[_i];
      }
      return cat.apply(void 0, [1].concat(As));
    }
    exports2.vertcat = vertcat;
    function permute(A, order) {
      var src_size = A._size.concat();
      var numel = A._numel;
      if (order.length < src_size.length) {
        throw Error("order must include at least input dimension");
      }
      var ndim = order.length;
      var src_strides = A._strides.concat();
      while (src_size.length < ndim) {
        src_size.push(1);
        src_strides.push(numel);
      }
      var dst_size = [];
      for (var d = 0; d < ndim; d++) {
        var element = order[d] - 1;
        dst_size.push(src_size[element]);
      }
      var dst = new Matrix2(dst_size, A._klass);
      var dst_strides = dst._strides.concat();
      while (dst_strides.length < ndim) {
        dst_strides.push(numel);
      }
      var dst_strides_perm = [];
      order.forEach(function(o, i3) {
        return dst_strides_perm[o - 1] = dst_strides[i3];
      });
      var src_data = A.getdataref();
      var dst_data = dst._data;
      for (var i2 = 0; i2 < numel; i2++) {
        var dst_idx = 0;
        for (var d = 0; d < ndim; d++) {
          dst_idx += Math.floor(i2 / src_strides[d]) % src_size[d] * dst_strides_perm[d];
        }
        dst_data[dst_idx] = src_data[i2];
      }
      return dst;
    }
    exports2.permute = permute;
    function ipermute(A, order) {
      var rev_order = order.concat();
      for (var d = 0; d < order.length; d++) {
        rev_order[order[d] - 1] = d + 1;
      }
      return permute(A, rev_order);
    }
    exports2.ipermute = ipermute;
  }
});

// node_modules/milsushi2/src/reduction.js
var require_reduction = __commonJS({
  "node_modules/milsushi2/src/reduction.js"(exports, module) {
    "use strict";
    var Matrix = require_matrix();
    var util = require_util();
    var func_generator = require_func_generator();
    function max_along_axis_old(A, dim) {
      if (dim == null) {
        dim = A._numel;
        for (var i2 = 0; i2 < A._size.length; i2++) {
          var dimsize = A._size[i2];
          if (dimsize !== 1) {
            dim = i2 + 1;
            break;
          }
        }
      }
      if (dim > A._ndims) {
        return A.copy();
      }
      var dstsize = A._size.slice();
      if (dstsize[dim - 1] !== 0) {
        dstsize[dim - 1] = 1;
      }
      if (A._numel === 0 || A._size[dim - 1] === 1) {
        var dst_onlyreshape = A.copy();
        dst_onlyreshape.reshape_inplace(dstsize);
        return dst_onlyreshape;
      }
      var dst = new Matrix(dstsize, A._klass);
      var input_strides = A._strides;
      var output_strides = dst._strides.slice();
      while (output_strides.length <= input_strides.length) {
        output_strides.push(dst._numel);
      }
      var reduction_step = input_strides[dim - 1];
      var reduction_count = A._size[dim - 1];
      var a_data = A._data;
      var dst_data = dst._data;
      var dims = A._ndims;
      for (var dst_idx = 0, dst_numel = dst._numel; dst_idx < dst_numel; dst_idx++) {
        var src_idx = 0;
        for (var d = 0; d < dims; d++) {
          src_idx += Math.floor(dst_idx % output_strides[d + 1] / output_strides[d]) * input_strides[d];
        }
        var val = a_data[src_idx];
        var curret = val;
        for (var red = 1; red < reduction_count; red++) {
          src_idx += reduction_step;
          val = a_data[src_idx];
          if (val > curret) {
            curret = val;
          }
        }
        dst_data[dst_idx] = curret;
      }
      return dst;
    }
    function _argmax_ones_like(A) {
      var amax = new Matrix(A._size, "int32");
      amax._data.fill(1);
      return { M: A, I: amax };
    }
    function make_reduction_along_axis(var_decl, var_update, result_assign, out_argmax) {
      var f;
      eval([
        "f = function(A, dim) {",
        "    if (dim == null) {",
        "        //select first non-1 axis",
        "        dim = A._numel;",
        "        for (var i = 0; i < A._size.length; i++) {",
        "            var dimsize = A._size[i];",
        "            if (dimsize !== 1) {",
        "                dim = i + 1;",
        "                break;",
        "            }",
        "        }",
        "    }",
        "    if (dim > A._ndims) {",
        "        //max along axis with size 1",
        out_argmax ? "return _argmax_ones_like(A.copy());" : "return A.copy();",
        "    }",
        "    var dstsize = A._size.slice();",
        "    if (dstsize[dim - 1] !== 0) {",
        "        //size 0 dimension is preserved",
        "        dstsize[dim - 1] = 1;",
        "    }",
        "    if (A._numel === 0) {",
        "        //only change shape",
        "        var dst_onlyreshape = A.copy();",
        "        dst_onlyreshape.reshape_inplace(dstsize);",
        out_argmax ? "return _argmax_ones_like(dst_onlyreshape);" : "return dst_onlyreshape;",
        "    }",
        "    //reduction actually needed",
        "    var dst = new Matrix(dstsize, A._klass);",
        out_argmax ? "var amax = new Matrix(dstsize, 'int32'); var amax_data = amax._data;" : "",
        "    var input_strides = A._strides;",
        "    var output_strides = dst._strides.slice();",
        "    while (output_strides.length <= input_strides.length) {",
        "        output_strides.push(dst._numel);",
        "    }",
        "    var reduction_step = input_strides[dim - 1];",
        "    var reduction_count = A._size[dim - 1];",
        "    var a_data = A._data;",
        "    var dst_data = dst._data;",
        "    var dims = A._ndims;",
        "    for (var dst_idx = 0, dst_numel = dst._numel; dst_idx < dst_numel; dst_idx++) {",
        "        var src_idx = 0;",
        "        for (var d = 0; d < dims; d++) {",
        "            src_idx += Math.floor(dst_idx % output_strides[d + 1] / output_strides[d]) * input_strides[d];",
        "        }",
        "        var val = a_data[src_idx];",
        var_decl,
        "        for (var red = 1; red < reduction_count; red++) {",
        "            src_idx += reduction_step;",
        "            val = a_data[src_idx];",
        var_update,
        "        }",
        result_assign,
        "    }",
        out_argmax ? "return {M:dst,I:amax};" : "return dst;",
        "}"
      ].join("\n"));
      return f;
    }
    function make_reduction_along_axis_stat(var_decl, var_update, result_assign) {
      var f;
      eval([
        "f = function(A, dim) {",
        "    if (dim == null) {",
        "        //select first non-1 axis",
        "        dim = A._numel;",
        "        for (var i = 0; i < A._size.length; i++) {",
        "            var dimsize = A._size[i];",
        "            if (dimsize !== 1) {",
        "                dim = i + 1;",
        "                break;",
        "            }",
        "        }",
        "    }",
        "    if (dim > A._ndims) {",
        "        //max along axis with size 1",
        "    }",
        "    var dstsize = A._size.slice();",
        "    if (dstsize[dim - 1] !== 0) {",
        "        //size 0 dimension is preserved",
        "        dstsize[dim - 1] = 1;",
        "    }",
        "    if (A._numel === 0) {",
        "        //only change shape",
        "        var dst_onlyreshape = A.copy();",
        "        dst_onlyreshape.reshape_inplace(dstsize);",
        "        return dst_onlyreshape;",
        "    }",
        "    //reduction actually needed",
        "    var dst = new Matrix(dstsize, 'single');",
        "    var input_strides = A._strides;",
        "    var output_strides = dst._strides.slice();",
        "    while (output_strides.length <= input_strides.length) {",
        "        output_strides.push(dst._numel);",
        "    }",
        "    var reduction_step = input_strides[dim - 1];",
        "    var reduction_count = A._size[dim - 1];",
        "    var a_data = A._data;",
        "    var dst_data = dst._data;",
        "    var dims = A._ndims;",
        "    for (var dst_idx = 0, dst_numel = dst._numel; dst_idx < dst_numel; dst_idx++) {",
        "        var src_idx = 0;",
        "        for (var d = 0; d < dims; d++) {",
        "            src_idx += Math.floor(dst_idx % output_strides[d + 1] / output_strides[d]) * input_strides[d];",
        "        }",
        "        var val = a_data[src_idx];",
        var_decl,
        "        for (var red = 1; red < reduction_count; red++) {",
        "            src_idx += reduction_step;",
        "            val = a_data[src_idx];",
        var_update,
        "        }",
        result_assign,
        "    }",
        "return dst;",
        "}"
      ].join("\n"));
      return f;
    }
    var max_along_axis = make_reduction_along_axis("var curret = val;", "if(val>curret){curret=val;}", "dst_data[dst_idx]=curret;", false);
    var max_elementwise = func_generator.make_binary_arith_func_all("Math.max(%a,%b)");
    var min_along_axis = make_reduction_along_axis("var curret = val;", "if(val<curret){curret=val;}", "dst_data[dst_idx]=curret;", false);
    var min_elementwise = func_generator.make_binary_arith_func_all("Math.min(%a,%b)");
    function max(A, B, dim) {
      if (B == null) {
        return max_along_axis(util.as_mat(A), dim);
      } else {
        return max_elementwise(A, B);
      }
    }
    exports.max = max;
    function min(A, B, dim) {
      if (B == null) {
        return min_along_axis(util.as_mat(A), dim);
      } else {
        return min_elementwise(A, B);
      }
    }
    exports.min = min;
    var argmax_along_axis = make_reduction_along_axis("var curret = val, curamax = 0;", "if(val>curret){curret=val;curamax=red;}", "dst_data[dst_idx]=curret; amax_data[dst_idx]=curamax+1;", true);
    function argmax(A, dummy, dim) {
      return argmax_along_axis(util.as_mat(A), dim);
    }
    exports.argmax = argmax;
    var argmin_along_axis = make_reduction_along_axis("var curret = val, curamax = 0;", "if(val<curret){curret=val;curamax=red;}", "dst_data[dst_idx]=curret; amax_data[dst_idx]=curamax+1;", true);
    function argmin(A, dummy, dim) {
      return argmin_along_axis(util.as_mat(A), dim);
    }
    exports.argmin = argmin;
    function sum_mean(A, args, f2) {
      var dim = void 0;
      var outtype = void 0;
      while (args.length > 0) {
        var arg = args.pop();
        if (typeof arg === "string") {
          if (arg != "native") {
            throw new Error("Outtype other than native is currently not supported");
          }
        } else if (typeof arg === "number") {
          dim = arg;
        } else {
          throw new Error("Unknown argument " + arg);
        }
      }
      return f2(A, dim);
    }
    var sum_along_axis = make_reduction_along_axis_stat("var curret = val;", "curret += val;", "dst_data[dst_idx] = curret;");
    function sum(A) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      return sum_mean(A, args, sum_along_axis);
    }
    exports.sum = sum;
    var mean_along_axis = make_reduction_along_axis_stat("var curret = val;", "curret += val;", "dst_data[dst_idx] = curret / reduction_count;");
    function mean(A) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      return sum_mean(A, args, mean_along_axis);
    }
    exports.mean = mean;
    var prod_along_axis = make_reduction_along_axis_stat("var curret = val;", "curret *= val;", "dst_data[dst_idx] = curret;");
    function prod(A) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      return sum_mean(A, args, prod_along_axis);
    }
    exports.prod = prod;
    var variance_along_axis_w0 = make_reduction_along_axis_stat("var normalsum = val; var sqsum = val * val;", "normalsum += val; sqsum += val * val;", "dst_data[dst_idx] = (sqsum - normalsum * normalsum / reduction_count) / Math.max(reduction_count - 1, 1);");
    var variance_along_axis_w1 = make_reduction_along_axis_stat("var normalsum = val; var sqsum = val * val;", "normalsum += val; sqsum += val * val;", "dst_data[dst_idx] = (sqsum - normalsum * normalsum / reduction_count) / reduction_count;");
    function variance(A, w, dim) {
      if (w === void 0) {
        w = 0;
      }
      if (w == 0) {
        return variance_along_axis_w0(A, dim);
      } else if (w == 1) {
        return variance_along_axis_w1(A, dim);
      } else {
        throw new Error("w must be 0 or 1");
      }
    }
    exports.variance = variance;
    var std_along_axis_w0 = make_reduction_along_axis_stat("var normalsum = val; var sqsum = val * val;", "normalsum += val; sqsum += val * val;", "dst_data[dst_idx] = Math.sqrt((sqsum - normalsum * normalsum / reduction_count) / Math.max(reduction_count - 1, 1));");
    var std_along_axis_w1 = make_reduction_along_axis_stat("var normalsum = val; var sqsum = val * val;", "normalsum += val; sqsum += val * val;", "dst_data[dst_idx] = Math.sqrt((sqsum - normalsum * normalsum / reduction_count) / reduction_count);");
    function std(A, w, dim) {
      if (w === void 0) {
        w = 0;
      }
      if (w == 0) {
        return std_along_axis_w0(A, dim);
      } else if (w == 1) {
        return std_along_axis_w1(A, dim);
      } else {
        throw new Error("w must be 0 or 1");
      }
    }
    exports.std = std;
  }
});

// node_modules/milsushi2/src/mul.js
var require_mul = __commonJS({
  "node_modules/milsushi2/src/mul.js"(exports2) {
    "use strict";
    var Matrix2 = require_matrix();
    function mtimes(A, B) {
      if (A._ndims != 2 || B._ndims != 2) {
        throw new Error("Matrix must be two-dimensional");
      }
      if (A._size[1] != B._size[0]) {
        throw new Error("Shape mismatch");
      }
      if (A._klass != "single" || B._klass != "single") {
        throw new Error("Matrix klass must be single");
      }
      var m = A._size[0], n = B._size[1], k = A._size[1];
      var lda = A._strides[1];
      var ldb = B._strides[1];
      var data_a = A._data;
      var data_b = B._data;
      var dst = new Matrix2([m, n], "single");
      var ldc = dst._strides[1];
      var data_c = dst._data;
      for (var i2 = 0; i2 < m; i2++) {
        for (var j = 0; j < n; j++) {
          var sum2 = 0;
          for (var r = 0; r < k; r++) {
            sum2 += data_a[i2 + r * lda] * data_b[r + j * ldb];
          }
          data_c[i2 + j * ldc] = sum2;
        }
      }
      return dst;
    }
    exports2.mtimes = mtimes;
  }
});

// node_modules/milsushi2/src/io/npy.js
var require_npy = __commonJS({
  "node_modules/milsushi2/src/io/npy.js"(exports2) {
    "use strict";
    var Matrix2 = require_matrix();
    function parse_header(header_data) {
      var header_str = "";
      for (var i2 = 0; i2 < header_data.length; i2++) {
        var element = header_data[i2];
        header_str += String.fromCharCode(element);
      }
      var hobj = /^\{'descr': '(.*)', 'fortran_order': (True|False), 'shape': \(([0-9, ]+)\), \} *\n$/.exec(header_str);
      if (hobj == null) {
        throw Error("Failed to parse header string");
      }
      var typechars = hobj[1];
      var little_endian = true;
      switch (typechars.substr(0, 1)) {
        case "<":
        case "|":
          little_endian = true;
          break;
        case ">":
          little_endian = false;
          break;
        default:
          throw Error("Unknown endian");
      }
      var descr_wo_endian = typechars.substr(1, 2);
      var fortran_order = hobj[2] == "True";
      var shape_str = hobj[3].split(",");
      var shape;
      if (shape_str[1] == "") {
        shape = [Number(shape_str[0]), 1];
      } else {
        shape = shape_str.map(function(v) {
          return Number(v.trim());
        });
      }
      return { descr_wo_endian, fortran_order, shape, little_endian };
    }
    function is_little_endian() {
      var raw = new Uint8Array([1, 2, 3, 4]);
      var view = new Uint32Array(raw.buffer);
      if (view[0] == 16909060) {
        return false;
      } else {
        return true;
      }
    }
    var mat_klass_map = {
      "b1": "logical",
      "u1": "uint8",
      "i4": "int32",
      "f4": "single",
      "f8": "single"
    };
    var view_accessor_map = {
      "b1": DataView.prototype.getUint8,
      "u1": DataView.prototype.getUint8,
      "i4": DataView.prototype.getInt32,
      "f4": DataView.prototype.getFloat32,
      "f8": DataView.prototype.getFloat64
    };
    var view_bytestep_map = { "b1": 1, "u1": 1, "i4": 4, "f4": 4, "f8": 8 };
    function npyread(data) {
      var byteOffset = 0;
      if (ArrayBuffer.isView(data)) {
        byteOffset = data.byteOffset;
        data = data.buffer;
      }
      var header_view = new Uint8Array(data, byteOffset);
      var expect_header = [147, 78, 85, 77, 80, 89, 1, 0];
      for (var i2 = 0; i2 < expect_header.length; i2++) {
        if (header_view[i2] != expect_header[i2]) {
          throw Error("Incompatible format header");
        }
      }
      var header_len = header_view[8] + header_view[9] * 256;
      var data_type = parse_header(header_view.slice(10, 10 + header_len));
      var mat_klass = mat_klass_map[data_type.descr_wo_endian];
      if (mat_klass == null) {
        throw Error("Unsupported data type");
      }
      var data_view = new DataView(data, byteOffset + 10 + header_len);
      var mat = new Matrix2(data_type.shape, mat_klass);
      var mat_data = mat.getdataref();
      var view_accessor = view_accessor_map[data_type.descr_wo_endian];
      var view_bytestep = view_bytestep_map[data_type.descr_wo_endian];
      var numel = mat._numel;
      var view_little_endian = data_type.little_endian;
      if (data_type.fortran_order) {
        for (var i2 = 0; i2 < numel; i2++) {
          var val = view_accessor.call(data_view, view_bytestep * i2, view_little_endian);
          mat_data[i2] = val;
        }
      } else {
        var size = mat._size;
        var cstride = [];
        var fstride = [];
        var last_cstride = 1;
        var last_fstride = 1;
        for (var dim = 0; dim < size.length; dim++) {
          cstride.unshift(last_cstride);
          fstride.push(last_fstride);
          last_cstride *= size[size.length - 1 - dim];
          last_fstride *= size[dim];
        }
        for (var i2 = 0; i2 < numel; i2++) {
          var val = view_accessor.call(data_view, view_bytestep * i2, view_little_endian);
          var fidx = 0;
          for (var dim = 0; dim < size.length; dim++) {
            fidx += Math.floor(i2 / cstride[dim]) % size[dim] * fstride[dim];
          }
          mat_data[fidx] = val;
        }
      }
      return mat;
    }
    exports2.npyread = npyread;
    var save_klass_map = { "logical": "b1", "uint8": "u1", "int32": "i4", "single": "f4" };
    function npysave(A) {
      var klass = A._klass;
      var endian_char;
      switch (klass) {
        case "logical":
        case "uint8":
          endian_char = "|";
          break;
        default:
          endian_char = is_little_endian() ? "<" : ">";
          break;
      }
      var header_str = "{'descr': '" + endian_char + save_klass_map[klass] + "', 'fortran_order': True, 'shape': (" + A._size.join(", ") + "), }";
      var pad_len = 16 - (header_str.length + 11) % 16;
      header_str += "                ".substr(0, pad_len) + "\n";
      var header_len = header_str.length;
      var header_total_len = header_len + 10;
      var dst_size = A._numel * A._data_ctor.BYTES_PER_ELEMENT + header_total_len;
      var dst = new ArrayBuffer(dst_size);
      var dst_byte_offset = 0;
      var header_dst_view = new Uint8Array(dst, dst_byte_offset, header_total_len);
      var const_header = [147, 78, 85, 77, 80, 89, 1, 0];
      for (var i2 = 0; i2 < const_header.length; i2++) {
        header_dst_view[i2] = const_header[i2];
      }
      header_dst_view[8] = header_len % 256;
      header_dst_view[9] = Math.floor(header_len / 256);
      for (var i2 = 0; i2 < header_len; i2++) {
        header_dst_view[10 + i2] = header_str.charCodeAt(i2);
      }
      var body_dst_view = new A._data_ctor(dst, dst_byte_offset + header_total_len, A._numel);
      body_dst_view.set(A.getdataref());
      return dst;
    }
    exports2.npysave = npysave;
  }
});

// node_modules/milsushi2/src/cl/handwrittenjs/driver_opencl.js
var require_driver_opencl = __commonJS({
  "node_modules/milsushi2/src/cl/handwrittenjs/driver_opencl.js"(exports2, module2) {
    "use strict";
    (function() {
      var $M = require_sushi();
      var $CL = {};
      $CL.WebCL = createWebCLObject();
      initWebCL($CL.WebCL);
      initUtilityMethods($CL.WebCL);
      function createWebCLObject() {
        var web_cl;
        try {
          web_cl = __require("node-opencl");
        } catch (e) {
          web_cl = void 0;
        }
        return web_cl;
      }
      function initWebCL(WebCL2) {
        var platform_list = WebCL2.getPlatformIDs();
        var platform_index = 0;
        if ("OPENCL_PLATFORM_INDEX" in process.env) {
          platform_index = Number(process.env["OPENCL_PLATFORM_INDEX"]);
          if (platform_index >= platform_list.length) {
            throw new Error("Invalid platform index " + platform_index);
          }
        } else {
          var platform_priority = ["CUDA", "AMD", "Apple", "OpenCL"];
          var priority = platform_priority.length + 1;
          var includeIndexOf = function(array, search) {
            for (var i3 = 0; i3 < array.length; i3++) {
              if (search.indexOf(array[i3]) !== -1) {
                return i3;
              }
            }
            return array.length;
          };
          for (var i2 = 0; i2 < platform_list.length; i2++) {
            var platform_tmp = platform_list[i2];
            var platform_info_tmp = WebCL2.getPlatformInfo(platform_tmp, WebCL2.PLATFORM_NAME);
            var priority_tmp = includeIndexOf(platform_priority, platform_info_tmp);
            if (priority_tmp < priority) {
              priority = priority_tmp;
              platform_index = i2;
              $CL.platform = platform_tmp;
              $CL.platform_info = platform_info_tmp;
            }
          }
        }
        $CL.platform = platform_list[platform_index];
        $CL.platform_info = WebCL2.getPlatformInfo($CL.platform, WebCL2.PLATFORM_NAME);
        try {
          var device_type = WebCL2.DEVICE_TYPE_GPU;
          $CL.devices = WebCL2.getDeviceIDs($CL.platform, device_type);
        } catch (ex) {
          $CL.devices = [];
        }
        if ($CL.devices.length === 0) {
          device_type = WebCL2.DEVICE_TYPE_CPU;
          $CL.devices = WebCL2.getDeviceIDs($CL.platform, device_type);
          ;
        }
        var device_index = 0;
        if ("OPENCL_DEVICE_INDEX" in process.env) {
          device_index = Number(process.env["OPENCL_DEVICE_INDEX"]);
          if (device_index >= $CL.devices.length) {
            throw new Error("Invalid device index " + device_index);
          }
        }
        $CL.selected_device = $CL.devices[device_index];
        $CL.device_info = WebCL2.getDeviceInfo($CL.selected_device, WebCL2.DEVICE_NAME);
        $CL.device_max_work_group_size = WebCL2.getDeviceInfo($CL.selected_device, WebCL2.DEVICE_MAX_WORK_GROUP_SIZE);
        WebCL2.type = {
          CHAR: 0,
          UCHAR: 1,
          SHORT: 2,
          USHORT: 3,
          INT: 4,
          UINT: 5,
          LONG: 6,
          ULONG: 7,
          FLOAT: 8,
          HALF: 9,
          DOUBLE: 10,
          QUAD: 11,
          LONG_LONG: 12,
          VEC2: 65536,
          VEC3: 131072,
          VEC4: 262144,
          VEC8: 524288,
          VEC16: 1048576,
          LOCAL_MEMORY_SIZE: 255
        };
        var table_primitive = {};
        table_primitive[WebCL2.type.CHAR] = "char";
        table_primitive[WebCL2.type.UCHAR] = "uchar";
        table_primitive[WebCL2.type.SHORT] = "short";
        table_primitive[WebCL2.type.USHORT] = "ushort";
        table_primitive[WebCL2.type.INT] = "int";
        table_primitive[WebCL2.type.UINT] = "uint";
        table_primitive[WebCL2.type.LONG] = "long";
        table_primitive[WebCL2.type.ULONG] = "ulong";
        table_primitive[WebCL2.type.FLOAT] = "float";
        table_primitive[WebCL2.type.HALF] = "half";
        table_primitive[WebCL2.type.DOUBLE] = "double";
        table_primitive[WebCL2.type.QUAD] = "quad";
        table_primitive[WebCL2.type.LONG_LONG] = "long long";
        var table_vec_len = {};
        table_vec_len[0] = 1;
        table_vec_len[WebCL2.type.VEC2] = 2;
        table_vec_len[WebCL2.type.VEC3] = 3;
        table_vec_len[WebCL2.type.VEC4] = 4;
        table_vec_len[WebCL2.type.VEC8] = 8;
        table_vec_len[WebCL2.type.VEC16] = 16;
        $CL.context = WebCL2.createContext([WebCL2.CONTEXT_PLATFORM, $CL.platform, 0], [$CL.selected_device]);
        $CL.kernelSetArg = function(kernel, idx, param, type) {
          var typestr = "";
          if (type !== void 0) {
            if (type == WebCL2.type.LOCAL_MEMORY_SIZE) {
              typestr = "local";
            } else {
              var primitive = type & 255;
              typestr = table_primitive[primitive];
              var vec = type & 2031616;
              var vec_len = table_vec_len[vec];
              if (vec_len > 1) {
                typestr += vec_len;
              }
            }
          } else {
            typestr = "cl_mem";
          }
          WebCL2.setKernelArg(kernel, idx, typestr, param);
        };
        if (WebCL2.createCommandQueueWithProperties !== void 0) {
          $CL.queue = WebCL2.createCommandQueueWithProperties($CL.context, $CL.selected_device, []);
        } else {
          $CL.queue = WebCL2.createCommandQueue($CL.context, $CL.selected_device, 0);
        }
        $CL.buffers = 0;
      }
      function initUtilityMethods(WebCL2) {
        $CL.createKernel = function(code, name) {
          if (!name) {
            name = "kernel_func";
          }
          var program = WebCL2.createProgramWithSource($CL.context, code);
          WebCL2.buildProgram(program);
          return WebCL2.createKernel(program, name);
        };
        $CL.createBuffer = function(byte_length) {
          var buffer = WebCL2.createBuffer($CL.context, WebCL2.MEM_READ_WRITE, byte_length);
          $CL.buffers++;
          return buffer;
        };
        $CL.writeBuffer = function(buffer, typed_array, offset) {
          if (offset === void 0) {
            offset = 0;
          }
          WebCL2.enqueueWriteBuffer(
            $CL.queue,
            buffer,
            true,
            offset,
            typed_array.byteLength,
            typed_array
          );
        };
        $CL.executeKernel = function(kernel, params, parallelization, localWS) {
          for (var i2 = 0; i2 < params.length; i2++) {
            if (params[i2].type === void 0) {
              $CL.kernelSetArg(kernel, i2, params[i2].datum._clbuffer);
            } else {
              $CL.kernelSetArg(kernel, i2, params[i2].datum, params[i2].type);
            }
          }
          if (parallelization != null && parallelization.length === void 0) {
            parallelization = [parallelization];
          }
          if (localWS != null && localWS.length === void 0) {
            localWS = [localWS];
          }
          var globalWS;
          if (localWS == null) {
            var localWS_each = [64, 64, 8, 4][parallelization.length];
            localWS = [];
            globalWS = [];
            for (var i2 = 0; i2 < parallelization.length; i2++) {
              localWS.push(localWS_each);
              globalWS.push(Math.ceil(parallelization[i2] / localWS_each) * localWS_each);
            }
          } else {
            globalWS = [];
            for (var i2 = 0; i2 < parallelization.length; i2++) {
              globalWS.push(Math.ceil(parallelization[i2] / localWS[i2]) * localWS[i2]);
            }
          }
          WebCL2.enqueueNDRangeKernel(
            $CL.queue,
            kernel,
            globalWS.length,
            null,
            globalWS,
            localWS
          );
          $CL.flush();
        };
        $CL.flush = function() {
          WebCL2.flush($CL.queue);
        };
        $CL.finish = function() {
          WebCL2.finish($CL.queue);
        };
        $CL.readBuffer = function(buffer, typed_array, offset) {
          if (offset === void 0) {
            offset = 0;
          }
          WebCL2.enqueueReadBuffer(
            $CL.queue,
            buffer,
            true,
            offset,
            typed_array.byteLength,
            typed_array
          );
        };
        $CL.releaseBuffer = function(buffer) {
          WebCL2.releaseMemObject(buffer);
          $CL.buffers--;
        };
      }
      module2.exports = $CL;
    })();
  }
});

// node_modules/milsushi2/src/cl/handwrittenjs/driver_webcl.js
var require_driver_webcl = __commonJS({
  "node_modules/milsushi2/src/cl/handwrittenjs/driver_webcl.js"(exports2, module2) {
    "use strict";
    (function() {
      var $M = require_sushi();
      var $CL = {};
      var env = getEnvironment();
      $CL.WebCL = createWebCLObject();
      initWebCL($CL.WebCL);
      initUtilityMethods($CL.WebCL);
      function getEnvironment() {
        var env2;
        if (typeof window !== "undefined" && window.webcl !== void 0) {
          env2 = "ff";
        } else if (typeof WebCL === "function") {
          env2 = "chromium";
        } else {
          throw new Error("WebCL object not found. WebCL may be not supported on this browser.");
        }
        return env2;
      }
      function createWebCLObject() {
        var web_cl = void 0;
        switch (env) {
          case "chromium":
            web_cl = new WebCL();
            break;
          case "ff":
            web_cl = window.webcl;
            break;
        }
        return web_cl;
      }
      function initWebCL(WebCL2) {
        var platform_list = WebCL2.getPlatforms();
        var platform_index = 0;
        var platform_priority = ["CUDA", "AMD", "Apple", "OpenCL"];
        var priority = platform_priority.length + 1;
        var includeIndexOf = function(array, search) {
          for (var i3 = 0; i3 < array.length; i3++) {
            if (search.indexOf(array[i3]) !== -1) {
              return i3;
            }
          }
          return array.length;
        };
        for (var i2 = 0; i2 < platform_list.length; i2++) {
          var platform_tmp = platform_list[i2];
          var platform_info_tmp = platform_tmp.getInfo(WebCL2.PLATFORM_NAME);
          var priority_tmp = includeIndexOf(platform_priority, platform_info_tmp);
          if (priority_tmp < priority) {
            priority = priority_tmp;
            platform_index = i2;
            $CL.platform = platform_tmp;
            $CL.platform_info = platform_info_tmp;
          }
        }
        $CL.platform = platform_list[platform_index];
        $CL.platform_info = $CL.platform.getInfo(WebCL2.PLATFORM_NAME);
        try {
          var device_type = WebCL2.DEVICE_TYPE_GPU;
          $CL.devices = $CL.platform.getDevices(device_type);
        } catch (ex) {
          $CL.devices = [];
        }
        if ($CL.devices.length === 0) {
          device_type = WebCL2.DEVICE_TYPE_CPU;
          $CL.devices = $CL.platform.getDevices(device_type);
          ;
        }
        var device_index = 0;
        var url_vars = function() {
          var vars = {};
          var param = location.search.substring(1).split("&");
          for (var i3 = 0; i3 < param.length; i3++) {
            var keySearch = param[i3].search(/=/);
            var key = "";
            if (keySearch != -1)
              key = param[i3].slice(0, keySearch);
            var val = param[i3].slice(param[i3].indexOf("=", 0) + 1);
            if (key != "")
              vars[key] = decodeURI(val);
          }
          return vars;
        }();
        device_index = url_vars.device_index ? Math.min(url_vars.device_index, $CL.devices.length - 1) : 0;
        $CL.selected_device = $CL.devices[device_index];
        $CL.device_info = $CL.selected_device.getInfo(WebCL2.DEVICE_NAME);
        $CL.device_max_work_group_size = $CL.selected_device.getInfo(WebCL2.DEVICE_MAX_WORK_GROUP_SIZE);
        WebCL2.type = {
          CHAR: 0,
          UCHAR: 1,
          SHORT: 2,
          USHORT: 3,
          INT: 4,
          UINT: 5,
          LONG: 6,
          ULONG: 7,
          FLOAT: 8,
          HALF: 9,
          DOUBLE: 10,
          QUAD: 11,
          LONG_LONG: 12,
          VEC2: 65536,
          VEC3: 131072,
          VEC4: 262144,
          VEC8: 524288,
          VEC16: 1048576,
          LOCAL_MEMORY_SIZE: 255
        };
        switch (env) {
          case "ff":
            $CL.context = WebCL2.createContext($CL.platform, device_type);
            var table_primitive = {};
            table_primitive[WebCL2.type.CHAR] = Uint8Array;
            table_primitive[WebCL2.type.UCHAR] = Int8Array;
            table_primitive[WebCL2.type.SHORT] = Int16Array;
            table_primitive[WebCL2.type.USHORT] = Uint16Array;
            table_primitive[WebCL2.type.INT] = Int32Array;
            table_primitive[WebCL2.type.UINT] = Uint32Array;
            table_primitive[WebCL2.type.LONG] = Int32Array;
            table_primitive[WebCL2.type.ULONG] = Uint32Array;
            table_primitive[WebCL2.type.FLOAT] = Float32Array;
            table_primitive[WebCL2.type.HALF] = Float32Array;
            table_primitive[WebCL2.type.DOUBLE] = Float64Array;
            table_primitive[WebCL2.type.QUAD] = Float32Array;
            table_primitive[WebCL2.type.LONG_LONG] = Float32Array;
            var table_vec_len = {};
            table_vec_len[0] = 1;
            table_vec_len[WebCL2.type.VEC2] = 2;
            table_vec_len[WebCL2.type.VEC3] = 3;
            table_vec_len[WebCL2.type.VEC4] = 4;
            table_vec_len[WebCL2.type.VEC8] = 8;
            table_vec_len[WebCL2.type.VEC16] = 16;
            $CL.kernelSetArg = function(kernel, idx, param, type) {
              if (type !== void 0) {
                if (type == WebCL2.type.LOCAL_MEMORY_SIZE) {
                  param = new Uint32Array([param]);
                } else {
                  var primitive = type & 255;
                  var array_ctor = table_primitive[primitive];
                  var vec = type & 2031616;
                  var vec_len = table_vec_len[vec];
                  if (vec_len > 1) {
                    param = new array_ctor(param);
                  } else {
                    param = new array_ctor([param]);
                  }
                }
              }
              kernel.setArg(idx, param);
            };
            break;
          case "chromium":
            var properties = new WebCLContextProperties();
            properties.platform = $CL.platform;
            properties.deviceType = device_type;
            properties.devices = $CL.devices;
            properties.shareGroup = 1;
            $CL.context = WebCL2.createContext(properties);
            $CL.kernelSetArg = function(kernel, idx, param, type) {
              if (type !== void 0) {
                switch (type) {
                  case WebCL2.type.UINT:
                    var type_tmp = WebCL2.KERNEL_ARG_UINT;
                    break;
                  case WebCL2.type.INT:
                    var type_tmp = WebCL2.KERNEL_ARG_INT;
                    break;
                  case WebCL2.type.FLOAT:
                    var type_tmp = WebCL2.KERNEL_ARG_FLOAT;
                    break;
                }
                kernel.setKernelArg(idx, param, type_tmp);
              } else {
                kernel.setKernelArgGlobal(idx, param);
              }
            };
            break;
        }
        switch (env) {
          case "ff":
            $CL.queue = $CL.context.createCommandQueue($CL.selected_device, 0);
            break;
          case "chromium":
            $CL.queue = $CL.context.createCommandQueue($CL.devices, null);
            break;
        }
        $CL.buffers = 0;
      }
      function initUtilityMethods(WebCL2) {
        $CL.createKernel = function(code, name) {
          if (!name) {
            name = "kernel_func";
          }
          var program = $CL.context.createProgram(code);
          switch (env) {
            case "ff":
              program.build($CL.devices);
              break;
            case "chromium":
              program.buildProgram(null, null, null);
              break;
          }
          return program.createKernel(name);
        };
        $CL.createBuffer = function(byte_length) {
          var buffer = $CL.context.createBuffer(WebCL2.MEM_READ_WRITE, byte_length);
          $CL.buffers++;
          return buffer;
        };
        $CL.writeBuffer = function(buffer, typed_array, offset) {
          if (offset === void 0) {
            offset = 0;
          }
          if (typed_array.byteOffset === 0) {
            $CL.queue.enqueueWriteBuffer(
              buffer,
              true,
              offset,
              typed_array.byteLength,
              typed_array
            );
          } else {
            var tmpbuf = new typed_array.constructor(typed_array);
            $CL.queue.enqueueWriteBuffer(
              buffer,
              true,
              offset,
              tmpbuf.byteLength,
              tmpbuf
            );
          }
        };
        $CL.executeKernel = function(kernel, params, parallelization, localWS) {
          for (var i2 = 0; i2 < params.length; i2++) {
            if (params[i2].type === void 0) {
              $CL.kernelSetArg(kernel, i2, params[i2].datum._clbuffer);
            } else {
              $CL.kernelSetArg(kernel, i2, params[i2].datum, params[i2].type);
            }
          }
          if (parallelization != null && parallelization.length === void 0) {
            parallelization = [parallelization];
          }
          if (localWS != null && localWS.length === void 0) {
            localWS = [localWS];
          }
          var globalWS;
          if (localWS == null) {
            var localWS_each = [64, 64, 8, 4][parallelization.length];
            localWS = [];
            globalWS = [];
            for (var i2 = 0; i2 < parallelization.length; i2++) {
              localWS.push(localWS_each);
              globalWS.push(Math.ceil(parallelization[i2] / localWS_each) * localWS_each);
            }
          } else {
            globalWS = [];
            for (var i2 = 0; i2 < parallelization.length; i2++) {
              globalWS.push(Math.ceil(parallelization[i2] / localWS[i2]) * localWS[i2]);
            }
          }
          switch (env) {
            case "ff":
              $CL.queue.enqueueNDRangeKernel(
                kernel,
                globalWS.length,
                null,
                globalWS,
                localWS
              );
              break;
            case "chromium":
              globalWS = new Int32Array(globalWS);
              $CL.queue.enqueueNDRangeKernel(
                kernel,
                null,
                globalWS,
                localWS
              );
              $CL.queue.finish();
              break;
          }
          $CL.queue.flush();
        };
        $CL.flush = function() {
          $CL.queue.flush();
        };
        $CL.finish = function() {
          $CL.queue.finish();
        };
        $CL.readBuffer = function(buffer, typed_array, offset) {
          if (offset === void 0) {
            offset = 0;
          }
          if (typed_array.byteOffset === 0) {
            $CL.queue.enqueueReadBuffer(
              buffer,
              true,
              offset,
              typed_array.byteLength,
              typed_array
            );
          } else {
            var tmpbuf = new typed_array.constructor(typed_array.length);
            $CL.queue.enqueueReadBuffer(
              buffer,
              true,
              offset,
              tmpbuf.byteLength,
              tmpbuf
            );
            typed_array.set(tmpbuf);
          }
        };
        switch (env) {
          case "ff":
            $CL.releaseBuffer = function(buffer) {
              buffer.release();
              $CL.buffers--;
            };
            break;
          case "chromium":
            $CL.releaseBuffer = function(buffer) {
              buffer.releaseCL();
              $CL.buffers--;
            };
            break;
        }
      }
      module2.exports = $CL;
    })();
  }
});

// node_modules/milsushi2/src/cl/handwrittenjs/driver.js
var require_driver = __commonJS({
  "node_modules/milsushi2/src/cl/handwrittenjs/driver.js"(exports2, module2) {
    "use strict";
    (function() {
      var $CL;
      if (typeof window === "undefined") {
        $CL = require_driver_opencl();
      } else {
        $CL = require_driver_webcl();
      }
      module2.exports = $CL;
    })();
  }
});

// node_modules/milsushi2/src/cl/matrix_cl.js
var require_matrix_cl = __commonJS({
  "node_modules/milsushi2/src/cl/matrix_cl.js"(exports2, module2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var Matrix2 = require_matrix();
    var Colon2 = require_colon();
    var $CL = require_driver();
    var WebCL2 = $CL.WebCL;
    var ctypes = { single: "float", int32: "int", uint8: "uchar", logical: "uchar" };
    var webcltypes = { single: WebCL2.type.FLOAT, int32: WebCL2.type.INT, uint8: WebCL2.type.UCHAR, logical: WebCL2.type.UCHAR };
    var MatrixCL = function(_super) {
      __extends(MatrixCL2, _super);
      function MatrixCL2(size, klass) {
        var _this = _super.call(this, size, klass, true) || this;
        var buffer_size = _this._numel * _this._data_ctor.BYTES_PER_ELEMENT;
        if (_this._numel == 0) {
          buffer_size = 4;
        }
        _this._clbuffer = $CL.createBuffer(buffer_size);
        return _this;
      }
      MatrixCL2.prototype.to_cpu = function() {
        var cpumat = new Matrix2(this._size, this._klass);
        this.read(cpumat._data);
        return cpumat;
      };
      MatrixCL2.prototype.throw_if_destructed = function() {
        if (!this._clbuffer) {
          throw new Error("Attempting use destructed matrix");
        }
      };
      MatrixCL2.prototype.write = function(src_typed_array, dst_bytes_offset) {
        this.throw_if_destructed();
        if (src_typed_array.length > 0) {
          $CL.writeBuffer(this._clbuffer, src_typed_array, dst_bytes_offset);
        }
      };
      MatrixCL2.prototype.read = function(dst_typed_array, src_bytes_offset) {
        this.throw_if_destructed();
        if (dst_typed_array.length > 0) {
          $CL.readBuffer(this._clbuffer, dst_typed_array, src_bytes_offset);
        }
      };
      MatrixCL2._fromnativemat = function(A) {
        if (A instanceof MatrixCL2) {
          return A.copy();
        } else {
          var matcl = new MatrixCL2(A._size, A._klass);
          matcl.write(A._getdata());
          return matcl;
        }
      };
      MatrixCL2._fromtypedarray = function(src_typed_array, klass) {
        var mat = new MatrixCL2([1, src_typed_array.length], klass);
        mat.write(src_typed_array);
        return mat;
      };
      MatrixCL2.prototype.destruct = function() {
        if (this._clbuffer) {
          $CL.releaseBuffer(this._clbuffer);
          this._clbuffer = null;
        }
      };
      MatrixCL2.prototype.inspect = function(depth) {
        var shape_str = this._size.join("x");
        if (this._numel <= 100) {
          return "MatrixCL " + shape_str + " " + this._klass + "\n" + this.toString();
        } else {
          return "MatrixCL " + shape_str + " " + this._klass;
        }
      };
      MatrixCL2.prototype._getdata = function() {
        var typed_array = new this._data_ctor(this._numel);
        this.read(typed_array);
        return typed_array;
      };
      MatrixCL2.prototype.getdataref = function(src_offset, length) {
        if (src_offset === void 0) {
          src_offset = 0;
        }
        if (length == null) {
          length = this._numel - src_offset;
        }
        var typed_array = new this._data_ctor(length);
        this.read(typed_array, src_offset * this._data_ctor.BYTES_PER_ELEMENT);
        return typed_array;
      };
      MatrixCL2.prototype.getdatacopy = function(src_offset, length, dst) {
        if (src_offset === void 0) {
          src_offset = 0;
        }
        if (length == null) {
          length = this._numel - src_offset;
        }
        if (!dst) {
          dst = new this._data_ctor(length);
        }
        var range_view = new this._data_ctor(dst.buffer, dst.byteOffset, length);
        this.read(range_view, src_offset * this._data_ctor.BYTES_PER_ELEMENT);
        return dst;
      };
      MatrixCL2.prototype.setdata = function(src, dst_offset) {
        if (dst_offset === void 0) {
          dst_offset = 0;
        }
        this.write(src, dst_offset * this._data_ctor.BYTES_PER_ELEMENT);
      };
      MatrixCL2.get_cast_str = function(dst_klass2, src_klass) {
        var cast_str;
        if (src_klass == dst_klass2) {
          cast_str = "(x)";
        } else if (dst_klass2 != "logical") {
          cast_str = "(" + dst_klass2 + ")(x)";
        } else {
          cast_str = "((x != 0) ? 1 : 0)";
        }
        return cast_str;
      };
      MatrixCL2.prototype.copy = function(klass) {
        var clone = new MatrixCL2(this._size, klass || this._klass);
        var kernel_name = "copy_" + clone._klass + "_" + this._klass;
        var kernel = MatrixCL2.kernel_cache[kernel_name];
        if (!kernel) {
          kernel = $CL.createKernel([
            "#define DST_TYPE " + ctypes[clone._klass],
            "#define SRC_TYPE " + ctypes[this._klass],
            "#define TYPE_CAST(x) " + MatrixCL2.get_cast_str(clone._klass, this._klass),
            "__kernel void kernel_func(__global DST_TYPE *dst, __global SRC_TYPE *src, uint length) {",
            "  uint i = get_global_id(0);",
            "  if (i >= length) { return; }",
            "  dst[i] = TYPE_CAST(src[i]);",
            "}"
          ].join("\n"));
          MatrixCL2.kernel_cache[kernel_name] = kernel;
        }
        if (this._numel > 0) {
          $CL.executeKernel(kernel, [
            { access: WebCL2.MEM_WRITE_ONLY, datum: clone },
            { access: WebCL2.MEM_READ_ONLY, datum: this },
            { datum: this._numel, type: WebCL2.type.UINT }
          ], this._numel);
        }
        return clone;
      };
      MatrixCL2.prototype._fill = function(val) {
        var kernel_name = "fill_" + this._klass;
        var kernel = MatrixCL2.kernel_cache[kernel_name];
        if (!kernel) {
          kernel = $CL.createKernel([
            "#define DST_TYPE " + ctypes[this._klass],
            "__kernel void kernel_func(__global DST_TYPE *dst, uint length, DST_TYPE val) {",
            "  uint i = get_global_id(0);",
            "  if (i >= length) { return; }",
            "  dst[i] = val;",
            "}"
          ].join("\n"));
          MatrixCL2.kernel_cache[kernel_name] = kernel;
        }
        if (this._numel > 0) {
          $CL.executeKernel(kernel, [
            { access: WebCL2.MEM_WRITE_ONLY, datum: this },
            { datum: this._numel, type: WebCL2.type.UINT },
            { datum: val, type: webcltypes[this._klass] }
          ], this._numel);
        }
      };
      MatrixCL2.prototype.get = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (args.length == 0) {
          return this.get_scalar([1]);
        }
        var all_number = args.every(function(v) {
          return typeof v === "number";
        });
        if (all_number) {
          return this.get_scalar(args);
        } else {
          return this.get_matrix_nd(args);
        }
      };
      MatrixCL2.prototype.get_scalar = function(inds) {
        this._isvalidindexerr(inds);
        var arrayidx = this._getarrayindex(inds);
        var dst_typed_array = new this._data_ctor(1);
        this.read(dst_typed_array, arrayidx * this._data_ctor.BYTES_PER_ELEMENT);
        return dst_typed_array[0];
      };
      MatrixCL2._get_ind_iterator_cl = function(ind, dim_size) {
        if (typeof ind === "number") {
          var ind_positive = ind;
          if (ind_positive < 0) {
            ind_positive += dim_size + 1;
          }
          if (ind_positive <= 0 || ind_positive > dim_size) {
            throw Error("Index exceeds matrix dimension");
          }
          return {
            kernel_arg: { datum: ind_positive, type: webcltypes.int32 },
            to_destruct: null,
            length: 1,
            typename: "int"
          };
        } else if (ind instanceof Colon2) {
          var start = ind.start;
          var stop = ind.stop;
          var step = ind.step;
          if (ind.all) {
            start = 1;
            stop = dim_size;
            step = 1;
          }
          if (start < 0) {
            start += dim_size + 1;
          }
          if (stop < 0) {
            stop += dim_size + 1;
          }
          var length = 0;
          if (step > 0 && stop >= start || step < 0 && stop <= start) {
            length = Math.floor((stop - start) / step) + 1;
            var final_value = start + step * (length - 1);
            if (start <= 0 || start > dim_size || (final_value <= 0 || final_value > dim_size)) {
              throw Error("Index exceeds matrix dimension");
            }
          }
          return {
            kernel_arg: { datum: [start, step, stop, length], type: webcltypes.int32 | WebCL2.type.VEC4 },
            to_destruct: null,
            length,
            typename: "int4"
          };
        } else if (ind instanceof Matrix2) {
          var to_destruct = null;
          var ind_mat;
          if (ind instanceof MatrixCL2) {
            ind_mat = ind;
          } else {
            ind_mat = MatrixCL2._fromnativemat(ind);
            to_destruct = ind_mat;
          }
          var kernel_name = "_get_ind_iterator_cl_" + ind._klass;
          var kernel = MatrixCL2.kernel_cache[kernel_name];
          if (!kernel) {
            var kernel_str = [
              "#define SRC_TYPE " + ctypes[ind._klass],
              "__kernel void kernel_func(__global int *dst, __global const SRC_TYPE *src, int dim_size, uint src_length) {",
              "  uint i = get_global_id(0);",
              "  if (i >= src_length) { return; }",
              "  int src_val = (int)src[i];",
              "  if (src_val == 0 || src_val > dim_size || src_val < -dim_size) {",
              "    dst[0] = 1;",
              "  }",
              "}"
            ].join("\n");
            kernel = $CL.createKernel(kernel_str);
            MatrixCL2.kernel_cache[kernel_name] = kernel;
          }
          if (ind_mat._numel > 0) {
            var validity_result = new MatrixCL2([1, 1], "int32");
            validity_result._fill(0);
            $CL.executeKernel(kernel, [
              { access: WebCL2.MEM_WRITE_ONLY, datum: validity_result },
              { access: WebCL2.MEM_READ_ONLY, datum: ind_mat },
              { datum: dim_size, type: WebCL2.type.INT },
              { datum: ind_mat._numel, type: WebCL2.type.UINT }
            ], ind_mat._numel);
            if (validity_result.getdataref()[0]) {
              validity_result.destruct();
              if (to_destruct) {
                to_destruct.destruct();
              }
              throw Error("Index exceeds matrix dimension");
            }
            validity_result.destruct();
          }
          return {
            kernel_arg: { datum: ind_mat, access: WebCL2.MEM_READ_ONLY },
            to_destruct,
            length: ind_mat._numel,
            typename: "__global " + ctypes[ind_mat._klass] + " *"
          };
        }
      };
      MatrixCL2.prototype.get_matrix_nd = function(inds) {
        var inds_ndim = inds.length;
        var destruct_targets = [];
        try {
          for (var i2 = 0; i2 < inds_ndim; i2++) {
            var ind = inds[i2];
            if (ind instanceof Matrix2) {
              if (ind._klass == "logical") {
                var idxarray = ind._find();
                inds[i2] = idxarray;
                destruct_targets.push(idxarray);
              }
            }
          }
          var virtual_input_shape = [];
          if (this._ndims <= inds_ndim) {
            virtual_input_shape = this._size.concat();
            while (virtual_input_shape.length < inds_ndim) {
              virtual_input_shape.push(1);
            }
          } else {
            var cur_prod = 1;
            for (var dim_1 = 0; dim_1 < inds_ndim - 1; dim_1++) {
              virtual_input_shape.push(this._size[dim_1]);
              cur_prod *= this._size[dim_1];
            }
            virtual_input_shape.push(this._numel / cur_prod);
          }
          var virtual_input_stride = [];
          var stride_tmp = 1;
          for (var dim = 0; dim < inds_ndim; dim++) {
            virtual_input_stride.push(stride_tmp);
            stride_tmp *= virtual_input_shape[dim];
          }
          var kernel_args = [];
          var kernel_type_names = [];
          var dst_shape = [];
          var dst_stride = [];
          var dst_stride_tmp = 1;
          for (var dim = 0; dim < inds_ndim; dim++) {
            var iter_and_length = MatrixCL2._get_ind_iterator_cl(inds[dim], virtual_input_shape[dim]);
            if (iter_and_length.to_destruct) {
              destruct_targets.push(iter_and_length.to_destruct);
            }
            kernel_args.push(iter_and_length.kernel_arg);
            kernel_type_names.push(iter_and_length.typename);
            dst_shape.push(iter_and_length.length);
            dst_stride.push(dst_stride_tmp);
            dst_stride_tmp *= iter_and_length.length;
          }
          var dst_numel = dst_stride_tmp;
          var dst_reshape_shape = null;
          if (inds_ndim == 1) {
            dst_shape.push(1);
            var is_ind_vector = false;
            var only_ind = inds[0];
            if (only_ind instanceof Matrix2) {
              if (only_ind._ndims == 2 && (only_ind._size[0] == 1 || only_ind._size[1] == 1)) {
                is_ind_vector = true;
              }
            } else if (only_ind instanceof Colon2) {
              is_ind_vector = true;
            }
            var is_src_vector = false;
            if (this._ndims == 2 && (this._size[0] == 1 || this._size[1] == 1)) {
              is_src_vector = true;
            }
            if (is_src_vector && is_ind_vector) {
              if (this._size[0] == 1) {
                dst_reshape_shape = [1, dst_shape[0]];
              }
            } else {
              if (only_ind instanceof Matrix2) {
                dst_reshape_shape = only_ind._size;
              } else if (only_ind instanceof Colon2) {
                dst_reshape_shape = [1, dst_shape[0]];
              }
            }
          }
          var dst = new MatrixCL2(dst_shape, this._klass);
          var kernel_name = "get_matrix_nd_" + this._klass + "_" + inds_ndim + "_" + kernel_type_names.join(",");
          var kernel = MatrixCL2.kernel_cache[kernel_name];
          if (!kernel) {
            var kernel_index_args_str = "";
            for (var dim = 0; dim < inds_ndim; dim++) {
              kernel_index_args_str += "," + kernel_type_names[dim] + " ind" + dim;
            }
            var kernel_add_dim = "";
            for (var dim = 0; dim < inds_ndim; dim++) {
              kernel_add_dim += "ADD_IND(" + dim + ");";
            }
            var kernel_get_ind_func = "";
            for (var dim = 0; dim < inds_ndim; dim++) {
              kernel_get_ind_func += "int get_ind" + dim;
              var kernel_type_name = kernel_type_names[dim];
              switch (kernel_type_name) {
                case "int":
                  kernel_get_ind_func += "(int indexer, int offset, int dim_size) {return indexer;}";
                  break;
                case "int4":
                  kernel_get_ind_func += "(int4 indexer, int offset, int dim_size) {return indexer.x + indexer.y * offset;}";
                  break;
                default:
                  kernel_get_ind_func += "(" + kernel_type_name + " indexer, int offset, int dim_size) {int val = (int)indexer[offset]; if (val < 0) { return val + dim_size + 1; } else { return val; }}";
                  break;
              }
              kernel_get_ind_func += "\n";
            }
            var kernel_str = [
              "#define DIMS " + inds_ndim,
              "#define SRC_DST_TYPE " + ctypes[this._klass],
              kernel_get_ind_func,
              "#define ADD_IND(dim) {dst_coord = (i / dst_stride[dim]) % dst_shape[dim]; src_coord = (get_ind ## dim(ind ## dim, dst_coord, src_shape[dim])) - 1; src_linear_index += src_coord * src_stride[dim];}",
              "__kernel void kernel_func(__global SRC_DST_TYPE *dst, __global const SRC_DST_TYPE *src, __global const int *size_strides, uint output_length",
              kernel_index_args_str,
              ") {",
              "  uint i = get_global_id(0);",
              "  if (i >= output_length) { return; }",
              "  __global const int *src_stride = size_strides, *src_shape = size_strides + DIMS * 1, *dst_stride = size_strides + DIMS * 2, *dst_shape = size_strides + DIMS * 3;",
              "  int dst_coord, src_coord;",
              "  int src_linear_index = 0;",
              kernel_add_dim,
              "  dst[i] = src[src_linear_index];",
              "}"
            ].join("\n");
            kernel = $CL.createKernel(kernel_str);
            MatrixCL2.kernel_cache[kernel_name] = kernel;
          }
          if (dst_numel > 0) {
            var size_strides = [];
            size_strides.push.apply(
              size_strides,
              virtual_input_stride
            );
            size_strides.push.apply(size_strides, virtual_input_shape);
            size_strides.push.apply(size_strides, dst_stride);
            size_strides.push.apply(size_strides, dst_shape);
            var size_strides_mat = MatrixCL2._fromtypedarray(new Int32Array(size_strides), "int32");
            destruct_targets.push(size_strides_mat);
            kernel_args.unshift({ access: WebCL2.MEM_WRITE_ONLY, datum: dst }, { access: WebCL2.MEM_READ_ONLY, datum: this }, { access: WebCL2.MEM_READ_ONLY, datum: size_strides_mat }, { datum: dst_numel, type: WebCL2.type.UINT });
            $CL.executeKernel(kernel, kernel_args, dst_numel);
          }
          if (dst_reshape_shape) {
            dst.reshape_inplace(dst_reshape_shape);
          }
          return dst;
        } finally {
          for (var i2 = 0; i2 < destruct_targets.length; i2++) {
            destruct_targets[i2].destruct();
          }
        }
      };
      MatrixCL2.prototype.set = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var val = args.pop();
        if (!(val instanceof Matrix2) && val.length !== void 0) {
          val = Matrix2.jsa2mat(val, false, this._klass);
        }
        if (val instanceof Matrix2 && val._numel == 1) {
          val = val.get_scalar([1]);
        }
        var all_number = args.every(function(v) {
          return typeof v === "number";
        });
        if (all_number) {
          this.set_scalar(val, args);
        } else {
          this.set_matrix_nd(val, args);
        }
      };
      MatrixCL2.prototype.set_scalar = function(val, inds) {
        this._isvalidindexerr(inds);
        var arrayidx = this._getarrayindex(inds);
        var scalar_val;
        if (val instanceof Matrix2) {
          if (val._numel != 1) {
            throw new Error("Value is not scalar");
          }
          scalar_val = val.get_scalar([1]);
        } else {
          scalar_val = val;
        }
        if (Matrix2._logical_cast_required(this._klass)) {
          scalar_val = Matrix2._logical_cast(scalar_val);
        }
        var typed_array = new this._data_ctor(1);
        typed_array[0] = scalar_val;
        this.write(typed_array, arrayidx * this._data_ctor.BYTES_PER_ELEMENT);
      };
      MatrixCL2.cast_scalar_val = function(val, klass) {
        switch (klass) {
          case "int32":
            val = val | 0;
            break;
          case "uint8":
            val = val & 255;
            break;
          case "logical":
            val = val ? 1 : 0;
            break;
        }
        return val;
      };
      MatrixCL2.prototype.set_matrix_single = function(val, singleind) {
        var index_mat;
        var destruct_index_mat = true;
        var val_mat;
        var destruct_val_mat = false;
        var input_size;
        if (singleind instanceof Colon2) {
          var single_idx_array = singleind.tojsa(this._numel);
          input_size = [1, single_idx_array.length];
          index_mat = new MatrixCL2(input_size, "int32");
          index_mat.write(new Int32Array(single_idx_array));
        } else if (singleind instanceof MatrixCL2) {
          index_mat = singleind;
          destruct_index_mat = false;
        } else if (singleind instanceof Matrix2) {
          index_mat = MatrixCL2._fromnativemat(singleind);
        }
        try {
          if (val instanceof Matrix2) {
            if (index_mat._numel != val._numel) {
              throw new Error("Dimension mismatch");
            }
            if (val instanceof MatrixCL2) {
              val_mat = val;
            } else {
              val_mat = MatrixCL2._fromnativemat(val);
              destruct_val_mat = true;
            }
            var kernel_name = "set_matrix_single_matrix_" + this._klass + "_" + val_mat._klass + "_" + index_mat._klass;
            var kernel = MatrixCL2.kernel_cache[kernel_name];
            if (!kernel) {
              kernel = $CL.createKernel([
                "#define SRC_TYPE " + ctypes[val_mat._klass],
                "#define DST_TYPE " + ctypes[this._klass],
                "#define INDEX_TYPE " + ctypes[index_mat._klass],
                "#define TYPE_CAST(x) " + MatrixCL2.get_cast_str(this._klass, val_mat._klass),
                "__kernel void kernel_func(__global DST_TYPE *dst, __global SRC_TYPE *src, __global INDEX_TYPE *index, uint index_length) {",
                "  uint i = get_global_id(0);",
                "  if (i >= index_length) { return; }",
                "  dst[(uint)index[i]-1] = TYPE_CAST(src[i]);",
                "}"
              ].join("\n"));
              MatrixCL2.kernel_cache[kernel_name] = kernel;
            }
            if (index_mat._numel > 0) {
              $CL.executeKernel(kernel, [
                { access: WebCL2.MEM_WRITE_ONLY, datum: this },
                { access: WebCL2.MEM_READ_ONLY, datum: val_mat },
                { access: WebCL2.MEM_READ_ONLY, datum: index_mat },
                { datum: index_mat._numel, type: WebCL2.type.UINT }
              ], index_mat._numel);
            }
          } else {
            var kernel_name = "set_matrix_single_scalar_" + this._klass + "_" + index_mat._klass;
            var kernel = MatrixCL2.kernel_cache[kernel_name];
            if (!kernel) {
              kernel = $CL.createKernel([
                "#define DST_TYPE " + ctypes[this._klass],
                "#define INDEX_TYPE " + ctypes[index_mat._klass],
                "__kernel void kernel_func(__global DST_TYPE *dst, DST_TYPE src, __global INDEX_TYPE *index, uint index_length) {",
                "  uint i = get_global_id(0);",
                "  if (i >= index_length) { return; }",
                "  dst[(uint)index[i]-1] = src;",
                "}"
              ].join("\n"));
              MatrixCL2.kernel_cache[kernel_name] = kernel;
            }
            var scalar_val = MatrixCL2.cast_scalar_val(val, this._klass);
            if (index_mat._numel > 0) {
              $CL.executeKernel(kernel, [
                { access: WebCL2.MEM_WRITE_ONLY, datum: this },
                { datum: scalar_val, type: webcltypes[this._klass] },
                { access: WebCL2.MEM_READ_ONLY, datum: index_mat },
                { datum: index_mat._numel, type: WebCL2.type.UINT }
              ], index_mat._numel);
            }
          }
        } catch (error) {
          throw error;
        } finally {
          if (destruct_index_mat) {
            index_mat.destruct();
          }
        }
      };
      MatrixCL2.prototype.set_matrix_nd = function(val, inds) {
        var inds_ndim = inds.length;
        var destruct_targets = [];
        try {
          for (var i2 = 0; i2 < inds_ndim; i2++) {
            var ind = inds[i2];
            if (ind instanceof Matrix2) {
              if (ind._klass == "logical") {
                var idxarray = ind._find();
                inds[i2] = idxarray;
                destruct_targets.push(idxarray);
              }
            }
          }
          var virtual_input_shape = [];
          if (this._ndims <= inds_ndim) {
            virtual_input_shape = this._size.concat();
            while (virtual_input_shape.length < inds_ndim) {
              virtual_input_shape.push(1);
            }
          } else {
            var cur_prod = 1;
            for (var dim_2 = 0; dim_2 < inds_ndim - 1; dim_2++) {
              virtual_input_shape.push(this._size[dim_2]);
              cur_prod *= this._size[dim_2];
            }
            virtual_input_shape.push(this._numel / cur_prod);
          }
          var virtual_input_stride = [];
          var stride_tmp = 1;
          for (var dim = 0; dim < inds_ndim; dim++) {
            virtual_input_stride.push(stride_tmp);
            stride_tmp *= virtual_input_shape[dim];
          }
          var kernel_args = [];
          var kernel_type_names = [];
          var dst_shape = [];
          var dst_stride = [];
          var dst_stride_tmp = 1;
          var squeezed_dst_shape = [];
          for (var dim = 0; dim < inds_ndim; dim++) {
            var iter_and_length = MatrixCL2._get_ind_iterator_cl(inds[dim], virtual_input_shape[dim]);
            if (iter_and_length.to_destruct) {
              destruct_targets.push(iter_and_length.to_destruct);
            }
            kernel_args.push(iter_and_length.kernel_arg);
            kernel_type_names.push(iter_and_length.typename);
            dst_shape.push(iter_and_length.length);
            if (iter_and_length.length != 1) {
              squeezed_dst_shape.push(iter_and_length.length);
            }
            dst_stride.push(dst_stride_tmp);
            dst_stride_tmp *= iter_and_length.length;
          }
          var dst_numel = dst_stride_tmp;
          var val_is_matrix = false;
          if (val instanceof Matrix2) {
            if (val._numel == 1) {
              val = val.get();
            } else {
              val_is_matrix = true;
              if (!(val instanceof MatrixCL2)) {
                val = MatrixCL2._fromnativemat(val);
                destruct_targets.push(val);
              }
            }
          }
          if (val_is_matrix) {
            var val_numel = val._numel;
            var raise_error = false;
            if (squeezed_dst_shape.length == 0) {
              if (val_numel != 1) {
                raise_error = true;
              }
            } else if (squeezed_dst_shape.length == 1) {
              if (val_numel != squeezed_dst_shape[0]) {
                raise_error = true;
              }
            } else {
              var val_shape = val._size;
              var squeezed_val_shape = val_shape.filter(function(v) {
                return v != 1;
              });
              if (!squeezed_val_shape.every(function(v, i3) {
                return v == squeezed_dst_shape[i3];
              })) {
                raise_error = true;
              }
            }
            if (raise_error) {
              throw new Error("The shape of matrix does not fit");
            }
          }
          var kernel_name = "set_matrix_nd_" + this._klass + "_" + val_is_matrix + "_" + inds_ndim + "_" + kernel_type_names.join(",");
          var kernel = MatrixCL2.kernel_cache[kernel_name];
          if (!kernel) {
            var kernel_index_args_str = "";
            for (var dim = 0; dim < inds_ndim; dim++) {
              kernel_index_args_str += "," + kernel_type_names[dim] + " ind" + dim;
            }
            var kernel_add_dim = "";
            for (var dim = 0; dim < inds_ndim; dim++) {
              kernel_add_dim += "ADD_IND(" + dim + ");";
            }
            var kernel_get_ind_func = "";
            for (var dim = 0; dim < inds_ndim; dim++) {
              kernel_get_ind_func += "int get_ind" + dim;
              var kernel_type_name = kernel_type_names[dim];
              switch (kernel_type_name) {
                case "int":
                  kernel_get_ind_func += "(int indexer, int offset, int dim_size) {return indexer;}";
                  break;
                case "int4":
                  kernel_get_ind_func += "(int4 indexer, int offset, int dim_size) {return indexer.x + indexer.y * offset;}";
                  break;
                default:
                  kernel_get_ind_func += "(" + kernel_type_name + " indexer, int offset, int dim_size) {int val = (int)indexer[offset]; if (val < 0) { return val + dim_size + 1; } else { return val; }}";
                  break;
              }
              kernel_get_ind_func += "\n";
            }
            var kernel_str = [
              "#define DIMS " + inds_ndim,
              "#define SRC_TYPE " + ctypes[this._klass],
              "#define DST_TYPE " + ctypes[val_is_matrix ? val._klass : this._klass],
              "#define TYPE_CAST(x) " + MatrixCL2.get_cast_str(this._klass, val_is_matrix ? val._klass : this._klass),
              kernel_get_ind_func,
              "#define ADD_IND(dim) {dst_coord = (i / dst_stride[dim]) % dst_shape[dim]; src_coord = (get_ind ## dim(ind ## dim, dst_coord, src_shape[dim])) - 1; src_linear_index += src_coord * src_stride[dim];}",
              "__kernel void kernel_func(",
              val_is_matrix ? "__global const DST_TYPE *dst" : "DST_TYPE dst",
              ", __global SRC_TYPE *src, __global const int *size_strides, uint output_length",
              kernel_index_args_str,
              ") {",
              "  uint i = get_global_id(0);",
              "  if (i >= output_length) { return; }",
              "  __global const int *src_stride = size_strides, *src_shape = size_strides + DIMS * 1, *dst_stride = size_strides + DIMS * 2, *dst_shape = size_strides + DIMS * 3;",
              "  int dst_coord, src_coord;",
              "  int src_linear_index = 0;",
              kernel_add_dim,
              val_is_matrix ? "  src[src_linear_index] = TYPE_CAST(dst[i]);" : "  src[src_linear_index] = TYPE_CAST(dst);",
              "}"
            ].join("\n");
            kernel = $CL.createKernel(kernel_str);
            MatrixCL2.kernel_cache[kernel_name] = kernel;
          }
          if (dst_numel > 0) {
            var size_strides = [];
            size_strides.push.apply(
              size_strides,
              virtual_input_stride
            );
            size_strides.push.apply(size_strides, virtual_input_shape);
            size_strides.push.apply(size_strides, dst_stride);
            size_strides.push.apply(size_strides, dst_shape);
            var size_strides_mat = MatrixCL2._fromtypedarray(new Int32Array(size_strides), "int32");
            destruct_targets.push(size_strides_mat);
            kernel_args.unshift({ access: WebCL2.MEM_WRITE_ONLY, datum: this }, { access: WebCL2.MEM_READ_ONLY, datum: size_strides_mat }, { datum: dst_numel, type: WebCL2.type.UINT });
            if (val_is_matrix) {
              kernel_args.unshift({ access: WebCL2.MEM_READ_ONLY, datum: val });
            } else {
              kernel_args.unshift({ datum: val, type: webcltypes[this._klass] });
            }
            $CL.executeKernel(kernel, kernel_args, dst_numel);
          }
        } finally {
          for (var i2 = 0; i2 < destruct_targets.length; i2++) {
            destruct_targets[i2].destruct();
          }
        }
      };
      MatrixCL2.prototype._find = function() {
        var count_mat = new MatrixCL2([1, 2], "int32");
        var kernel_name = "matrix_find_count_" + this._klass;
        var kernel = MatrixCL2.kernel_cache[kernel_name];
        if (!kernel) {
          kernel = $CL.createKernel([
            "#define SRC_TYPE " + ctypes[this._klass],
            "__kernel void kernel_func(__global int *count, __global SRC_TYPE *logical_index, uint numel) {",
            "  int ctr = 0;",
            "  int max_i = -1;",
            "  if (get_global_id(0) > 0) {return;}",
            "  for (uint i = 0; i < numel; i++) {",
            "    SRC_TYPE val = logical_index[i];",
            "    if (val) {",
            "      ctr++;",
            "      max_i = i;",
            "    }",
            "  }",
            "  count[0] = ctr;",
            "  count[1] = max_i;",
            "}"
          ].join("\n"));
          MatrixCL2.kernel_cache[kernel_name] = kernel;
        }
        var count_array = new Int32Array(2);
        if (this._numel > 0) {
          $CL.executeKernel(kernel, [
            { access: WebCL2.MEM_WRITE_ONLY, datum: count_mat },
            { access: WebCL2.MEM_READ_ONLY, datum: this },
            { datum: this._numel, type: WebCL2.type.UINT }
          ], 1);
          count_mat.read(count_array);
        }
        var output_length = count_array[0];
        var max_i = count_array[1];
        var output = new MatrixCL2([output_length, 1], "int32");
        var kernel_name = "matrix_find_write_" + this._klass;
        var kernel = MatrixCL2.kernel_cache[kernel_name];
        if (!kernel) {
          kernel = $CL.createKernel([
            "#define SRC_TYPE " + ctypes[this._klass],
            "__kernel void kernel_func(__global int *dst, __global SRC_TYPE *src, uint output_length) {",
            "  uint i = get_global_id(0);",
            "  if (i > 0) { return; }",
            "  int out_idx = 0;",
            "  int in_idx = 0;",
            "  while (out_idx < output_length) {",
            "    if (src[in_idx]) {",
            "      dst[out_idx++] = in_idx + 1;",
            "    }",
            "    in_idx++;",
            "  }",
            "}"
          ].join("\n"));
          MatrixCL2.kernel_cache[kernel_name] = kernel;
        }
        if (output_length > 0) {
          $CL.executeKernel(kernel, [
            { access: WebCL2.MEM_WRITE_ONLY, datum: output },
            { access: WebCL2.MEM_READ_ONLY, datum: this },
            { datum: output_length, type: WebCL2.type.UINT }
          ], 1);
        }
        if (this._size[1] == this._numel) {
          output.reshape_inplace(this._size);
        }
        count_mat.destruct();
        return output;
      };
      return MatrixCL2;
    }(Matrix2);
    MatrixCL.kernel_cache = {};
    module2.exports = MatrixCL;
  }
});

// node_modules/milsushi2/src/cl/handwrittenjs/util_cl.js
var require_util_cl = __commonJS({
  "node_modules/milsushi2/src/cl/handwrittenjs/util_cl.js"(exports2, module2) {
    "use strict";
    var $M = require_sushi();
    (function() {
      var $CL = require_driver();
      $M.CL = $CL;
      var Matrix2 = require_matrix();
      var MatrixCL = require_matrix_cl();
      var WebCL2 = $M.CL.WebCL;
      var ctypes = { single: "float", int32: "int", uint8: "uchar", logical: "uchar" };
      module2.exports.ctypes = ctypes;
      var webcltypes = { single: WebCL2.type.FLOAT, int32: WebCL2.type.INT, uint8: WebCL2.type.UCHAR, logical: WebCL2.type.UCHAR };
      module2.exports.webcltypes = webcltypes;
      var unify_mats = function(inputs) {
        var matcl_exist = false;
        for (var i2 = 0; i2 < inputs.length; i2++) {
          var mati = inputs[i2];
          if (mati instanceof MatrixCL) {
            matcl_exist = true;
            break;
          }
        }
        var unified_mats = { cl: matcl_exist, length: inputs.length };
        if (matcl_exist) {
          for (var i2 = 0; i2 < inputs.length; i2++) {
            var mati = inputs[i2];
            if (mati instanceof Matrix2 && !(mati instanceof MatrixCL)) {
              unified_mats[i2] = MatrixCL._fromnativemat(mati);
            } else {
              unified_mats[i2] = mati;
            }
          }
        } else {
          for (var i2 = 0; i2 < inputs.length; i2++) {
            var mati = inputs[i2];
            unified_mats[i2] = mati;
          }
        }
        return unified_mats;
      };
      module2.exports.unify_mats = unify_mats;
      var unify_call = function(native_func, cl_func) {
        var unified_mats = unify_mats(Array.prototype.slice.call(arguments, 2));
        if (unified_mats.cl) {
          return cl_func.apply(null, unified_mats);
        } else {
          return native_func.apply(null, unified_mats);
        }
      };
      module2.exports.unify_call = unify_call;
    })();
  }
});

// node_modules/milsushi2/src/cl/handwrittenjs/binary_arithmetic.js
var require_binary_arithmetic = __commonJS({
  "node_modules/milsushi2/src/cl/handwrittenjs/binary_arithmetic.js"() {
    "use strict";
    var $M = require_sushi();
    var util2 = require_util();
    var util_cl = require_util_cl();
    (function() {
      var $CL = require_driver();
      $M.CL = $CL;
      var Matrix2 = require_matrix();
      var MatrixCL = require_matrix_cl();
      var WebCL2 = $M.CL.WebCL;
      var ctypes = util_cl.ctypes;
      var webcltypes = util_cl.webcltypes;
      var binary_arith_cl = function(A, B, name, operator) {
        var dst_klass2 = util2.commonklass(A, B);
        if (dst_klass2 == "logical") {
          dst_klass2 = "single";
        }
        var left_type, right_type;
        var left_scalar = null, right_scalar = null;
        var left_isscalar = true, right_isscalar = true;
        var kernel_param_a, kernel_param_b;
        if (A instanceof Matrix2) {
          if (A._numel == 1) {
            left_type = ctypes[dst_klass2];
            left_scalar = A.get();
          } else {
            left_type = "__global " + ctypes[A._klass] + " *";
            kernel_param_a = { access: WebCL2.MEM_READ_ONLY, datum: A };
            left_isscalar = false;
          }
        } else {
          left_type = ctypes[dst_klass2];
          left_scalar = A;
        }
        if (left_isscalar) {
          kernel_param_a = { datum: MatrixCL.cast_scalar_val(left_scalar, dst_klass2), type: webcltypes[dst_klass2] };
        }
        if (B instanceof Matrix2) {
          if (B._numel == 1) {
            right_type = ctypes[dst_klass2];
            right_scalar = B.get();
          } else {
            right_type = "__global " + ctypes[B._klass] + " *";
            kernel_param_b = { access: WebCL2.MEM_READ_ONLY, datum: B };
            right_isscalar = false;
          }
        } else {
          right_type = ctypes[dst_klass2];
          right_scalar = B;
        }
        if (right_isscalar) {
          kernel_param_b = { datum: MatrixCL.cast_scalar_val(right_scalar, dst_klass2), type: webcltypes[dst_klass2] };
        }
        var kernel_name = "binary_arith_cl_" + name + "_" + (left_isscalar || A._klass) + "_" + (right_isscalar || B._klass) + "_" + dst_klass2;
        var kernel = MatrixCL.kernel_cache[kernel_name];
        if (!kernel) {
          kernel = $CL.createKernel([
            "#define LEFT_TYPE " + left_type,
            "#define RIGHT_TYPE " + right_type,
            "#define DST_TYPE " + ctypes[dst_klass2],
            "#define LEFT_ACCESS(i) " + (left_isscalar ? "a" : "a[(i)]"),
            "#define RIGHT_ACCESS(i) " + (right_isscalar ? "b" : "b[(i)]"),
            "#define OPERATOR(left, right) " + operator,
            "__kernel void kernel_func(__global DST_TYPE *dst, LEFT_TYPE a, RIGHT_TYPE b, uint length) {",
            "  uint i = get_global_id(0);",
            "  if (i >= length) { return; }",
            "  dst[i] = (DST_TYPE)OPERATOR(LEFT_ACCESS(i), RIGHT_ACCESS(i));",
            "}"
          ].join("\n"));
          MatrixCL.kernel_cache[kernel_name] = kernel;
        }
        var dst_size;
        if (left_isscalar) {
          if (right_isscalar) {
            dst_size = [1, 1];
          } else {
            dst_size = B._size;
          }
        } else {
          dst_size = A._size;
          if (!right_isscalar) {
            if (!util2.issamesize(A._size, B._size)) {
              throw new Error("Dimension mismatch");
            }
          }
        }
        var dst = new MatrixCL(dst_size, dst_klass2);
        if (dst._numel > 0) {
          $CL.executeKernel(
            kernel,
            [
              { access: WebCL2.MEM_WRITE_ONLY, datum: dst },
              kernel_param_a,
              kernel_param_b,
              { datum: dst._numel, type: WebCL2.type.UINT }
            ],
            dst._numel
          );
        }
        return dst;
      };
      var subsitute_binary_arith = function(name, operator) {
        var func_native = $M[name];
        var func_cl = function(A, B) {
          return binary_arith_cl(A, B, name, operator);
        };
        $M[name] = function(A, B) {
          var ret = $M.autodestruct(function() {
            return util_cl.unify_call(func_native, func_cl, A, B);
          });
          return ret;
        };
      };
      subsitute_binary_arith("plus", "((left) + (right))");
      subsitute_binary_arith("minus", "((left) - (right))");
      subsitute_binary_arith("times", "((left) * (right))");
      subsitute_binary_arith("rdivide", "((left) / (right))");
      subsitute_binary_arith("ldivide", "((right) / (left))");
      subsitute_binary_arith("power", "(pow((float)(left), (float)(right)))");
      $M.CL._max_elementwise_cl = function(A, B) {
        return binary_arith_cl(A, B, "max_elementwise_cl", "(((left) > (right)) ? (left) : (right))");
      };
      $M.CL._min_elementwise_cl = function(A, B) {
        return binary_arith_cl(A, B, "min_elementwise_cl", "(((left) < (right)) ? (left) : (right))");
      };
      var compare_cl = function(A, B, name, operator) {
        var dst_klass2 = util2.commonklass(A, B);
        var left_type, right_type;
        var left_scalar = null, right_scalar = null;
        var left_isscalar = true, right_isscalar = true;
        var kernel_param_a, kernel_param_b;
        if (A instanceof Matrix2) {
          if (A._numel == 1) {
            left_type = ctypes[dst_klass2];
            left_scalar = A.get();
          } else {
            left_type = "__global " + ctypes[A._klass] + " *";
            kernel_param_a = { access: WebCL2.MEM_READ_ONLY, datum: A };
            left_isscalar = false;
          }
        } else {
          left_type = ctypes[dst_klass2];
          left_scalar = A;
        }
        if (left_isscalar) {
          kernel_param_a = { datum: MatrixCL.cast_scalar_val(left_scalar, dst_klass2), type: webcltypes[dst_klass2] };
        }
        if (B instanceof Matrix2) {
          if (B._numel == 1) {
            right_type = ctypes[dst_klass2];
            right_scalar = B.get();
          } else {
            right_type = "__global " + ctypes[B._klass] + " *";
            kernel_param_b = { access: WebCL2.MEM_READ_ONLY, datum: B };
            right_isscalar = false;
          }
        } else {
          right_type = ctypes[dst_klass2];
          right_scalar = B;
        }
        if (right_isscalar) {
          kernel_param_b = { datum: MatrixCL.cast_scalar_val(right_scalar, dst_klass2), type: webcltypes[dst_klass2] };
        }
        var kernel_name = "compare_cl_" + name + "_" + (left_isscalar || A._klass) + "_" + (right_isscalar || B._klass);
        var kernel = MatrixCL.kernel_cache[kernel_name];
        if (!kernel) {
          kernel = $CL.createKernel([
            "#define LEFT_TYPE " + left_type,
            "#define RIGHT_TYPE " + right_type,
            "#define LEFT_ACCESS(i) " + (left_isscalar ? "a" : "a[(i)]"),
            "#define RIGHT_ACCESS(i) " + (right_isscalar ? "b" : "b[(i)]"),
            "#define OPERATOR(left, right) " + operator,
            "__kernel void kernel_func(__global uchar *dst, LEFT_TYPE a, RIGHT_TYPE b, uint length) {",
            "  uint i = get_global_id(0);",
            "  if (i >= length) { return; }",
            "  dst[i] = OPERATOR(LEFT_ACCESS(i), RIGHT_ACCESS(i));",
            "}"
          ].join("\n"));
          MatrixCL.kernel_cache[kernel_name] = kernel;
        }
        var dst_size;
        if (left_isscalar) {
          if (right_isscalar) {
            dst_size = [1, 1];
          } else {
            dst_size = B._size;
          }
        } else {
          dst_size = A._size;
          if (!right_isscalar) {
            if (!util2.issamesize(A._size, B._size)) {
              throw new Error("Dimension mismatch");
            }
          }
        }
        var dst = new MatrixCL(dst_size, "logical");
        if (dst._numel > 0) {
          $CL.executeKernel(
            kernel,
            [
              { access: WebCL2.MEM_WRITE_ONLY, datum: dst },
              kernel_param_a,
              kernel_param_b,
              { datum: dst._numel, type: WebCL2.type.UINT }
            ],
            dst._numel
          );
        }
        return dst;
      };
      var subsitute_compare = function(name, operator) {
        var func_native = $M[name];
        var func_cl = function(A, B) {
          return compare_cl(A, B, name, operator);
        };
        $M[name] = function(A, B) {
          var ret = $M.autodestruct(function() {
            return util_cl.unify_call(func_native, func_cl, A, B);
          });
          return ret;
        };
      };
      subsitute_compare("eq", "((left) == (right))");
      subsitute_compare("ge", "((left) >= (right))");
      subsitute_compare("gt", "((left) > (right))");
      subsitute_compare("le", "((left) <= (right))");
      subsitute_compare("lt", "((left) < (right))");
      subsitute_compare("ne", "((left) != (right))");
      var isequal_cl_both = function(mats, nan_equal) {
        var A = mats[0];
        var eqmat = new MatrixCL([1, 1], "logical");
        eqmat.set(1, 0);
        for (var i2 = 1; i2 < mats.length; i2++) {
          var B = mats[i2];
          if (!util2.issamesize(A._size, B._size)) {
            return false;
          }
          var kernel_name = "isequal_cl_" + A._klass + "_" + B._klass + "_" + nan_equal;
          var kernel = MatrixCL.kernel_cache[kernel_name];
          if (!kernel) {
            var condition = "aval != bval";
            if (nan_equal) {
              if (A._klass === "single" && B._klass === "single") {
                condition += "&& !(isnan(aval) && isnan(bval))";
              }
            }
            kernel = $CL.createKernel([
              "#define LEFT_TYPE " + ctypes[A._klass],
              "#define RIGHT_TYPE " + ctypes[B._klass],
              "__kernel void kernel_func(__global uchar *dst, __global LEFT_TYPE *a, __global RIGHT_TYPE *b, uint length) {",
              "  uint i = get_global_id(0);",
              "  if (i >= length) { return; }",
              "  LEFT_TYPE aval = a[i];",
              "  RIGHT_TYPE bval = b[i];",
              "  if (" + condition + ") {*dst = 1;}",
              "}"
            ].join("\n"));
            MatrixCL.kernel_cache[kernel_name] = kernel;
          }
          if (A._numel > 0) {
            $CL.executeKernel(
              kernel,
              [
                { access: WebCL2.MEM_WRITE_ONLY, datum: eqmat },
                { access: WebCL2.MEM_READ_ONLY, datum: A },
                { access: WebCL2.MEM_READ_ONLY, datum: B },
                { datum: A._numel, type: WebCL2.type.UINT }
              ],
              A._numel
            );
          }
          if (eqmat.get()) {
            return false;
          }
        }
        return true;
      };
      var isequal_cl = function() {
        return isequal_cl_both(arguments, false);
      };
      var isequaln_cl = function() {
        return isequal_cl_both(arguments, true);
      };
      var isequal_native = $M.isequal;
      $M.isequal = function() {
        var mats = arguments;
        var ret = $M.autodestruct(function() {
          var unify_call_args = [isequal_native, isequal_cl];
          Array.prototype.push.apply(unify_call_args, mats);
          return util_cl.unify_call.apply(null, unify_call_args);
        });
        return ret;
      };
      var isequaln_native = $M.isequaln;
      $M.isequaln = function() {
        var mats = arguments;
        var ret = $M.autodestruct(function() {
          var unify_call_args = [isequaln_native, isequaln_cl];
          Array.prototype.push.apply(unify_call_args, mats);
          return util_cl.unify_call.apply(null, unify_call_args);
        });
        return ret;
      };
    })();
  }
});

// node_modules/milsushi2/src/cl/handwrittenjs/unary_arithmetic.js
var require_unary_arithmetic = __commonJS({
  "node_modules/milsushi2/src/cl/handwrittenjs/unary_arithmetic.js"() {
    "use strict";
    var $M = require_sushi();
    var util2 = require_util();
    var util_cl = require_util_cl();
    (function() {
      var $CL = require_driver();
      $M.CL = $CL;
      var Matrix2 = require_matrix();
      var MatrixCL = require_matrix_cl();
      var WebCL2 = $M.CL.WebCL;
      var ctypes = util_cl.ctypes;
      var webcltypes = util_cl.webcltypes;
      var unary_arith_cl = function(A, name, operator) {
        var dst_klass2 = A._klass;
        if (dst_klass2 == "logical") {
          dst_klass2 = "single";
        }
        var kernel_name = "unary_arith_cl_" + name + "_" + A._klass + "_" + dst_klass2;
        var kernel = MatrixCL.kernel_cache[kernel_name];
        if (!kernel) {
          kernel = $CL.createKernel([
            "#define SRC_TYPE  " + ctypes[A._klass],
            "#define DST_TYPE " + ctypes[dst_klass2],
            "#define OPERATOR(left) " + operator,
            "__kernel void kernel_func(__global DST_TYPE *dst, __global SRC_TYPE *a, uint length) {",
            "  uint i = get_global_id(0);",
            "  if (i >= length) { return; }",
            "  dst[i] = (DST_TYPE)OPERATOR(a[i]);",
            "}"
          ].join("\n"));
          MatrixCL.kernel_cache[kernel_name] = kernel;
        }
        var dst = new MatrixCL(A._size, dst_klass2);
        if (dst._numel > 0) {
          $CL.executeKernel(
            kernel,
            [
              { access: WebCL2.MEM_WRITE_ONLY, datum: dst },
              { access: WebCL2.MEM_READ_ONLY, datum: A },
              { datum: dst._numel, type: WebCL2.type.UINT }
            ],
            dst._numel
          );
        }
        return dst;
      };
      var subsitute_unary_arith = function(name, operator) {
        var func_native = $M[name];
        var func_cl = function(A) {
          return unary_arith_cl(A, name, operator);
        };
        $M[name] = function(A) {
          if (A instanceof MatrixCL) {
            return func_cl(A);
          } else {
            return func_native(A);
          }
        };
      };
      subsitute_unary_arith("uplus", "(left)");
      subsitute_unary_arith("uminus", "-(left)");
      subsitute_unary_arith("floor", "floor((float)(left))");
      subsitute_unary_arith("fix", "((left) > 0 ? floor((float)(left)): ceil((float)(left)))");
      subsitute_unary_arith("ceil", "ceil((float)(left))");
      subsitute_unary_arith("exp", "exp((float)(left))");
      subsitute_unary_arith("log", "log((float)(left))");
    })();
  }
});

// node_modules/milsushi2/src/cl/handwrittenjs/shape_converter_cl.js
var require_shape_converter_cl = __commonJS({
  "node_modules/milsushi2/src/cl/handwrittenjs/shape_converter_cl.js"() {
    "use strict";
    var $M = require_sushi();
    var util2 = require_util();
    var util_cl = require_util_cl();
    (function() {
      var $CL = require_driver();
      $M.CL = $CL;
      var Matrix2 = require_matrix();
      var MatrixCL = require_matrix_cl();
      var WebCL2 = $M.CL.WebCL;
      var ctypes = util_cl.ctypes;
      var webcltypes = util_cl.webcltypes;
      var transpose_native = $M.transpose;
      var transpose_cl = function(A) {
        if (A._ndims != 2) {
          throw new Error("Matrix must be two-dimensional");
        }
        var dst_cols = A._size[0], dst_rows = A._size[1];
        var dst = new MatrixCL([dst_rows, dst_cols], A._klass);
        if (dst_cols % 64 == 0 && dst_rows % 64 == 0) {
          var kernel_name = "transpose_cl_" + A._klass + "_64";
          var kernel = MatrixCL.kernel_cache[kernel_name];
          var tile_size = 64;
          var block_size = 16;
          if (!kernel) {
            kernel = $CL.createKernel([
              "#define SRC_DST_TYPE " + ctypes[A._klass],
              "#define TILE_SIZE " + tile_size,
              "#define BLOCK_SIZE " + block_size,
              "__kernel void kernel_func(__global SRC_DST_TYPE *dst, __global SRC_DST_TYPE *src,",
              "uint dst_rows, uint dst_cols)",
              "{",
              "uint r0 = get_group_id(0);",
              "uint r1 = get_group_id(1);",
              "uint l1 = get_local_id(1);",
              "__local SRC_DST_TYPE block_cache[BLOCK_SIZE][BLOCK_SIZE];",
              "for (int tile_x = 0; tile_x < (TILE_SIZE / BLOCK_SIZE); tile_x++) {",
              "for (int tile_y = 0; tile_y < (TILE_SIZE / BLOCK_SIZE); tile_y++) {",
              "for (int i = 0; i < BLOCK_SIZE; i++) {",
              "block_cache[l1][i] = src[(r0 * TILE_SIZE + tile_x * BLOCK_SIZE + l1)+(r1 * TILE_SIZE + tile_y * BLOCK_SIZE + i)*dst_cols];",
              "}",
              "barrier(CLK_LOCAL_MEM_FENCE);",
              "for (int i = 0; i < BLOCK_SIZE; i++) {",
              "dst[(r1 * TILE_SIZE + tile_y * BLOCK_SIZE + l1) + (r0 * TILE_SIZE + tile_x * BLOCK_SIZE + i) * dst_rows] = block_cache[i][l1];",
              "}",
              "barrier(CLK_LOCAL_MEM_FENCE);",
              "}",
              "}",
              "}"
            ].join("\n"));
            MatrixCL.kernel_cache[kernel_name] = kernel;
          }
          if (dst._numel > 0) {
            $CL.executeKernel(kernel, [
              { access: WebCL2.MEM_WRITE_ONLY, datum: dst },
              { access: WebCL2.MEM_READ_ONLY, datum: A },
              { datum: dst_rows, type: WebCL2.type.UINT },
              { datum: dst_cols, type: WebCL2.type.UINT }
            ], [dst_cols / tile_size, dst_rows / (tile_size / block_size)], [1, block_size]);
          }
        } else if (dst_cols % 16 == 0 && dst_rows % 16 == 0) {
          var kernel_name = "transpose_cl_" + A._klass + "_16";
          var kernel = MatrixCL.kernel_cache[kernel_name];
          var block_size = 16;
          if (!kernel) {
            kernel = $CL.createKernel([
              "#define SRC_DST_TYPE " + ctypes[A._klass],
              "#define BLOCK_SIZE " + block_size,
              "__kernel void kernel_func(__global SRC_DST_TYPE *dst, __global SRC_DST_TYPE *src,",
              "uint dst_rows, uint dst_cols)",
              "{",
              "uint r0 = get_group_id(0);",
              "uint r1 = get_group_id(1);",
              "uint l1 = get_local_id(1);",
              "__local SRC_DST_TYPE block_cache[BLOCK_SIZE][BLOCK_SIZE];",
              "for (int i = 0; i < BLOCK_SIZE; i++) {",
              "block_cache[l1][i] = src[(r0 * BLOCK_SIZE + l1)+(r1 * BLOCK_SIZE + i)*dst_cols];",
              "}",
              "barrier(CLK_LOCAL_MEM_FENCE);",
              "for (int i = 0; i < BLOCK_SIZE; i++) {",
              "dst[(r1 * BLOCK_SIZE + l1) + (r0 * BLOCK_SIZE + i) * dst_rows] = block_cache[i][l1];",
              "}",
              "}"
            ].join("\n"));
            MatrixCL.kernel_cache[kernel_name] = kernel;
          }
          if (dst._numel > 0) {
            $CL.executeKernel(kernel, [
              { access: WebCL2.MEM_WRITE_ONLY, datum: dst },
              { access: WebCL2.MEM_READ_ONLY, datum: A },
              { datum: dst_rows, type: WebCL2.type.UINT },
              { datum: dst_cols, type: WebCL2.type.UINT }
            ], [dst_cols / block_size, dst_rows], [1, block_size]);
          }
        } else {
          var kernel_name = "transpose_cl_" + A._klass;
          var kernel = MatrixCL.kernel_cache[kernel_name];
          if (!kernel) {
            kernel = $CL.createKernel([
              "#define SRC_DST_TYPE " + ctypes[A._klass],
              "__kernel void kernel_func(__global SRC_DST_TYPE *dst, __global SRC_DST_TYPE *src,",
              "uint dst_rows, uint dst_cols, uint length)",
              "{",
              "uint i = get_global_id(0);",
              "if (i >= length) {return;}",
              "uint dst_row = i % dst_rows, dst_col = i / dst_rows;",
              "dst[i] = src[dst_row * dst_cols + dst_col];",
              "}"
            ].join("\n"));
            MatrixCL.kernel_cache[kernel_name] = kernel;
          }
          if (dst._numel > 0) {
            $CL.executeKernel(kernel, [
              { access: WebCL2.MEM_WRITE_ONLY, datum: dst },
              { access: WebCL2.MEM_READ_ONLY, datum: A },
              { datum: dst_rows, type: WebCL2.type.UINT },
              { datum: dst_cols, type: WebCL2.type.UINT },
              { datum: dst._numel, type: WebCL2.type.UINT }
            ], dst._numel);
          }
        }
        return dst;
      };
      $M.transpose = function(A) {
        if (A instanceof MatrixCL) {
          return transpose_cl(A);
        } else {
          return transpose_native(A);
        }
      };
      $M.t = $M.transpose;
      var repmat_native = $M.repmat;
      var repmat_cl = function(A) {
        var _rs;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var first_arg = args[0];
        if (first_arg instanceof Matrix2) {
          var tarray = first_arg._getdata();
          _rs = Array.prototype.slice.call(tarray);
        } else if (first_arg.length !== void 0) {
          _rs = Array.prototype.slice.call(first_arg);
        } else {
          _rs = Array.prototype.slice.call(args);
        }
        if (_rs.length === 1) {
          _rs.push(_rs[0]);
        }
        while (_rs.length < A._ndims) {
          _rs.push(1);
        }
        while (_rs.length > A._ndims && _rs[_rs.length - 1] == 1) {
          _rs.pop();
        }
        var newdims = _rs.length;
        var newsize = [];
        var input_strides = new Int32Array(newdims + 1);
        var output_strides = new Int32Array(newdims + 1);
        var tmp_in_stride = 1;
        var tmp_out_stride = 1;
        var n_copy = 1;
        var rs_strides = [];
        for (var dim = 0; dim < newdims; dim++) {
          var indimsize = A._ndims > dim ? A._size[dim] : 1;
          var outdimsize = indimsize * _rs[dim];
          rs_strides.push(n_copy);
          n_copy *= _rs[dim];
          newsize.push(outdimsize);
          input_strides[dim] = tmp_in_stride;
          output_strides[dim] = tmp_out_stride;
          tmp_in_stride *= indimsize;
          tmp_out_stride *= outdimsize;
        }
        input_strides[newdims] = tmp_in_stride;
        rs_strides.push(n_copy);
        var output_steps = new Int32Array(n_copy);
        for (var i2 = 0; i2 < n_copy; i2++) {
          var out_offset = 0;
          for (var dim = 0; dim < newdims; dim++) {
            out_offset += Math.floor(i2 % rs_strides[dim + 1] / rs_strides[dim]) * output_strides[dim] * (A._size[dim] || 1);
          }
          output_steps[i2] = out_offset;
        }
        var dst = new MatrixCL(newsize, A._klass);
        var kernel_name = "repmat_cl_" + newdims + "_" + A._klass;
        var kernel = MatrixCL.kernel_cache[kernel_name];
        if (!kernel) {
          kernel = $CL.createKernel([
            "#define DIMS " + newdims,
            "#define SRC_DST_TYPE " + ctypes[A._klass],
            "__kernel void kernel_func(__global SRC_DST_TYPE *dst, __global SRC_DST_TYPE *src,",
            "__global int *input_strides, __global int *output_strides, __global int *output_steps,",
            "uint n_copy, uint length)",
            "{",
            "uint i = get_global_id(0);",
            "if (i >= length) {return;}",
            "int out_offset = 0;",
            "SRC_DST_TYPE val = src[i];",
            "for (int dim = 0; dim < DIMS; dim++) {",
            "  out_offset += i % input_strides[dim+1] / input_strides[dim] * output_strides[dim];",
            "}",
            "for (int j = 0; j < n_copy; j++) {",
            "  dst[out_offset + output_steps[j]] = val;",
            "}",
            "}"
          ].join("\n"));
          MatrixCL.kernel_cache[kernel_name] = kernel;
        }
        if (dst._numel > 0) {
          var input_strides_mat = MatrixCL._fromtypedarray(input_strides, "int32");
          var output_strides_mat = MatrixCL._fromtypedarray(output_strides, "int32");
          var output_steps_mat = MatrixCL._fromtypedarray(output_steps, "int32");
          $CL.executeKernel(kernel, [
            { access: WebCL2.MEM_WRITE_ONLY, datum: dst },
            { access: WebCL2.MEM_READ_ONLY, datum: A },
            { access: WebCL2.MEM_READ_ONLY, datum: input_strides_mat },
            { access: WebCL2.MEM_READ_ONLY, datum: output_strides_mat },
            { access: WebCL2.MEM_READ_ONLY, datum: output_steps_mat },
            { datum: n_copy, type: WebCL2.type.UINT },
            { datum: A._numel, type: WebCL2.type.UINT }
          ], A._numel);
          input_strides_mat.destruct();
          output_strides_mat.destruct();
          output_steps_mat.destruct();
        }
        return dst;
      };
      $M.repmat = function(A) {
        if (A instanceof MatrixCL) {
          return repmat_cl.apply(null, arguments);
        } else {
          return repmat_native.apply(null, arguments);
        }
      };
      var permute_native = $M.permute;
      var permute_cl = function(A, order) {
        var src_size = A._size.concat();
        var numel = A._numel;
        if (order.length < src_size.length) {
          throw Error("order must include at least input dimension");
        }
        var ndim = order.length;
        var src_strides = A._strides.concat();
        while (src_size.length < ndim) {
          src_size.push(1);
          src_strides.push(numel);
        }
        var dst_size = [];
        for (var d = 0; d < ndim; d++) {
          var element = order[d] - 1;
          dst_size.push(src_size[element]);
        }
        var dst = new MatrixCL(dst_size, A._klass);
        var dst_strides = dst._strides.concat();
        while (dst_strides.length < ndim) {
          dst_strides.push(numel);
        }
        var dst_strides_perm = [];
        for (var i2 = 0; i2 < order.length; i2++) {
          var o = order[i2];
          dst_strides_perm[o - 1] = dst_strides[i2];
        }
        var perm_stride = MatrixCL._fromtypedarray(new Int32Array(src_strides.concat(src_size, dst_strides_perm)), "int32");
        var kernel_name = "permute_cl_" + A._klass + "_" + ndim;
        var kernel = MatrixCL.kernel_cache[kernel_name];
        if (!kernel) {
          kernel = $CL.createKernel([
            "#define SRC_DST_TYPE " + ctypes[A._klass],
            "#define DIMS " + ndim,
            "__kernel void kernel_func(__global SRC_DST_TYPE *dst, __global const SRC_DST_TYPE *src,",
            "__global const int *perm_stride, uint length)",
            "{",
            "uint i = get_global_id(0);",
            "if (i >= length) {return;}",
            "__global int *src_strides = perm_stride;",
            "__global int *src_size = perm_stride + DIMS;",
            "__global int *dst_strides_perm = perm_stride + DIMS * 2;",
            "uint dst_idx = 0;",
            "for (int dim = 0; dim < DIMS; dim++) {",
            "  dst_idx += i / src_strides[dim] % src_size[dim] * dst_strides_perm[dim];",
            "}",
            "dst[dst_idx] = src[i];",
            "}"
          ].join("\n"));
          MatrixCL.kernel_cache[kernel_name] = kernel;
        }
        if (dst._numel > 0) {
          $CL.executeKernel(kernel, [
            { access: WebCL2.MEM_WRITE_ONLY, datum: dst },
            { access: WebCL2.MEM_READ_ONLY, datum: A },
            { access: WebCL2.MEM_READ_ONLY, datum: perm_stride },
            { datum: dst._numel, type: WebCL2.type.UINT }
          ], dst._numel, 256);
        }
        perm_stride.destruct();
        return dst;
      };
      $M.permute = function(A, order) {
        if (A instanceof MatrixCL) {
          return permute_cl(A, order);
        } else {
          return permute_native(A, order);
        }
      };
      var ipermute_native = $M.ipermute;
      $M.ipermute = function(A, order) {
        if (A instanceof MatrixCL) {
          var rev_order = order.concat();
          for (var d = 0; d < order.length; d++) {
            rev_order[order[d] - 1] = d + 1;
          }
          return permute_cl(A, rev_order);
        } else {
          return ipermute_native(A, order);
        }
      };
    })();
  }
});

// node_modules/milsushi2/src/cl/handwrittenjs/reduction_cl.js
var require_reduction_cl = __commonJS({
  "node_modules/milsushi2/src/cl/handwrittenjs/reduction_cl.js"() {
    "use strict";
    var $M = require_sushi();
    var util2 = require_util();
    var util_cl = require_util_cl();
    (function() {
      var $CL = require_driver();
      $M.CL = $CL;
      var Matrix2 = require_matrix();
      var MatrixCL = require_matrix_cl();
      var WebCL2 = $M.CL.WebCL;
      var ctypes = util_cl.ctypes;
      var webcltypes = util_cl.webcltypes;
      var maxmin_reduction_along_axis_cl = function(A, dim, name, is_min, is_argmax) {
        if (dim == null) {
          dim = A._numel;
          for (var i2 = 0; i2 < A._size.length; i2++) {
            var dimsize = A._size[i2];
            if (dimsize !== 1) {
              dim = i2 + 1;
              break;
            }
          }
        }
        if (dim > A._ndims) {
          if (is_argmax) {
            var amat = new MatrixCL(A._size, "int32");
            amat._fill(1);
            return { M: A.copy(), I: amat };
          } else {
            return A.copy();
          }
        }
        var dstsize = A._size.slice();
        if (dstsize[dim - 1] !== 0) {
          dstsize[dim - 1] = 1;
        }
        if (A._numel === 0 || A._size[dim - 1] === 1) {
          var dst_onlyreshape = A.copy();
          dst_onlyreshape.reshape_inplace(dstsize);
          if (is_argmax) {
            var amat = new MatrixCL(dstsize, "int32");
            amat._fill(1);
            return { M: dst_onlyreshape, I: amat };
          } else {
            return dst_onlyreshape;
          }
        }
        var dst = new MatrixCL(dstsize, A._klass);
        var argmax2 = null;
        if (is_argmax) {
          argmax2 = new MatrixCL(dstsize, "int32");
        }
        var input_strides = A._strides;
        var output_strides = dst._strides.slice();
        while (output_strides.length <= input_strides.length) {
          output_strides.push(dst._numel);
        }
        var output_strides_mat = MatrixCL._fromtypedarray(new Int32Array(output_strides), "int32");
        var input_strides_mat = MatrixCL._fromtypedarray(new Int32Array(A._strides), "int32");
        var reduction_step = input_strides[dim - 1];
        var reduction_count = A._size[dim - 1];
        var dims = A._ndims;
        var kernel_name = "maxmin_reduction_cl_" + name + "_" + A._klass + "_" + dims;
        var kernel = MatrixCL.kernel_cache[kernel_name];
        if (!kernel) {
          kernel = $CL.createKernel([
            "#define SRC_DST_TYPE " + ctypes[A._klass],
            "#define DIMS " + dims,
            "__kernel void kernel_func(__global SRC_DST_TYPE *dst, __global SRC_DST_TYPE *src,",
            is_argmax ? "__global int *argmax," : "",
            " uint length,",
            "__global int *output_strides, __global int *input_strides, int reduction_step, int reduction_count) {",
            "  int i = (int)get_global_id(0);",
            "  if (i >= length) { return; }",
            "  int src_idx = 0;",
            "  for (int d = 0; d < DIMS; d++) {",
            "    src_idx += i % output_strides[d+1] / output_strides[d] * input_strides[d];",
            "  }",
            "  SRC_DST_TYPE val = src[src_idx];",
            "  SRC_DST_TYPE accum = val;",
            is_argmax ? "  int accumarg = 0;" : "",
            "  for (int red = 1; red < reduction_count; red++) {",
            "    src_idx += reduction_step;",
            "    val = src[src_idx];",
            is_min ? is_argmax ? "if (val < accum) { accum = val; accumarg = red; }" : "if (val < accum) { accum = val; }" : is_argmax ? "if (val > accum) { accum = val; accumarg = red; }" : "if (val > accum) { accum = val; }",
            "  }",
            "  dst[i] = accum;",
            is_argmax ? "argmax[i] = accumarg + 1;" : "",
            "}"
          ].join("\n"));
          MatrixCL.kernel_cache[kernel_name] = kernel;
        }
        if (dst._numel > 0) {
          if (is_argmax) {
            $CL.executeKernel(kernel, [
              { access: WebCL2.MEM_WRITE_ONLY, datum: dst },
              { access: WebCL2.MEM_READ_ONLY, datum: A },
              { access: WebCL2.MEM_WRITE_ONLY, datum: argmax2 },
              { datum: dst._numel, type: WebCL2.type.INT },
              { access: WebCL2.MEM_READ_ONLY, datum: output_strides_mat },
              { access: WebCL2.MEM_READ_ONLY, datum: input_strides_mat },
              { datum: reduction_step, type: WebCL2.type.INT },
              { datum: reduction_count, type: WebCL2.type.INT }
            ], dst._numel);
          } else {
            $CL.executeKernel(kernel, [
              { access: WebCL2.MEM_WRITE_ONLY, datum: dst },
              { access: WebCL2.MEM_READ_ONLY, datum: A },
              { datum: dst._numel, type: WebCL2.type.INT },
              { access: WebCL2.MEM_READ_ONLY, datum: output_strides_mat },
              { access: WebCL2.MEM_READ_ONLY, datum: input_strides_mat },
              { datum: reduction_step, type: WebCL2.type.INT },
              { datum: reduction_count, type: WebCL2.type.INT }
            ], dst._numel);
          }
        }
        if (is_argmax) {
          return { M: dst, I: argmax2 };
        } else {
          return dst;
        }
      };
      var stat_reduction_along_axis_cl = function(A, dim, name, init_accum, update_accum, assign_result) {
        if (dim == null) {
          dim = A._numel;
          for (var i2 = 0; i2 < A._size.length; i2++) {
            var dimsize = A._size[i2];
            if (dimsize !== 1) {
              dim = i2 + 1;
              break;
            }
          }
        }
        var virtual_input_shape = A._size.concat();
        while (dim > virtual_input_shape.length) {
          virtual_input_shape.push(1);
        }
        var dstsize = virtual_input_shape.concat();
        if (dstsize[dim - 1] !== 0) {
          dstsize[dim - 1] = 1;
        }
        var dst = new MatrixCL(dstsize, "single");
        if (A._numel == 0) {
          return dst;
        }
        var dims = virtual_input_shape.length;
        var input_strides = [];
        var tmp = 1;
        for (var i2 = 0; i2 < dims; i2++) {
          input_strides.push(tmp);
          tmp *= virtual_input_shape[i2];
        }
        var output_strides = [];
        tmp = 1;
        for (var i2 = 0; i2 < dims; i2++) {
          output_strides.push(tmp);
          tmp *= dstsize[i2];
        }
        output_strides.push(tmp);
        var output_strides_mat = MatrixCL._fromtypedarray(new Int32Array(output_strides), "int32");
        var input_strides_mat = MatrixCL._fromtypedarray(new Int32Array(input_strides), "int32");
        var reduction_step = input_strides[dim - 1];
        var reduction_count = virtual_input_shape[dim - 1];
        var kernel_name = "stat_reduction_cl_" + name + "_" + A._klass + "_" + dims;
        var kernel = MatrixCL.kernel_cache[kernel_name];
        if (!kernel) {
          kernel = $CL.createKernel([
            "#define SRC_TYPE " + ctypes[A._klass],
            "#define DST_TYPE float",
            "#define DIMS " + dims,
            "__kernel void kernel_func(__global DST_TYPE *dst, __global const SRC_TYPE *src,",
            " uint length,",
            "__global const int *output_strides, __global const int *input_strides, int reduction_step, int reduction_count) {",
            "  int i = (int)get_global_id(0);",
            "  if (i >= length) { return; }",
            "  int src_idx = 0;",
            "  for (int d = 0; d < DIMS; d++) {",
            "    src_idx += i % output_strides[d+1] / output_strides[d] * input_strides[d];",
            "  }",
            "  DST_TYPE val = src[src_idx];",
            init_accum,
            "  for (int red = 1; red < reduction_count; red++) {",
            "    src_idx += reduction_step;",
            "    val = (DST_TYPE)src[src_idx];",
            update_accum,
            "  }",
            assign_result,
            "}"
          ].join("\n"));
          MatrixCL.kernel_cache[kernel_name] = kernel;
        }
        $CL.executeKernel(kernel, [
          { access: WebCL2.MEM_WRITE_ONLY, datum: dst },
          { access: WebCL2.MEM_READ_ONLY, datum: A },
          { datum: dst._numel, type: WebCL2.type.INT },
          { access: WebCL2.MEM_READ_ONLY, datum: output_strides_mat },
          { access: WebCL2.MEM_READ_ONLY, datum: input_strides_mat },
          { datum: reduction_step, type: WebCL2.type.INT },
          { datum: reduction_count, type: WebCL2.type.INT }
        ], dst._numel);
        output_strides_mat.destruct();
        input_strides_mat.destruct();
        return dst;
      };
      var max_native = $M.max;
      $M.max = function(A, B, dim) {
        return $M.autodestruct(function() {
          var mats = util_cl.unify_mats([A, B]);
          if (mats.cl) {
            if (B == null) {
              return maxmin_reduction_along_axis_cl(A, dim, "max", false, false);
            } else {
              return $M.CL._max_elementwise_cl(mats[0], mats[1]);
            }
          } else {
            return max_native(mats[0], mats[1], dim);
          }
        });
      };
      var min_native = $M.min;
      $M.min = function(A, B, dim) {
        return $M.autodestruct(function() {
          var mats = util_cl.unify_mats([A, B]);
          if (mats.cl) {
            if (B == null) {
              return maxmin_reduction_along_axis_cl(A, dim, "min", true, false);
            } else {
              return $M.CL._min_elementwise_cl(mats[0], mats[1]);
            }
          } else {
            return min_native(mats[0], mats[1], dim);
          }
        });
      };
      var argmax_native = $M.argmax;
      $M.argmax = function(A, dummy, dim) {
        if (A instanceof MatrixCL) {
          return maxmin_reduction_along_axis_cl(A, dim, "argmax", false, true);
        } else {
          return argmax_native(A, dummy, dim);
        }
      };
      var argmin_native = $M.argmin;
      $M.argmin = function(A, dummy, dim) {
        if (A instanceof MatrixCL) {
          return maxmin_reduction_along_axis_cl(A, dim, "argmin", true, true);
        } else {
          return argmin_native(A, dummy, dim);
        }
      };
      var replace_sum = function(f_native, name, init_accum, update_accum, assign_result) {
        return function(A) {
          if (A instanceof MatrixCL) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var dim = void 0;
            var outtype = void 0;
            for (var i2 = 1; i2 < arguments.length; i2++) {
              var arg = arguments[i2];
              if (typeof arg === "string") {
                if (arg != "native") {
                  throw new Error("Outtype other than native is currently not supported");
                }
              } else if (typeof arg === "number") {
                dim = arg;
              } else {
                throw new Error("Unknown argument " + arg);
              }
            }
            return stat_reduction_along_axis_cl(
              A,
              dim,
              name,
              init_accum,
              update_accum,
              assign_result
            );
          } else {
            return f_native.apply(null, arguments);
          }
        };
      };
      $M.sum = replace_sum($M.sum, "sum", "DST_TYPE accum = val;", "accum += val;", "dst[i] = accum;");
      $M.mean = replace_sum($M.mean, "mean", "DST_TYPE accum = val;", "accum += val;", "dst[i] = accum / reduction_count;");
      $M.prod = replace_sum($M.prod, "prod", "DST_TYPE accum = val;", "accum *= val;", "dst[i] = accum;");
      var replace_variance = function(f_native, name, do_sqrt) {
        return function(A, w, dim) {
          if (A instanceof MatrixCL) {
            var assign_result;
            if (w == null || w == 0) {
              assign_result = "dst[i] = " + do_sqrt + "((sqsum - normalsum * normalsum / reduction_count) / (reduction_count > 1 ? reduction_count - 1 : 1));";
            } else if (w == 1) {
              assign_result = "dst[i] = " + do_sqrt + "((sqsum - normalsum * normalsum / reduction_count) / reduction_count);";
            } else {
              throw new Error("w must be 0 or 1");
            }
            return stat_reduction_along_axis_cl(
              A,
              dim,
              name + w,
              "DST_TYPE normalsum = (DST_TYPE)val; DST_TYPE sqsum = (DST_TYPE)val * (DST_TYPE)val;",
              "normalsum += val; sqsum += (DST_TYPE)val * (DST_TYPE)val;",
              assign_result
            );
          } else {
            return f_native.apply(null, arguments);
          }
        };
      };
      $M.variance = replace_variance($M.variance, "variance", "");
      $M.std = replace_variance($M.std, "std", "sqrt");
    })();
  }
});

// node_modules/milsushi2/src/cl/handwrittenjs/clblasgemm.js
var require_clblasgemm = __commonJS({
  "node_modules/milsushi2/src/cl/handwrittenjs/clblasgemm.js"() {
    "use strict";
    (function() {
      var $M = require_sushi();
      var util2 = require_util();
      var util_cl = require_util_cl();
      var $CL = require_driver();
      $M.CL = $CL;
      var Matrix2 = require_matrix();
      var MatrixCL = require_matrix_cl();
      var WebCL2 = $M.CL.WebCL;
      var ctypes = util_cl.ctypes;
      var webcltypes = util_cl.webcltypes;
      var select_macroTileNumRowsCols = function(m, n) {
        var size_limits = [4e3, 2448, 1600, 1008, 960, 896, 864, 784, 768, 720, 464, 304, 0];
        var fallback = [96, 96, 96, 96, 32, 32, 32, 32, 32, 32, 48, 32, 16];
        var divisors = [
          [96],
          [96],
          [96, 64, 80],
          [96, 64, 80, 48],
          [64, 48, 80, 32],
          [64, 96, 48, 80, 32],
          [96, 48, 80, 64, 32],
          [48, 80, 64, 32, 16],
          [48, 80, 64, 32, 16],
          [64, 80, 96, 48],
          [48, 64, 32, 80],
          [48, 32, 16],
          [16]
        ];
        for (var index = 0; index < size_limits.length; index++) {
          var size_limit = size_limits[index];
          if (m * n < size_limit * size_limit) {
            continue;
          }
          var divisor = divisors[index];
          for (var j = 0; j < divisor.length; j++) {
            var div = divisor[j];
            if (m % div == 0 && n % div == 0) {
              return div;
            }
          }
          return fallback[index];
        }
        return 16;
      };
      var sgemm = function(transa, transb, m, n, k, alpha, A, ldA, B, ldB, beta, C, ldC, offsetA, offsetB, offsetC) {
        offsetA = offsetA | 0;
        offsetB = offsetB | 0;
        offsetC = offsetC | 0;
        var betazero = "1";
        var caccess = WebCL2.MEM_READ_WRITE;
        if (beta == 0) {
          betazero = "0";
          caccess = WebCL2.MEM_WRITE_ONLY;
        }
        var workGroupNumRows = 16, workGroupNumCols = 16;
        var macroTileNumRowsCols = select_macroTileNumRowsCols(m, n);
        var unroll = 1;
        if (k % 16 == 0) {
          unroll = 16;
        } else if (k % 8 == 0) {
          unroll = 8;
        }
        if (macroTileNumRowsCols == 96 && unroll == 16) {
          unroll = 8;
        }
        var macroTileNumRows = macroTileNumRowsCols, macroTileNumCols = macroTileNumRowsCols;
        var globalWorkSizeRows = Math.floor(m / macroTileNumRows) * workGroupNumRows;
        var globalWorkSizeCols = Math.floor(n / macroTileNumCols) * workGroupNumCols;
        if (globalWorkSizeRows > 0 && globalWorkSizeCols > 0) {
          var kernel_tile = getgemmkernel("sgemm_Col_" + transa + transb + "_B" + betazero + "_MX" + macroTileNumRows + "_NX" + macroTileNumCols + "_KX" + unroll);
          $CL.executeKernel(
            kernel_tile,
            [
              { access: WebCL2.MEM_READ_ONLY, datum: A },
              { access: WebCL2.MEM_READ_ONLY, datum: B },
              { access: caccess, datum: C },
              { datum: alpha, type: WebCL2.type.FLOAT },
              { datum: beta, type: WebCL2.type.FLOAT },
              { datum: m, type: WebCL2.type.UINT },
              { datum: n, type: WebCL2.type.UINT },
              { datum: k, type: WebCL2.type.UINT },
              { datum: ldA, type: WebCL2.type.UINT },
              { datum: ldB, type: WebCL2.type.UINT },
              { datum: ldC, type: WebCL2.type.UINT },
              { datum: offsetA, type: WebCL2.type.UINT },
              { datum: offsetB, type: WebCL2.type.UINT },
              { datum: offsetC, type: WebCL2.type.UINT }
            ],
            [globalWorkSizeRows, globalWorkSizeCols],
            [workGroupNumRows, workGroupNumCols]
          );
        }
        if (m % macroTileNumRows != 0 && globalWorkSizeCols > 0) {
          var kernel_row = getgemmkernel("sgemm_Col_" + transa + transb + "_B" + betazero + "_ML" + macroTileNumRows + "_NX" + macroTileNumCols + "_KX" + unroll);
          $CL.executeKernel(
            kernel_row,
            [
              { access: WebCL2.MEM_READ_ONLY, datum: A },
              { access: WebCL2.MEM_READ_ONLY, datum: B },
              { access: caccess, datum: C },
              { datum: alpha, type: WebCL2.type.FLOAT },
              { datum: beta, type: WebCL2.type.FLOAT },
              { datum: m, type: WebCL2.type.UINT },
              { datum: n, type: WebCL2.type.UINT },
              { datum: k, type: WebCL2.type.UINT },
              { datum: ldA, type: WebCL2.type.UINT },
              { datum: ldB, type: WebCL2.type.UINT },
              { datum: ldC, type: WebCL2.type.UINT },
              { datum: offsetA, type: WebCL2.type.UINT },
              { datum: offsetB, type: WebCL2.type.UINT },
              { datum: offsetC, type: WebCL2.type.UINT }
            ],
            [workGroupNumRows, globalWorkSizeCols],
            [workGroupNumRows, workGroupNumCols]
          );
        }
        if (globalWorkSizeRows > 0 && n % macroTileNumCols != 0) {
          var kernel_col = getgemmkernel("sgemm_Col_" + transa + transb + "_B" + betazero + "_MX" + macroTileNumRows + "_NL" + macroTileNumCols + "_KX" + unroll);
          $CL.executeKernel(
            kernel_col,
            [
              { access: WebCL2.MEM_READ_ONLY, datum: A },
              { access: WebCL2.MEM_READ_ONLY, datum: B },
              { access: caccess, datum: C },
              { datum: alpha, type: WebCL2.type.FLOAT },
              { datum: beta, type: WebCL2.type.FLOAT },
              { datum: m, type: WebCL2.type.UINT },
              { datum: n, type: WebCL2.type.UINT },
              { datum: k, type: WebCL2.type.UINT },
              { datum: ldA, type: WebCL2.type.UINT },
              { datum: ldB, type: WebCL2.type.UINT },
              { datum: ldC, type: WebCL2.type.UINT },
              { datum: offsetA, type: WebCL2.type.UINT },
              { datum: offsetB, type: WebCL2.type.UINT },
              { datum: offsetC, type: WebCL2.type.UINT }
            ],
            [globalWorkSizeRows, workGroupNumCols],
            [workGroupNumRows, workGroupNumCols]
          );
        }
        if (m % macroTileNumRows != 0 && n % macroTileNumCols != 0) {
          var kernel_corner = getgemmkernel("sgemm_Col_" + transa + transb + "_B" + betazero + "_ML" + macroTileNumRows + "_NL" + macroTileNumCols + "_KX" + unroll);
          $CL.executeKernel(
            kernel_corner,
            [
              { access: WebCL2.MEM_READ_ONLY, datum: A },
              { access: WebCL2.MEM_READ_ONLY, datum: B },
              { access: caccess, datum: C },
              { datum: alpha, type: WebCL2.type.FLOAT },
              { datum: beta, type: WebCL2.type.FLOAT },
              { datum: m, type: WebCL2.type.UINT },
              { datum: n, type: WebCL2.type.UINT },
              { datum: k, type: WebCL2.type.UINT },
              { datum: ldA, type: WebCL2.type.UINT },
              { datum: ldB, type: WebCL2.type.UINT },
              { datum: ldC, type: WebCL2.type.UINT },
              { datum: offsetA, type: WebCL2.type.UINT },
              { datum: offsetB, type: WebCL2.type.UINT },
              { datum: offsetC, type: WebCL2.type.UINT }
            ],
            [workGroupNumRows, workGroupNumCols],
            [workGroupNumRows, workGroupNumCols]
          );
        }
      };
      $M.CL.sgemm = sgemm;
      var mtimes_native = $M.mtimes;
      var mtimes_cl = function(A, B) {
        if (A._ndims != 2 || B._ndims != 2) {
          throw new Error("Matrix must be two-dimensional");
        }
        if (A._size[1] != B._size[0]) {
          throw new Error("Shape mismatch");
        }
        if (A._klass != "single" || B._klass != "single") {
          throw new Error("Matrix klass must be single");
        }
        var m = A._size[0], n = B._size[1], k = A._size[1];
        var C = new MatrixCL([m, n], "single");
        var lda = A._strides[1];
        var ldb = B._strides[1];
        var ldc = C._strides[1];
        sgemm("N", "N", m, n, k, 1, A, lda, B, ldb, 0, C, ldc);
        return C;
      };
      $M.mtimes = function(A, B) {
        return $M.autodestruct(function() {
          return util_cl.unify_call(mtimes_native, mtimes_cl, A, B);
        });
      };
      var getgemmkernel = function() {
        var kernels = {};
        var KernelParameters = function(name) {
          this.name = name;
          var items = name.split("_");
          this.precision = items[0].substr(0, 1);
          this.microTileNumRows = parseInt(items[4].substr(2), 10) / this.workGroupNumRows;
          this.microTileNumCols = parseInt(items[5].substr(2), 10) / this.workGroupNumCols;
          this.unroll = parseInt(items[6].substr(2), 10);
          this.localRowPad = 0;
          this.localColPad = 0;
          this.order = items[1] == "Col" ? "clblasColumnMajor" : "clblasRowMajor";
          this.transA = items[2].substr(0, 1);
          this.transB = items[2].substr(1, 1);
          this.beta = parseInt(items[3].substr(1, 1), 10);
          this._isRowKernel = items[4].substr(1, 1) == "L";
          this._isColKernel = items[5].substr(1, 1) == "L";
        };
        KernelParameters.prototype.workGroupNumRows = 16;
        KernelParameters.prototype.workGroupNumCols = 16;
        KernelParameters.prototype.isValid = function() {
          return true;
        };
        KernelParameters.prototype.getName = function() {
          return this.name;
        };
        KernelParameters.prototype.isRowKernel = function() {
          return this._isRowKernel;
        };
        KernelParameters.prototype.isColKernel = function() {
          return this._isColKernel;
        };
        var Common = {};
        Common.hostDataChar = { "s": "s", "d": "d", "c": "c", "z": "z" };
        Common.hostDataType = { "s": "float", "d": "double", "c": "float2", "z": "double2" };
        Common.openclDataType = { "s": "float", "d": "double", "c": "float2", "z": "double2" };
        Common.precisionInt = { "s": 0, "d": 1, "c": 2, "z": 3 };
        Common.orderInt = { "clblasRowMajor": 0, "clblasColumnMajor": 1 };
        Common.transposeInt = { "N": 0, "T": 1, "C": 2 };
        function makeOpenCLKernelString(kernel) {
          var endLine = "\n";
          if (kernel.isValid() == false) {
            return kernel.getName() + " invalid";
          }
          var kStr = "";
          kStr += endLine;
          kStr += "/* " + kernel.getName() + " */";
          kStr += endLine;
          var prec = kernel.precision;
          if (prec == "d" || prec == "z") {
            kStr += endLine;
            kStr += "//pragma OPENCL EXTENSION cl_khr_fp64 : enable" + endLine;
          }
          kStr += endLine;
          kStr += "/* kernel parameters */" + endLine;
          kStr += "#define WG_NUM_ROWS          " + (kernel.workGroupNumRows + endLine);
          kStr += "#define WG_NUM_COLS          " + (kernel.workGroupNumCols + endLine);
          kStr += "#define MICRO_TILE_NUM_ROWS  " + (kernel.microTileNumRows + endLine);
          kStr += "#define MICRO_TILE_NUM_COLS  " + (kernel.microTileNumCols + endLine);
          kStr += "#define MACRO_TILE_NUM_ROWS  " + (kernel.workGroupNumRows * kernel.microTileNumRows + endLine);
          kStr += "#define MACRO_TILE_NUM_COLS  " + (kernel.workGroupNumCols * kernel.microTileNumCols + endLine);
          kStr += "#define NUM_UNROLL_ITER      " + (kernel.unroll + endLine);
          kStr += "" + endLine;
          kStr += "#define LOCAL_ROW_PAD        " + (kernel.localRowPad + endLine);
          kStr += "#define LOCAL_COL_PAD        " + (kernel.localColPad + endLine);
          kStr += endLine;
          kStr += "/* global memory indices */" + endLine;
          if (kernel.order == "clblasColumnMajor" == (kernel.transA == "N")) {
            kStr += "#define GET_GLOBAL_INDEX_A(ROW,COL) ((COL)*lda+(ROW))" + endLine;
          } else {
            kStr += "#define GET_GLOBAL_INDEX_A(ROW,COL) ((ROW)*lda+(COL))" + endLine;
          }
          if (kernel.order == "clblasColumnMajor" == (kernel.transB == "N")) {
            kStr += "#define GET_GLOBAL_INDEX_B(ROW,COL) ((COL)*ldb+(ROW))" + endLine;
          } else {
            kStr += "#define GET_GLOBAL_INDEX_B(ROW,COL) ((ROW)*ldb+(COL))" + endLine;
          }
          if (kernel.order == "clblasColumnMajor") {
            kStr += "#define GET_GLOBAL_INDEX_C(ROW,COL) ((COL)*ldc+(ROW))" + endLine;
          } else {
            kStr += "#define GET_GLOBAL_INDEX_C(ROW,COL) ((ROW)*ldc+(COL))" + endLine;
          }
          kStr += endLine;
          kStr += "/* local memory indices */" + endLine;
          kStr += "#define GET_LOCAL_INDEX_A(ROW,COL) ((ROW) + (COL)*((MACRO_TILE_NUM_ROWS)+(LOCAL_COL_PAD)) )" + endLine;
          kStr += "#define GET_LOCAL_INDEX_B(ROW,COL) ((COL) + (ROW)*((MACRO_TILE_NUM_COLS)+(LOCAL_ROW_PAD)) )" + endLine;
          kStr += endLine;
          kStr += "/* data types */" + endLine;
          kStr += "#define DATA_TYPE_STR " + (Common.openclDataType[kernel.precision] + endLine);
          if (kernel.precision == "s" || kernel.precision == "d") {
            kStr += "#define TYPE_MAD(MULA,MULB,DST) DST = mad(MULA,MULB,DST);" + endLine;
            if (kernel.beta == 1) {
              kStr += "#define TYPE_MAD_WRITE(DST,ALPHA,REG,BETA) DST = (ALPHA)*(REG) + (BETA)*(DST);" + endLine;
            } else {
              kStr += "#define TYPE_MAD_WRITE(DST,ALPHA,REG,BETA) DST = (ALPHA)*(REG);" + endLine;
            }
          } else {
            if (kernel.transA != "C" && kernel.transB != "C") {
              kStr += "#define TYPE_MAD(MULA,MULB,DST) \\" + endLine + "  DST.s0 = mad(  MULA.s0, MULB.s0, DST.s0 ); \\" + endLine + "  DST.s0 = mad( -MULA.s1, MULB.s1, DST.s0 ); \\" + endLine + "  DST.s1 = mad(  MULA.s0, MULB.s1, DST.s1 ); \\" + endLine + "  DST.s1 = mad(  MULA.s1, MULB.s0, DST.s1 );" + endLine;
            } else if (kernel.transA == "C" && kernel.transB != "C") {
              kStr += "#define TYPE_MAD(MULA,MULB,DST) \\" + endLine + "  DST.s0 = mad(  MULA.s0, MULB.s0, DST.s0 ); \\" + endLine + "  DST.s0 = mad(  MULA.s1, MULB.s1, DST.s0 ); \\" + endLine + "  DST.s1 = mad(  MULA.s0, MULB.s1, DST.s1 ); \\" + endLine + "  DST.s1 = mad( -MULA.s1, MULB.s0, DST.s1 );" + endLine;
            } else if (kernel.transA != "C" && kernel.transB == "C") {
              kStr += "#define TYPE_MAD(MULA,MULB,DST) \\" + endLine + "  DST.s0 = mad(  MULA.s0,  MULB.s0, DST.s0 ); \\" + endLine + "  DST.s0 = mad( -MULA.s1, -MULB.s1, DST.s0 ); \\" + endLine + "  DST.s1 = mad(  MULA.s0, -MULB.s1, DST.s1 ); \\" + endLine + "  DST.s1 = mad(  MULA.s1,  MULB.s0, DST.s1 );" + endLine;
            } else {
              kStr += "#define TYPE_MAD(MULA,MULB,DST) \\" + endLine + "  DST.s0 = mad(  MULA.s0,  MULB.s0, DST.s0 ); \\" + endLine + "  DST.s0 = mad(  MULA.s1, -MULB.s1, DST.s0 ); \\" + endLine + "  DST.s1 = mad(  MULA.s0, -MULB.s1, DST.s1 ); \\" + endLine + "  DST.s1 = mad( -MULA.s1,  MULB.s0, DST.s1 );" + endLine;
            }
            if (kernel.beta == 1) {
              kStr += "#define TYPE_MAD_WRITE( DST, ALPHA, REG, BETA ) \\" + endLine + "  /* (1) */ \\" + endLine + "  type_mad_tmp = REG.s0; \\" + endLine + "  REG.s0 *= ALPHA.s0; \\" + endLine + "  REG.s0 = mad( -ALPHA.s1, REG.s1, REG.s0 ); \\" + endLine + "  REG.s1 *= ALPHA.s0; \\" + endLine + "  REG.s1 = mad(  ALPHA.s1, type_mad_tmp, REG.s1 ); \\" + endLine + "  /* (2) */ \\" + endLine + "  REG.s0 = mad(  BETA.s0, DST.s0, REG.s0 ); \\" + endLine + "  REG.s0 = mad( -BETA.s1, DST.s1, REG.s0 ); \\" + endLine + "  REG.s1 = mad(  BETA.s1, DST.s0, REG.s1 ); \\" + endLine + "  REG.s1 = mad(  BETA.s0, DST.s1, REG.s1 ); \\" + endLine + "  /* (3) */ \\" + endLine + "  DST = REG;" + endLine;
            } else {
              kStr += "#define TYPE_MAD_WRITE( DST, ALPHA, REG, BETA ) \\" + endLine + "  /* (1) */ \\" + endLine + "  type_mad_tmp = REG.s0; \\" + endLine + "  REG.s0 *= ALPHA.s0; \\" + endLine + "  REG.s0 = mad( -ALPHA.s1, REG.s1, REG.s0 ); \\" + endLine + "  REG.s1 *= ALPHA.s0; \\" + endLine + "  REG.s1 = mad(  ALPHA.s1, type_mad_tmp, REG.s1 ); \\" + endLine + "  /* (2) */ \\" + endLine + "  REG.s0 = mad(  BETA.s0, DST.s0, REG.s0 ); \\" + endLine + "  REG.s0 = mad( -BETA.s1, DST.s1, REG.s0 ); \\" + endLine + "  REG.s1 = mad(  BETA.s1, DST.s0, REG.s1 ); \\" + endLine + "  REG.s1 = mad(  BETA.s0, DST.s1, REG.s1 ); \\" + endLine + "  /* (3) */ \\" + endLine + "  DST = REG;" + endLine;
            }
          }
          kStr += endLine;
          kStr += "/* " + kernel.microTileNumRows + "x" + kernel.microTileNumCols + " micro-tile */" + endLine;
          kStr += "#define MICRO_TILE \\" + endLine;
          for (var a = 0; a < kernel.microTileNumRows; a++) {
            kStr += "  rA[" + a + "] = localA[offA + " + a + "*WG_NUM_ROWS]; \\" + endLine;
          }
          for (var b = 0; b < kernel.microTileNumCols; b++) {
            kStr += "  rB[" + b + "] = localB[offB + " + b + "*WG_NUM_COLS]; \\" + endLine;
          }
          kStr += "  offA += (MACRO_TILE_NUM_ROWS+LOCAL_COL_PAD); \\" + endLine;
          kStr += "  offB += (MACRO_TILE_NUM_COLS+LOCAL_ROW_PAD); \\" + endLine;
          for (var a = 0; a < kernel.microTileNumRows; a++) {
            for (var b = 0; b < kernel.microTileNumCols; b++) {
              kStr += "  TYPE_MAD(rA[" + a + "],rB[" + b + "],rC[" + a + "][" + b + "]); \\" + endLine;
            }
          }
          kStr += "  mem_fence(CLK_LOCAL_MEM_FENCE);" + endLine;
          kStr += endLine;
          kStr += "__attribute__((reqd_work_group_size(WG_NUM_COLS,WG_NUM_ROWS,1)))" + endLine;
          kStr += "__kernel void kernel_func";
          kStr += "(" + endLine;
          kStr += "  __global DATA_TYPE_STR const * restrict A," + endLine + "  __global DATA_TYPE_STR const * restrict B," + endLine + "  __global DATA_TYPE_STR       *          C," + endLine + "  DATA_TYPE_STR const alpha," + endLine + "  DATA_TYPE_STR const beta," + endLine + "  uint const M," + endLine + "  uint const N," + endLine + "  uint const K," + endLine + "  uint const lda," + endLine + "  uint const ldb," + endLine + "  uint const ldc," + endLine + "  uint const offsetA," + endLine + "  uint const offsetB," + endLine + "  uint const offsetC" + endLine + ") {" + endLine;
          kStr += endLine;
          kStr += "  /* apply offsets */" + endLine + "  A += offsetA;" + endLine + "  B += offsetB;" + endLine + "  C += offsetC;" + endLine;
          kStr += endLine;
          kStr += "  /* allocate registers */" + endLine + "  DATA_TYPE_STR rC[MICRO_TILE_NUM_ROWS][MICRO_TILE_NUM_COLS] = { {0} };" + endLine + "  DATA_TYPE_STR rA[MICRO_TILE_NUM_ROWS];" + endLine + "  DATA_TYPE_STR rB[MICRO_TILE_NUM_COLS];" + endLine;
          kStr += endLine;
          kStr += "  /* allocate local memory */" + endLine + "  __local DATA_TYPE_STR localA[NUM_UNROLL_ITER*(MACRO_TILE_NUM_ROWS+LOCAL_COL_PAD)];" + endLine + "  __local DATA_TYPE_STR localB[NUM_UNROLL_ITER*(MACRO_TILE_NUM_COLS+LOCAL_ROW_PAD)];" + endLine;
          kStr += endLine;
          kStr += "  /* work item indices */" + endLine;
          if (kernel.isRowKernel()) {
            kStr += "  uint groupRow = M / " + kernel.workGroupNumRows * kernel.microTileNumRows + "; // last row" + endLine;
          } else {
            kStr += "  uint groupRow = get_group_id(0);" + endLine;
          }
          if (kernel.isColKernel()) {
            kStr += "  uint groupCol = N / " + kernel.workGroupNumCols * kernel.microTileNumCols + "; // last column" + endLine;
          } else {
            kStr += "  uint groupCol = get_group_id(1);" + endLine;
          }
          if (false) {
            kStr += "  // convert work-group order to z-order" + endLine + "  unsigned int morton = get_group_id(1) * get_num_groups(0) + get_group_id(0);" + endLine + "  groupRow = morton;" + endLine + "  groupCol = ( groupRow >> 1 );" + endLine + "  groupRow &= 0x55555555;" + endLine + "  groupCol &= 0x55555555;" + endLine + "  groupRow |= ( groupRow >> 1 );" + endLine + "  groupCol |= ( groupCol >> 1 );" + endLine + "  groupRow &= 0x33333333;" + endLine + "  groupCol &= 0x33333333;" + endLine + "  groupRow |= ( groupRow >> 2 );" + endLine + "  groupCol |= ( groupCol >> 2 );" + endLine + "  groupRow &= 0x0f0f0f0f;" + endLine + "  groupCol &= 0x0f0f0f0f;" + endLine + "  groupRow |= ( groupRow >> 4 );" + endLine + "  groupCol |= ( groupCol >> 4 );" + endLine + "  groupRow &= 0x00ff00ff;" + endLine + "  groupCol &= 0x00ff00ff;" + endLine + "  groupRow |= ( groupRow >> 8 );" + endLine + "  groupCol |= ( groupCol >> 8 );" + endLine + "  groupRow &= 0x0000ffff;" + endLine + "  groupCol &= 0x0000ffff;" + endLine + endLine;
          }
          kStr += "  uint localRow = get_local_id(0);" + endLine + "  uint localCol = get_local_id(1);" + endLine + "  uint localSerial = localRow + localCol*WG_NUM_ROWS;" + endLine;
          kStr += endLine;
          kStr += "  /* global indices being loaded */" + endLine;
          if (kernel.order == "clblasColumnMajor" == (kernel.transA == "N")) {
            kStr += "#define globalARow(LID) (groupRow*MACRO_TILE_NUM_ROWS + (localSerial+(LID)*WG_NUM_ROWS*WG_NUM_COLS)%MACRO_TILE_NUM_ROWS)" + endLine + "#define globalACol(LID) ((localSerial+(LID)*WG_NUM_ROWS*WG_NUM_COLS)/MACRO_TILE_NUM_ROWS)" + endLine;
          } else {
            kStr += "#define globalARow(LID) (groupRow*MACRO_TILE_NUM_ROWS + (localSerial+(LID)*WG_NUM_ROWS*WG_NUM_COLS)/NUM_UNROLL_ITER)" + endLine + "#define globalACol(LID) ((localSerial+(LID)*WG_NUM_ROWS*WG_NUM_COLS)%NUM_UNROLL_ITER)" + endLine;
          }
          if (kernel.order == "clblasColumnMajor" == (kernel.transB == "N")) {
            kStr += "#define globalBRow(LID) ((localSerial+(LID)*WG_NUM_ROWS*WG_NUM_COLS)%NUM_UNROLL_ITER)" + endLine + "#define globalBCol(LID) (groupCol*MACRO_TILE_NUM_COLS + (localSerial+(LID)*WG_NUM_ROWS*WG_NUM_COLS)/NUM_UNROLL_ITER)" + endLine;
          } else {
            kStr += "#define globalBRow(LID) ((localSerial+(LID)*WG_NUM_ROWS*WG_NUM_COLS)/MACRO_TILE_NUM_COLS)" + endLine + "#define globalBCol(LID) (groupCol*MACRO_TILE_NUM_COLS + (localSerial+(LID)*WG_NUM_ROWS*WG_NUM_COLS)%MACRO_TILE_NUM_COLS)" + endLine;
          }
          kStr += endLine;
          kStr += "  /* loop over k */" + endLine + "  uint block_k = K / NUM_UNROLL_ITER;" + endLine + "  do {" + endLine;
          kStr += endLine;
          kStr += "    /* local indices being written */" + endLine;
          if (kernel.order == "clblasColumnMajor" == (kernel.transA == "N")) {
            kStr += "#define localARow (localSerial % MACRO_TILE_NUM_ROWS)" + endLine + "#define localACol (localSerial / MACRO_TILE_NUM_ROWS)" + endLine + "#define localAStride (WG_NUM_ROWS*WG_NUM_COLS)" + endLine;
          } else {
            kStr += "#define localARow (localSerial / NUM_UNROLL_ITER)" + endLine + "#define localACol (localSerial % NUM_UNROLL_ITER)" + endLine + "#define localAStride (WG_NUM_ROWS*WG_NUM_COLS/NUM_UNROLL_ITER)" + endLine;
          }
          if (kernel.order == "clblasColumnMajor" == (kernel.transB == "N")) {
            kStr += "#define localBRow ( localSerial % NUM_UNROLL_ITER )" + endLine + "#define localBCol ( localSerial / NUM_UNROLL_ITER )" + endLine + "#define localBStride (WG_NUM_ROWS*WG_NUM_COLS/NUM_UNROLL_ITER)" + endLine;
          } else {
            kStr += "#define localBRow ( localSerial / MACRO_TILE_NUM_COLS )" + endLine + "#define localBCol ( localSerial % MACRO_TILE_NUM_COLS )" + endLine + "#define localBStride  (WG_NUM_ROWS*WG_NUM_COLS)" + endLine;
          }
          kStr += "    __local DATA_TYPE_STR *lA = localA + GET_LOCAL_INDEX_A(localARow, localACol);" + endLine + "    __local DATA_TYPE_STR *lB = localB + GET_LOCAL_INDEX_B(localBRow, localBCol);" + endLine + "    barrier(CLK_LOCAL_MEM_FENCE);" + endLine;
          kStr += endLine;
          kStr += "    /* load global -> local */" + endLine;
          var numALoads = Math.floor(kernel.workGroupNumRows * kernel.microTileNumRows * kernel.unroll / (kernel.workGroupNumRows * kernel.workGroupNumCols));
          var numALoadsR = kernel.workGroupNumRows * kernel.microTileNumRows * kernel.unroll % (kernel.workGroupNumRows * kernel.workGroupNumCols);
          var numBLoads = Math.floor(kernel.workGroupNumCols * kernel.microTileNumCols * kernel.unroll / (kernel.workGroupNumRows * kernel.workGroupNumCols));
          var numBLoadsR = kernel.workGroupNumCols * kernel.microTileNumCols * kernel.unroll % (kernel.workGroupNumRows * kernel.workGroupNumCols);
          var zeroString;
          if (kernel.precision == "c") {
            zeroString = "(float2)(0.f, 0.f)";
          } else if (kernel.precision == "z") {
            zeroString = "(double2)(0.0, 0.0)";
          } else {
            zeroString = "0.0";
          }
          for (var a = 0; a < numALoads; a++) {
            kStr += "    lA[ " + a + "*localAStride ] = ";
            if (kernel.isRowKernel()) {
              kStr += "( globalARow(" + a + ") >= M) ? " + zeroString + " : ";
            }
            kStr += "A[ GET_GLOBAL_INDEX_A( globalARow(" + a + "), globalACol(" + a + ") ) ];" + endLine;
          }
          if (numALoadsR > 0) {
            kStr += "    if ( localSerial + " + numALoads + "*WG_NUM_ROWS*WG_NUM_COLS < (WG_NUM_ROWS*MICRO_TILE_NUM_ROWS*NUM_UNROLL_ITER) ) {" + endLine;
            kStr += "      lA[ " + numALoads + "*localAStride ] = ";
            if (kernel.isRowKernel()) {
              kStr += "( globalARow(" + numALoads + ") >= M) ? " + zeroString + " : ";
            }
            kStr += "A[ GET_GLOBAL_INDEX_A( globalARow(" + numALoads + "), globalACol(" + numALoads + ") ) ];" + endLine;
            kStr += "    }" + endLine;
          }
          for (var b = 0; b < numBLoads; b++) {
            kStr += "    lB[ " + b + "*localBStride ] = ";
            if (kernel.isColKernel()) {
              kStr += "( globalBCol(" + b + ") >= N) ? " + zeroString + " : ";
            }
            kStr += "B[ GET_GLOBAL_INDEX_B( globalBRow(" + b + "), globalBCol(" + b + ") ) ];" + endLine;
          }
          if (numBLoadsR > 0) {
            kStr += "    if ( localSerial + " + numBLoads + "*WG_NUM_ROWS*WG_NUM_COLS < (WG_NUM_COLS*MICRO_TILE_NUM_COLS*NUM_UNROLL_ITER) ) {" + endLine;
            kStr += "      lB[ " + numBLoads + "*localBStride ] = ";
            if (kernel.isColKernel()) {
              kStr += "(globalBCol(" + numBLoads + ") >= N) ? " + zeroString + " : ";
            }
            kStr += "B[ GET_GLOBAL_INDEX_B( globalBRow(" + numBLoads + "), globalBCol(" + numBLoads + ") ) ];" + endLine;
            kStr += "    }" + endLine;
          }
          kStr += "    barrier(CLK_LOCAL_MEM_FENCE);" + endLine + "    uint offA = localRow;" + endLine + "    uint offB = localCol;" + endLine;
          kStr += endLine;
          kStr += "    /* do mads */" + endLine;
          for (var u = 0; u < kernel.unroll; u++) {
            kStr += "    MICRO_TILE" + endLine;
          }
          kStr += endLine;
          kStr += "    /* shift to next k block */" + endLine;
          if (kernel.order == "clblasColumnMajor" == (kernel.transA == "N")) {
            kStr += "    A += lda*NUM_UNROLL_ITER;" + endLine;
          } else {
            kStr += "    A += NUM_UNROLL_ITER;" + endLine;
          }
          if (kernel.order == "clblasColumnMajor" == (kernel.transB == "N")) {
            kStr += "    B += NUM_UNROLL_ITER;" + endLine;
          } else {
            kStr += "    B += ldb*NUM_UNROLL_ITER;" + endLine;
          }
          kStr += endLine;
          kStr += "  } while (--block_k > 0);" + endLine;
          kStr += endLine;
          kStr += endLine;
          kStr += "  /* which global Cij index */" + endLine;
          kStr += "  uint globalCRow = groupRow * MACRO_TILE_NUM_ROWS + localRow;" + endLine;
          kStr += "  uint globalCCol = groupCol * MACRO_TILE_NUM_COLS + localCol;" + endLine;
          kStr += endLine;
          kStr += "  /* write global Cij */" + endLine;
          if (kernel.precision == "c") {
            kStr += "  float type_mad_tmp;" + endLine;
          }
          if (kernel.precision == "z") {
            kStr += "  double type_mad_tmp;" + endLine;
          }
          for (var a = 0; a < kernel.microTileNumRows; a++) {
            for (var b = 0; b < kernel.microTileNumCols; b++) {
              if (kernel.isRowKernel()) {
                kStr += "  if (globalCRow+" + a + "*WG_NUM_ROWS < M)";
              }
              if (kernel.isColKernel()) {
                kStr += "  if (globalCCol+" + b + "*WG_NUM_COLS < N)";
              }
              if (kernel.isRowKernel() || kernel.isColKernel()) {
                kStr += "{";
              }
              kStr += "  TYPE_MAD_WRITE( C[ GET_GLOBAL_INDEX_C( globalCRow+" + a + "*WG_NUM_ROWS, globalCCol+" + b + "*WG_NUM_COLS) ], alpha, rC[" + a + "][" + b + "], beta )";
              if (kernel.isRowKernel() || kernel.isColKernel()) {
                kStr += "}";
              }
              kStr += endLine;
            }
          }
          kStr += endLine;
          kStr += "}" + endLine;
          return kStr;
        }
        return function(name) {
          var kernel;
          if (!(name in kernels)) {
            var kp = new KernelParameters(name);
            var kernelstr = makeOpenCLKernelString(kp);
            kernel = $CL.createKernel(kernelstr);
            kernels[name] = kernel;
          } else {
            kernel = kernels[name];
          }
          return kernel;
        };
      }();
    })();
  }
});

// node_modules/milsushi2/src/cl/handwrittenjs/sushi_cl.js
var require_sushi_cl = __commonJS({
  "node_modules/milsushi2/src/cl/handwrittenjs/sushi_cl.js"(exports2, module2) {
    "use strict";
    var $M = require_sushi();
    var util2 = require_util();
    module2.exports = $M;
    (function() {
      if ($M.CL) {
        return;
      }
      var $CL = require_driver();
      $M.CL = $CL;
      var Matrix2 = require_matrix();
      var MatrixCL = require_matrix_cl();
      $M.CL.MatrixCL = MatrixCL;
      var WebCL2 = $M.CL.WebCL;
      $M.gpuArray = function(A) {
        if (A instanceof MatrixCL) {
          return A.copy();
        }
        A = util2.as_mat(A);
        var mat = new MatrixCL(A._size, A._klass);
        mat.write(A._data);
        return mat;
      };
      $M.gather = function(A) {
        if (!(A instanceof MatrixCL)) {
          return A.copy();
        }
        var mat = new Matrix2(A._size, A._klass);
        A.read(mat._data);
        return mat;
      };
      $M.devicetype = function(A) {
        if (A instanceof MatrixCL) {
          return "cl";
        } else if (A instanceof Matrix2) {
          return "cpu";
        }
        return null;
      };
      var zeros_native = $M.zeros;
      $M.zeros = function() {
        if (arguments[arguments.length - 1] == "gpuArray") {
          var format = util2.calc_zeros_size(Array.prototype.slice.call(arguments, 0, -1));
          var mat = new MatrixCL(format.size, format.klass);
          mat._fill(0);
          return mat;
        } else {
          return zeros_native.apply(null, arguments);
        }
      };
      var ones_native = $M.ones;
      $M.ones = function() {
        if (arguments[arguments.length - 1] == "gpuArray") {
          var format = util2.calc_zeros_size(Array.prototype.slice.call(arguments, 0, -1));
          var mat = new MatrixCL(format.size, format.klass);
          mat._fill(1);
          return mat;
        } else {
          return ones_native.apply(null, arguments);
        }
      };
      require_binary_arithmetic();
      require_unary_arithmetic();
      require_shape_converter_cl();
      require_reduction_cl();
      require_clblasgemm();
    })();
  }
});

// node_modules/milsushi2/src/sushi.js
var require_sushi = __commonJS({
  "node_modules/milsushi2/src/sushi.js"(exports2) {
    "use strict";
    var polyfill = require_polyfill();
    exports2.Matrix = require_matrix();
    exports2.Colon = require_colon();
    exports2.colon = require_colonwrap();
    var util2 = require_util();
    var func_generator2 = require_func_generator();
    var shape_converter = require_shape_converter();
    var reduction = require_reduction();
    var mul = require_mul();
    var npy = require_npy();
    exports2.CL = null;
    polyfill.polyfill();
    exports2.end = -1;
    var initcl_result = null;
    function initcl() {
      if (initcl_result != null) {
        return initcl_result;
      }
      try {
        var dummy = require_sushi_cl();
        initcl_result = true;
      } catch (ex) {
        console.error(ex);
        initcl_result = false;
      }
      return initcl_result;
    }
    exports2.initcl = initcl;
    function devicetype(A) {
      if (A instanceof exports2.Matrix) {
        return "cpu";
      }
      return null;
    }
    exports2.devicetype = devicetype;
    function autodestruct(f2) {
      exports2.Matrix.autodestruct_push();
      var mats_to_save = [];
      try {
        mats_to_save = f2();
      } finally {
        if (typeof mats_to_save === "object") {
          var mats_list;
          if (mats_to_save instanceof exports2.Matrix) {
            mats_list = [mats_to_save];
          } else if (mats_to_save.length !== void 0) {
            mats_list = mats_to_save.filter(function(v) {
              return v instanceof exports2.Matrix;
            });
          } else {
            mats_list = [];
            for (var k in mats_to_save) {
              if (mats_to_save[k] instanceof exports2.Matrix) {
                mats_list.push(mats_to_save[k]);
              }
            }
          }
          var stack_top = exports2.Matrix._autodestruct_stack_top;
          var stack_second_top = exports2.Matrix._autodestruct_stack[exports2.Matrix._autodestruct_stack.length - 2];
          for (var i2 = 0; i2 < mats_list.length; i2++) {
            var mat = mats_list[i2];
            var delete_idx = stack_top.indexOf(mat);
            if (delete_idx >= 0) {
              stack_top.splice(delete_idx, 1);
              if (stack_second_top) {
                stack_second_top.push(mat);
              }
            }
          }
        }
        exports2.Matrix.autodestruct_pop();
      }
      return mats_to_save;
    }
    exports2.autodestruct = autodestruct;
    exports2.typedarray2mat = exports2.Matrix.typedarray2mat;
    function zeros() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var format = util2.calc_zeros_size(args);
      return new exports2.Matrix(format.size, format.klass);
    }
    exports2.zeros = zeros;
    function ones() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var mat = zeros.apply(void 0, args);
      mat._data.fill(1);
      return mat;
    }
    exports2.ones = ones;
    function rand() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var mat = zeros.apply(void 0, args);
      var data = mat._data;
      for (var i2 = 0, length2 = data.length; i2 < length2; i2++) {
        data[i2] = Math.random();
      }
      return mat;
    }
    exports2.rand = rand;
    function randi(imax) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var _imin = 1, _imax = 1;
      if (imax.length != null) {
        if (imax.length === 2) {
          _imin = imax[0];
          _imax = imax[1];
        } else {
          throw new Error("Invalid imax");
        }
      } else {
        _imax = imax;
      }
      var mat = zeros.apply(void 0, args);
      var data = mat._data;
      for (var i2 = 0, length2 = data.length; i2 < length2; i2++) {
        data[i2] = Math.floor(Math.random() * (_imax - _imin + 1)) + _imin;
      }
      return mat;
    }
    exports2.randi = randi;
    function randn() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var mat = zeros.apply(void 0, args);
      var data = mat._data;
      for (var i2 = 0, length2 = data.length; i2 < length2; i2++) {
        var alpha = Math.random();
        var beta = Math.random();
        data[i2] = Math.sqrt(-2 * Math.log(alpha)) * Math.sin(2 * Math.PI * beta);
      }
      return mat;
    }
    exports2.randn = randn;
    function eye() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var mat = zeros.apply(void 0, args);
      var min_dim = Math.min(mat._size[0], mat._size[1]);
      for (var i2 = 1; i2 <= min_dim; i2++) {
        mat.set(i2, i2, 1);
      }
      return mat;
    }
    exports2.eye = eye;
    function size(X, dim) {
      if (dim === void 0) {
        return jsa2mat([X._size], false, "int32");
      } else {
        if (dim <= 0 || !exports2.Matrix._isinteger(dim)) {
          throw new Error("Invalid dimension");
        }
        return X._size[dim - 1] || 1;
      }
    }
    exports2.size = size;
    function sizejsa(X) {
      return X._size;
    }
    exports2.sizejsa = sizejsa;
    function jsa2mat(A, one_d_column, klass2) {
      return exports2.Matrix.jsa2mat(A, one_d_column, klass2);
    }
    exports2.jsa2mat = jsa2mat;
    function mat2jsa(A, one_d_flatten) {
      if (one_d_flatten === void 0) {
        one_d_flatten = false;
      }
      return A.mat2jsa(one_d_flatten);
    }
    exports2.mat2jsa = mat2jsa;
    function length(X) {
      return Math.max.apply(null, X._size);
    }
    exports2.length = length;
    function ndims(X) {
      return X._ndims;
    }
    exports2.ndims = ndims;
    function numel(X) {
      return X._numel;
    }
    exports2.numel = numel;
    function iscolumn(A) {
      return A._ndims == 2 && A._size[1] == 1;
    }
    exports2.iscolumn = iscolumn;
    function isrow(A) {
      return A._ndims == 2 && A._size[0] == 1;
    }
    exports2.isrow = isrow;
    function isvector(A) {
      return A._ndims == 2 && (A._size[0] == 1 || A._size[1] == 1);
    }
    exports2.isvector = isvector;
    function isempty(A) {
      return A._numel == 0;
    }
    exports2.isempty = isempty;
    function ismatrix(A) {
      return A._ndims == 2;
    }
    exports2.ismatrix = ismatrix;
    function isscalar(A) {
      return A._numel == 1;
    }
    exports2.isscalar = isscalar;
    function klass(object) {
      return object._klass;
    }
    exports2.klass = klass;
    function gpuArray(A) {
      return util2.as_mat(A).copy();
    }
    exports2.gpuArray = gpuArray;
    function gather(A) {
      return A.copy();
    }
    exports2.gather = gather;
    exports2.eq = function(A, B) {
      throw new Error();
    };
    exports2.eq = func_generator2.make_compare_func_all("Number(%a == %b)");
    exports2.ge = function(A, B) {
      throw new Error();
    };
    exports2.ge = func_generator2.make_compare_func_all("Number(%a >= %b)");
    exports2.gt = function(A, B) {
      throw new Error();
    };
    exports2.gt = func_generator2.make_compare_func_all("Number(%a > %b)");
    exports2.le = function(A, B) {
      throw new Error();
    };
    exports2.le = func_generator2.make_compare_func_all("Number(%a <= %b)");
    exports2.lt = function(A, B) {
      throw new Error();
    };
    exports2.lt = func_generator2.make_compare_func_all("Number(%a < %b)");
    exports2.ne = function(A, B) {
      throw new Error();
    };
    exports2.ne = func_generator2.make_compare_func_all("Number(%a != %b)");
    exports2.isequal = function() {
      var As = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        As[_i] = arguments[_i];
      }
      throw new Error();
    };
    exports2.isequal = func_generator2.isequal;
    exports2.isequaln = function() {
      var As = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        As[_i] = arguments[_i];
      }
      throw new Error();
    };
    exports2.isequaln = func_generator2.isequaln;
    exports2.isclose = function(A, B, rtol, atol, equal_nan) {
      if (rtol === void 0) {
        rtol = 1e-5;
      }
      if (atol === void 0) {
        atol = 1e-8;
      }
      if (equal_nan === void 0) {
        equal_nan = false;
      }
      throw new Error();
    };
    exports2.isclose = func_generator2.isclose;
    exports2.allclose = function(A, B, rtol, atol, equal_nan) {
      throw new Error();
    };
    exports2.allclose = func_generator2.allclose;
    exports2.plus = func_generator2.make_binary_arith_func_all("%a + %b");
    exports2.minus = func_generator2.make_binary_arith_func_all("%a - %b");
    exports2.times = func_generator2.make_binary_arith_func_all("%a * %b");
    exports2.rdivide = func_generator2.make_binary_arith_func_all("%a / %b");
    exports2.ldivide = func_generator2.make_binary_arith_func_all("%b / %a");
    exports2.power = func_generator2.make_binary_arith_func_all("Math.pow(%a,%b)");
    exports2.floor = func_generator2.make_unary_arith_func_all("Math.floor(%a)");
    exports2.fix = func_generator2.make_unary_arith_func_all("(%a > 0 ? Math.floor(%a) : Math.ceil(%a))");
    exports2.ceil = func_generator2.make_unary_arith_func_all("Math.ceil(%a)");
    exports2.uplus = func_generator2.make_unary_arith_func_all("+%a");
    exports2.uminus = func_generator2.make_unary_arith_func_all("-%a");
    exports2.exp = func_generator2.make_unary_arith_func_all("Math.exp(%a)");
    exports2.log = func_generator2.make_unary_arith_func_all("Math.log(%a)");
    exports2.max = reduction.max;
    exports2.min = reduction.min;
    exports2.argmax = reduction.argmax;
    exports2.argmin = reduction.argmin;
    exports2.sum = reduction.sum;
    exports2.mean = reduction.mean;
    exports2.prod = reduction.prod;
    exports2.std = reduction.std;
    exports2.variance = reduction.variance;
    exports2.mtimes = mul.mtimes;
    function reshape(A) {
      var sz = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        sz[_i - 1] = arguments[_i];
      }
      var dst = A.copy();
      try {
        dst.reshape_inplace.apply(dst, sz);
        return dst;
      } catch (error) {
        dst.destruct();
        throw error;
      }
    }
    exports2.reshape = reshape;
    function squeeze(A) {
      var dst = A.copy();
      dst.squeeze_inplace();
      return dst;
    }
    exports2.squeeze = squeeze;
    exports2.transpose = shape_converter.transpose;
    exports2.t = exports2.transpose;
    exports2.repmat = shape_converter.repmat;
    exports2.cat = shape_converter.cat;
    exports2.horzcat = shape_converter.horzcat;
    exports2.vertcat = shape_converter.vertcat;
    exports2.permute = shape_converter.permute;
    exports2.ipermute = shape_converter.ipermute;
    exports2.npyread = npy.npyread;
    exports2.npysave = npy.npysave;
    function sub2ind(matrixSize) {
      var dimSub = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        dimSub[_i - 1] = arguments[_i];
      }
      var msizejsa;
      if (matrixSize instanceof exports2.Matrix) {
        if (!isrow(matrixSize) || matrixSize._numel < 2) {
          throw new Error("matrixSize must be row vector");
        }
        msizejsa = matrixSize.mat2jsa(true);
      } else {
        msizejsa = matrixSize;
      }
      var stride = 1;
      var idx = 1;
      for (var i2 = 0; i2 < msizejsa.length; i2++) {
        idx += ((dimSub[i2] || 1) - 1) * stride;
        stride *= msizejsa[i2];
      }
      return idx;
    }
    exports2.sub2ind = sub2ind;
    function colonvec(start, stop_step, stop, klass2) {
      if (klass2 === void 0) {
        klass2 = "single";
      }
      var step;
      if (stop == null) {
        stop = stop_step;
        step = 1;
      } else {
        step = stop_step;
      }
      var n_item = Math.max(Math.floor((stop - start) / step) + 1, 0);
      var vec = new exports2.Matrix([1, n_item], klass2);
      var vec_data = vec._data;
      for (var i2 = 0; i2 < n_item; i2++) {
        vec_data[i2] = start + step * i2;
      }
      return vec;
    }
    exports2.colonvec = colonvec;
  }
});

// node_modules/milsushi2/index.js
var require_milsushi2 = __commonJS({
  "node_modules/milsushi2/index.js"(exports2, module2) {
    var Sushi = require_sushi();
    module2.exports = Sushi;
  }
});
export default require_milsushi2();
//# sourceMappingURL=milsushi2.js.map
