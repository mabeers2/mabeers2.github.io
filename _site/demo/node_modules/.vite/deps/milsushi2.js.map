{
  "version": 3,
  "sources": ["../../milsushi2/src/polyfill.ts", "../../milsushi2/src/colon.ts", "../../milsushi2/src/matrix.ts", "../../milsushi2/src/colonwrap.ts", "../../milsushi2/src/util.ts", "../../milsushi2/src/func_generator.ts", "../../milsushi2/src/shape_converter.ts", "../../milsushi2/src/reduction.ts", "../../milsushi2/src/mul.ts", "../../milsushi2/src/io/npy.ts", "../../milsushi2/src/cl/handwrittenjs/driver_opencl.js", "../../milsushi2/src/cl/handwrittenjs/driver_webcl.js", "../../milsushi2/src/cl/handwrittenjs/driver.js", "../../milsushi2/src/cl/matrix_cl.ts", "../../milsushi2/src/cl/handwrittenjs/util_cl.js", "../../milsushi2/src/cl/handwrittenjs/binary_arithmetic.js", "../../milsushi2/src/cl/handwrittenjs/unary_arithmetic.js", "../../milsushi2/src/cl/handwrittenjs/shape_converter_cl.js", "../../milsushi2/src/cl/handwrittenjs/reduction_cl.js", "../../milsushi2/src/cl/handwrittenjs/clblasgemm.js", "../../milsushi2/src/cl/handwrittenjs/sushi_cl.js", "../../milsushi2/src/sushi.ts", "../../milsushi2/index.ts"],
  "sourcesContent": ["// does polyfill for older browsers\n\nexport function polyfill(): void {\n  typedarray_fill_all();\n}\n\nfunction typedarray_fill_all(): void {\n  typedarray_fill(Int8Array);\n  typedarray_fill(Uint8Array);\n  typedarray_fill(Uint8ClampedArray);\n  typedarray_fill(Int16Array);\n  typedarray_fill(Uint16Array);\n  typedarray_fill(Int32Array);\n  typedarray_fill(Uint32Array);\n  typedarray_fill(Float32Array);\n  typedarray_fill(Float64Array);\n}\n\nfunction typedarray_fill(type: any): void {\n  // https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Polyfill\n  if (!type.prototype.fill) {\n    type.prototype.fill = function (value) {\n\n      // Steps 1-2.\n      if (this == null) {\n        throw new TypeError('this is null or not defined');\n      }\n\n      var O = Object(this);\n\n      // Steps 3-5.\n      var len = O.length >>> 0;\n\n      // Steps 6-7.\n      var start = arguments[1];\n      var relativeStart = start >> 0;\n\n      // Step 8.\n      var k = relativeStart < 0 ?\n        Math.max(len + relativeStart, 0) :\n        Math.min(relativeStart, len);\n\n      // Steps 9-10.\n      var end = arguments[2];\n      var relativeEnd = end === undefined ?\n        len : end >> 0;\n\n      // Step 11.\n      var final = relativeEnd < 0 ?\n        Math.max(len + relativeEnd, 0) :\n        Math.min(relativeEnd, len);\n\n      // Step 12.\n      while (k < final) {\n        O[k] = value;\n        k++;\n      }\n\n      // Step 13.\n      return O;\n    };\n  }\n}\n", "// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\n// colon object\n// $M.colon(1,3,10) or $M.colon.fromstring('1:3:10');\n\nclass Colon {\n  // http://jp.mathworks.com/help/matlab/ref/colon.html\n  start: number;\n  stop: number;\n  step: number;\n  all: boolean;//means ':'\n  constructor(start?: number, stop_step?: number, stop?: number) {\n    this.start = start;\n    this.step = 1;\n    if (this.start == null) {\n      this.all = true;\n    } else {\n      if (stop != null) {\n        // start:step:stop\n        this.step = stop_step;\n        this.stop = stop;\n      } else {\n        // start:1:stop\n        this.stop = stop_step;\n      }\n    }\n  }\n\n  static fromstring(s: string): Colon {\n    var elements = s.replace('end', '-1').split(':');\n    var nums: number[] = [];\n    for (var i = 0; i < elements.length; i++) {\n      nums.push(eval(elements[i] || 'null'));\n    }\n\n    if (elements.length == 2) {\n      return new Colon(nums[0], nums[1]);\n    } else if (elements.length == 3) {\n      return new Colon(nums[0], nums[1], nums[2]);\n    } else {\n      throw new Error('Invalid format');\n    }\n  }\n\n  tojsa(size?: number): number[] {\n    var start = this.start;\n    var stop = this.stop;\n    var step = this.step;\n    if (this.all) {\n      start = 1;\n      stop = size;\n      step = 1;\n    }\n    if (start < 0) {\n      start += size + 1;\n    }\n    if (stop < 0) {\n      stop += size + 1;\n    }\n\n    var jsa: number[] = [];\n    if (step > 0) {\n      for (var i = start; i <= stop; i += step) {\n        jsa.push(i);\n      }\n    } else if (step < 0) {\n      for (var i = start; i >= stop; i += step) {\n        jsa.push(i);\n      }\n    }//step == 0 means length 0\n\n    return jsa;\n  }\n\n  toString(): string {\n    if (this.start == null) {\n      return ':';\n    } else {\n      if (this.step == null) {\n        return colonedge2str(this.start) + ':' + colonedge2str(this.stop);\n      } else {\n        return colonedge2str(this.start) + ':' + this.step + ':' + colonedge2str(this.stop);\n      }\n    }\n  }\n}\n\nfunction colonedge2str(val: number): string {\n  if (val >= 0) {\n    return '' + val;\n  } else {\n    if (val == 0) {\n      return 'end';\n    }\n    return 'end-' + (-1 - val);\n  }\n}\n\nexport = Colon;\n", "// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\nimport Colon = require('./colon');\nimport typedef = require('./typedef');\n\ntype AllowedTypedArray = typedef.AllowedTypedArray;//TODO: find way to use AllowedTypedArray in public methods\n\nclass Matrix {\n  _size: number[];\n  _ndims: number;\n  _numel: number;\n  _klass: string;\n  _data_ctor: any;\n  _data: typedef.AllowedTypedArray;//allocated in constructor\n  _strides: number[];// in typedarray index (not byte)\n  static _autodestruct_stack: Matrix[][] = [];\n  static _autodestruct_stack_top: Matrix[] = null;\n\n  constructor(size: number[], klass: string = 'single', noalloc: boolean = false) {\n    var _size: number[] = Array.prototype.slice.call(size);//copy\n    //verify size\n    var tmpnumel: number = 1;\n    var strides: number[] = [];\n    var last_none_one_dim = 0;\n    if (_size.length < 2) {\n      throw new Error('matrix must have at least 2 dimensions');\n    }\n    for (var i = 0; i < _size.length; i++) {\n      var dimsize = _size[i];\n      if (typeof (dimsize) !== 'number' || dimsize < 0 || !Matrix._isinteger(dimsize)) {\n        throw new Error('size is invalid');\n      }\n      if (dimsize != 1) {\n        last_none_one_dim = i;\n      }\n      strides.push(tmpnumel);\n      tmpnumel *= dimsize;\n    }\n    if (tmpnumel >= 2147483648) {\n      // indexing with int32 value is impossible\n      throw new Error('Matrix of equal to or more than 2G elements is not supported');\n    }\n    this._numel = tmpnumel;\n    //remove tail dimensions with size 1 (retain minimum 2 dimensions)\n    last_none_one_dim = Math.max(last_none_one_dim, 1) + 1;\n    _size.splice(last_none_one_dim);\n    strides.splice(last_none_one_dim);\n    this._size = _size;\n    this._ndims = _size.length;\n    this._strides = strides;\n\n    if (!Matrix._isvalidklass(klass)) {\n      throw new Error('unknown klass');\n    }\n    this._klass = klass;\n    this._data_ctor = Matrix.data_ctors[klass];\n    if (!noalloc) {\n      this._alloccpu();\n    }\n\n    if (Matrix._autodestruct_stack_top) {\n      Matrix._autodestruct_stack_top.push(this);\n    }\n  }\n\n  static data_ctors = { 'single': Float32Array, 'int32': Int32Array, 'uint8': Uint8Array, 'logical': Uint8Array };\n\n  static autodestruct_push(): void {\n    var array = [];\n    Matrix._autodestruct_stack_top = array;\n    Matrix._autodestruct_stack.push(array);\n  }\n\n  static autodestruct_pop(): void {\n    if (Matrix._autodestruct_stack_top) {\n      //destruct all in current list\n      //console.log('Autodestruct: ' + Matrix._autodestruct_stack_top.length + ' mats');\n      for (var i = 0; i < Matrix._autodestruct_stack_top.length; i++) {\n        Matrix._autodestruct_stack_top[i].destruct();\n      }\n\n      Matrix._autodestruct_stack.pop();\n      Matrix._autodestruct_stack_top = Matrix._autodestruct_stack[Matrix._autodestruct_stack.length - 1];\n    }\n  }\n\n  destruct() {\n    //release memory\n    this._data = null;\n  }\n\n  inspect(depth: number): string {\n    var shape_str = this._size.join('x');\n    if (this._numel <= 100) {\n      return 'Matrix ' + shape_str + ' ' + this._klass + '\\n' + this.toString();\n    } else {\n      return 'Matrix ' + shape_str + ' ' + this._klass;\n    }\n  }\n\n  static typedarray2mat(size: number[], klass: string = 'single', data: typedef.AllowedTypedArray): Matrix {\n    //type check\n    if (!(data instanceof Matrix.data_ctors[klass])) {\n      throw Error('klass and data type mismatch');\n    }\n\n    var m = new Matrix(size, klass, true);\n    if (data.length < m._numel) {\n      throw Error('The length of data is smaller than matrix size');\n    }\n\n    m._data = data;\n    if (klass === 'logical') {\n      //force values to 0/1\n      for (var i = 0; i < m._numel; i++) {\n        data[i] = Number(data[i] != 0);\n      }\n    }\n    return m;\n  }\n\n  static _isinteger(x) {\n    return Math.round(x) == x;\n  }\n\n  static _isvalidklass(klass) {\n    return klass == 'single' || klass == 'int32' || klass == 'uint8' || klass == 'logical';\n  }\n\n  static _logical_cast_required(klass_dst: string, klass_src?: string): boolean {\n    return (klass_dst == 'logical' && klass_src != 'logical');\n  }\n\n  static _logical_cast(val: any): number {\n    return Number(Boolean(val));\n  }\n\n  private _alloccpu(): typedef.AllowedTypedArray {\n    // allocate cpu buffer if not exist\n    if (!this._data) {\n      this._data = new this._data_ctor(this._numel);\n    }\n\n    return this._data;\n  }\n\n  to_cpu(): Matrix {\n    return this;\n  }\n\n  _getdata(): typedef.AllowedTypedArray {\n    //override in gpu\n    //get copy of data in TypedArray\n    return this._data;\n  }\n\n  getdataref(src_offset: number = 0, length?: number): typedef.AllowedTypedArray {\n    //get read-only view of array\n    if (!src_offset && length == null) {\n      return this._data;\n    } else {\n      if (length == null) {\n        length = this._numel;\n      }\n      return new this._data_ctor(this._data.buffer, src_offset * this._data.BYTES_PER_ELEMENT, length);\n    }\n  }\n\n  getdatacopy(src_offset: number = 0, length?: number, dst?: typedef.AllowedTypedArray): typedef.AllowedTypedArray {\n    if (length == null) {\n      length = this._numel - src_offset;\n    }\n    if (!dst) {\n      dst = new this._data_ctor(length);\n    }\n\n    var range_view = new this._data_ctor(this._data.buffer, src_offset * this._data.BYTES_PER_ELEMENT, length);\n    dst.set(range_view);\n    return dst;\n  }\n\n  setdata(src: typedef.AllowedTypedArray, dst_offset: number = 0): void {\n    //set raw data into buffer\n    this._data.set(src, dst_offset);\n  }\n\n  _isvalidindex(inds: number[]): boolean {\n    if (this._numel == 0) {\n      // if matrix have zero dimension, all index is invalid\n      return false;\n    }\n    if (inds.length == 0) {\n      return false;\n    } else if (inds.length == 1) {\n      return Matrix._isinteger(inds[0]) && ((inds[0] > 0 && inds[0] <= this._numel) || (inds[0] < 0 && (-inds[0]) <= this._numel));\n    } else {\n      if (inds.length < this._ndims) {\n        // last index last index is regarded as linear index of remaining dimensions\n        for (var dim = 0; dim < inds.length; dim++) {\n          var ind = inds[dim];\n          var dimsize: number;\n          if (dim == inds.length - 1) {\n            //last index\n            dimsize = 1;\n            for (var dimex = dim; dimex < this._ndims; dimex++) {\n              dimsize *= this._size[dimex];\n            }\n          } else {\n            dimsize = this._size[dim];\n          }\n          if (Matrix._isinteger(ind) && ((ind > 0 && (ind <= dimsize) || (ind < 0 && -ind <= dimsize)))) {\n            //ok\n          } else {\n            return false;\n          }\n        }\n      } else {\n        for (var dim = 0; dim < inds.length; dim++) {\n          var ind = inds[dim];\n          var dimsize = this._size[dim] || 1;\n          // if dimensions of inds is more than matrix dimensions, only 1 is ok for the extra dimension\n          if (Matrix._isinteger(ind) && ((ind > 0 && (ind <= dimsize) || (ind < 0 && -ind <= dimsize)))) {\n            //ok\n          } else {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  _isvalidindexerr(inds: number[]): void {\n    if (!this._isvalidindex(inds)) {\n      throw new Error('Invalid index');\n    }\n  }\n\n  _getarrayindex(inds: number[]): number {\n    // assume inds is valid\n    var idx = 0;\n    if (inds.length == 1) {\n      var ind = inds[0];\n      if (ind < 0) {\n        ind += this._numel + 1;\n      }\n      idx = ind - 1;\n    } else {\n      if (inds.length < this._ndims) {\n        // last index last index is regarded as linear index of remaining dimensions\n        for (var dim = 0; dim < inds.length; dim++) {\n          var ind = inds[dim];\n          if (ind < 0) {\n            var dimsize: number;\n            if (dim == inds.length - 1) {\n              //last index\n              dimsize = 1;\n              for (var dimex = dim; dimex < this._ndims; dimex++) {\n                dimsize *= this._size[dimex];\n              }\n            } else {\n              dimsize = this._size[dim];\n            }\n            ind += dimsize + 1;\n          }\n          idx += (ind - 1) * (this._strides[dim] || 0);//trailing 1 does not affect\n        }\n      } else {\n        for (var dim = 0; dim < inds.length; dim++) {\n          var ind = inds[dim];\n          if (ind < 0) {\n            ind += (this._size[dim] || 1) + 1;\n          }\n          idx += (ind - 1) * (this._strides[dim] || 0);//trailing 1 does not affect\n        }\n      }\n    }\n\n    return idx;\n  }\n\n  static numel(A: Matrix): number {\n    return A._numel;\n  }\n\n  static size(X: Matrix): Matrix;\n  static size(X: Matrix, dim: number): number;\n  static size(X: Matrix, dim?: number): any {\n    if (dim == undefined) {\n      return Matrix.jsa2mat([X._size]);\n    } else {\n      return X._size[dim - 1];\n    }\n  }\n\n  static sizejsa(X: Matrix): number[] {\n    return X._size.slice();//array is mutable, so returns copy\n  }\n\n  static jsa2mat(ary: any, one_d_column: boolean = false, klass: string = 'single'): Matrix {\n    // TODO: type inference (contains non-integer => single, contains boolean => logical)\n    // get dimension\n    var mat: Matrix;\n    if (typeof (ary) === 'number') {\n      //1x1 matrix\n      mat = new Matrix([1, 1], klass);\n      mat.set_scalar(<number>ary, [1]);\n    } else if (ary instanceof Matrix) {\n      //simply copy\n      mat = (<Matrix>ary).copy();\n    } else if (!ary.length) {\n      //0x0 matrix (length is undefined or 0)\n      mat = new Matrix([0, 0], klass);\n    } else {\n      //n-d matrix\n      //array[z2][z1][y][x]=mat(y,x,z1,z2)\n      //get shape\n      var arysize: number[] = [];\n      var cur_ary: any[] = ary;\n      var numel = 1;\n      while (cur_ary.length !== void 0) {\n        arysize.push(cur_ary.length);\n        numel *= cur_ary.length;\n        cur_ary = cur_ary[0];\n      }\n      // here, arysize = [z2, z1, y, x]\n      var ndims = arysize.length;\n      var size: number[] = arysize.slice();\n      size.reverse();//[x,y,z1,z2]\n      if (size.length >= 2) {\n        var swap = size[1];\n        size[1] = size[0];\n        size[0] = swap;\n      }//[y,x,z1,z2]\n      var cstride: number[];\n      if (size.length >= 2) {\n        // cstride: [z1*y*x, y*x, 1, y]\n        cstride = [1, size[0]];\n        var last_cstride = size[0];\n        for (var dim = 2; dim < ndims; dim++) {\n          last_cstride *= size[dim - 1];\n          cstride.unshift(last_cstride);\n        }\n      } else {\n        cstride = [1];\n      }\n\n      //flatten data\n      var data_ctor = Matrix.data_ctors[klass];\n      var data: AllowedTypedArray = new data_ctor(numel);\n      var flat_i = 0;\n\n      var n = function (a, dim, fidx_ofs) {\n        if (a.length != arysize[dim]) {\n          throw Error('Inconsistent size of n-d array');\n        }\n        if (dim == ndims - 1) {\n          // a contains numbers\n          for (var i = 0; i < arysize[dim]; i++) {\n            var val = a[i];\n            var fidx = fidx_ofs + i * cstride[dim];\n            data[fidx] = val;\n            flat_i++;\n          }\n\n        } else {\n          for (var i = 0; i < arysize[dim]; i++) {\n            n(a[i], dim + 1, fidx_ofs + i * cstride[dim]);\n          }\n        }\n      }\n\n      n(ary, 0, 0);\n      if (ndims == 1) {\n        if (one_d_column) {\n          size = [size[0], 1];\n        } else {\n          size = [1, size[0]];\n        }\n      }\n\n      mat = Matrix.typedarray2mat(size, klass, data);\n    }\n\n    return mat;\n  }\n\n  mat2jsa(one_d_flatten: boolean = false): any[] {\n    //empty matrix will be [] not [[]]\n    var ary = [];\n    if (one_d_flatten && this._ndims == 2 && (this._size[0] == 1 || this._size[1] == 1)) {\n      var data = this.getdataref();\n      for (var i = 0; i < data.length; i++) {\n        ary.push(data[i]);\n      }\n    } else {\n      //n-d jagged array\n      var size = this._size;\n      var ndims = this._ndims;\n      var data = this.getdataref();\n\n      //array[z2][z1][y][x]=mat(y,x,z1,z2)\n      var cstride: number[];\n      if (size.length >= 2) {\n        // cstride: [z1*y*x, y*x, 1, y]\n        cstride = [1, size[0]];\n        var last_cstride = size[0];\n        for (var dim = 2; dim < ndims; dim++) {\n          last_cstride *= size[dim - 1];\n          cstride.unshift(last_cstride);\n        }\n      } else {\n        cstride = [1];\n      }\n      var arysize: number[] = size.slice();\n      arysize.reverse();//[z2,z1,x,y]\n      var swap = arysize[arysize.length - 1];\n      arysize[arysize.length - 1] = arysize[arysize.length - 2];\n      arysize[arysize.length - 2] = swap;//[z2,z1,y,x]\n\n      var flat_i = 0;//c-order\n      var n = function (a, dim, fidx_ofs) {\n        if (dim == ndims - 1) {\n          for (var i = 0; i < arysize[dim]; i++) {\n            var fidx = fidx_ofs + i * cstride[dim];\n            a.push(data[fidx]);\n            flat_i++;\n          }\n        } else {\n          for (var i = 0; i < arysize[dim]; i++) {\n            var newa = [];\n            a.push(newa);\n            n(newa, dim + 1, fidx_ofs + i * cstride[dim]);\n          }\n        }\n      }\n\n      n(ary, 0, 0);\n    }\n    return ary;\n  }\n\n  get(): number;\n  get(...args: number[]): number;\n  get(...args: any[]): Matrix;\n  get(...args: any[]): any {\n    if (this._numel == 0) {\n      throw Error('Matrix with no element');\n    }\n    if (args.length == 0) {\n      // get scalar\n      return this._alloccpu()[0];\n    }\n    var all_number = args.every((v) => typeof (v) === 'number');\n    if (all_number) {\n      return this.get_scalar(args);\n    } else {\n      return this.get_matrix_nd(args);\n\n      // if (args.length > 1) {\n      //   return this.get_matrix_nd(args);\n      // } else {\n      //   if (args[0] instanceof Matrix && (<Matrix>args[0])._klass === 'logical') {\n      //     return this.get_matrix_logical(args[0]);\n      //   } else {\n      //     return this.get_matrix_single(args[0]);\n      //   }\n      // }\n    }\n  }\n\n  // returns value of (1,1) or 0\n  valueOf(): number {\n    if (this._numel > 0) {\n      return this.get();\n    } else {\n      return 0;\n    }\n  }\n\n  copy(klass?: string): Matrix {\n    var clone = new Matrix(this._size, klass || this._klass);\n    var clone_data = clone._getdata();\n    var rawdata = this._alloccpu();\n    if (Matrix._logical_cast_required(clone._klass, this._klass)) {\n      for (var i = 0, length = clone_data.length; i < length; i++) {\n        clone_data[i] = Matrix._logical_cast(rawdata[i]);\n      }\n    } else {\n      clone_data.set(rawdata);\n    }\n\n    return clone;\n  }\n\n  get_scalar(inds: number[]): number {\n    var rawdata = this._alloccpu();\n    this._isvalidindexerr(inds);\n    var arrayidx = this._getarrayindex(inds);\n    return rawdata[arrayidx];\n  }\n\n  private static _get_ind_iterator(ind: (number | Colon | Matrix), dim_size: number): { iter: (index: number) => number, length: number } {\n    // argument index is 0-origin\n    // return index within valid range\n    if (typeof (ind) === 'number') {\n      var ind_positive = <number>ind;\n      if (ind_positive < 0) {//end-xxx\n        ind_positive += dim_size + 1;\n      }\n      if (ind_positive <= 0 || ind_positive > dim_size) {\n        throw Error('Index exceeds matrix dimension');\n      }\n      return {\n        iter: function (index) {\n          return ind_positive;\n        }, length: 1\n      };\n    } else if (ind instanceof Colon) {\n      var start = ind.start;\n      var stop = ind.stop;\n      var step = ind.step;\n      if (ind.all) {\n        start = 1;\n        stop = dim_size;\n        step = 1;\n      }\n      if (start < 0) {\n        start += dim_size + 1;\n      }\n      if (stop < 0) {\n        stop += dim_size + 1;\n      }\n      var length: number = 0;\n      if ((step > 0 && stop >= start) || (step < 0 && stop <= start)) {\n        length = Math.floor((stop - start) / step) + 1;\n        // check if in valid range\n        var final_value = start + step * (length - 1);\n        if ((start <= 0 || start > dim_size) || (final_value <= 0 || final_value > dim_size)) {\n          throw Error('Index exceeds matrix dimension');\n        }\n      }\n      return {\n        iter: function (index) {\n          return start + step * index;\n        },\n        length: length\n      }\n    } else if (ind instanceof Matrix) {\n      var dataref = ind.getdataref();\n      // check if in valid range\n      for (var i = 0; i < dataref.length; i++) {\n        var element = dataref[i];\n        if (element == 0 || element > dim_size || element < -dim_size) {\n          throw Error('Index exceeds matrix dimension');\n        }\n      }\n\n      return {\n        iter: function (index) {\n          var val = dataref[index];\n          if (val < 0) {\n            val += dim_size;\n          }\n          return val;\n        },\n        length: dataref.length\n      }\n    }\n  }\n\n  get_matrix_nd(inds: (number | Colon | Matrix)[]): Matrix {\n    var inds_ndim = inds.length;\n    // replace logical matrix with vector\n    for (var i = 0; i < inds_ndim; i++) {\n      var ind = inds[i];\n      if (ind instanceof Matrix) {\n        if (ind._klass == 'logical') {\n          inds[i] = ind._find();\n        }\n      }\n    }\n\n    var virtual_input_shape: number[] = [];\n    if (this._ndims <= inds_ndim) {\n      // pad with 1\n      virtual_input_shape = this._size.concat();\n      while (virtual_input_shape.length < inds_ndim) {\n        virtual_input_shape.push(1);\n      }\n    } else {\n      // last dimension is like linear index\n      let cur_prod = 1;\n      for (let dim = 0; dim < inds_ndim - 1; dim++) {\n        virtual_input_shape.push(this._size[dim]);\n        cur_prod *= this._size[dim];\n      }\n      virtual_input_shape.push(this._numel / cur_prod);\n    }\n    var virtual_input_stride: number[] = [];\n    var stride_tmp = 1;\n    for (var dim = 0; dim < inds_ndim; dim++) {\n      virtual_input_stride.push(stride_tmp);\n      stride_tmp *= virtual_input_shape[dim];\n    }\n\n    var ind_iters = [];\n    var dst_shape = [];\n    var dst_stride = [];//not use dst._strides because tailing 1 dimension is omitted\n    var dst_stride_tmp = 1;\n    for (var dim = 0; dim < inds_ndim; dim++) {\n      var iter_and_length = Matrix._get_ind_iterator(inds[dim], virtual_input_shape[dim]);\n      ind_iters.push(iter_and_length.iter);\n      dst_shape.push(iter_and_length.length);\n      dst_stride.push(dst_stride_tmp);\n      dst_stride_tmp *= iter_and_length.length;\n    }\n\n    var dst_reshape_shape = null;\n    if (inds_ndim == 1) {\n      // linear indexing case\n      dst_shape.push(1);//avoid error on new Matrix()\n      // if ind is logical matrix, regarded as vector in the following\n      // colon is row vector\n      // src and ind are both vectors => follows direction of src\n      // otherwise: follows ind's shape\n      var is_ind_vector = false;\n      var only_ind = inds[0];\n      if (only_ind instanceof Matrix) {\n        if (only_ind._ndims == 2 && (only_ind._size[0] == 1 || only_ind._size[1] == 1)) {\n          is_ind_vector = true;\n        }\n      } else if (only_ind instanceof Colon) {\n        is_ind_vector = true;\n      }\n      var is_src_vector = false;\n      if (this._ndims == 2 && (this._size[0] == 1 || this._size[1] == 1)) {\n        is_src_vector = true;\n      }\n\n      if (is_src_vector && is_ind_vector) {\n        // follow direction of src\n        if (this._size[0] == 1) {\n          // reshape to row vector\n          dst_reshape_shape = [1, dst_shape[0]];\n        }\n      } else {\n        // follow ind's shape\n        if (only_ind instanceof Matrix) {\n          dst_reshape_shape = only_ind._size;\n        } else if (only_ind instanceof Colon) {\n          // reshape to row vector\n          dst_reshape_shape = [1, dst_shape[0]];\n        }\n      }\n    }\n    var dst = new Matrix(dst_shape, this._klass);\n    var dst_data = dst._data;\n    var src_data = this._data;\n    var dst_numel = dst._numel;\n    for (var dst_idx = 0; dst_idx < dst_numel; dst_idx++) {\n      var input_linear_idx = 0;\n      for (var dim = 0; dim < inds_ndim; dim++) {\n        var dst_coord = Math.floor(dst_idx / dst_stride[dim]) % dst_shape[dim];\n        var src_coord = ind_iters[dim](dst_coord) - 1;\n        input_linear_idx += src_coord * virtual_input_stride[dim];\n      }\n      dst_data[dst_idx] = src_data[input_linear_idx];\n    }\n\n    if (dst_reshape_shape) {\n      dst.reshape_inplace(dst_reshape_shape);\n    }\n\n    return dst;\n  }\n\n  get_matrix_nd_old(inds: (number | Colon | Matrix)[]): Matrix {\n    //multidim indexing\n    //convert index of each dimension into array\n    var eachdimidx: (number[] | AllowedTypedArray)[] = [];\n    var eachdimstride: number[] = [];\n    var output_size: number[] = [];\n    var output_length = 1;\n    var inputdimctr: number[] = [];\n    for (var dim = 0; dim < inds.length; dim++) {\n      var dimind = inds[dim];\n      var dimidx;\n      if (dimind instanceof Colon) {\n        dimidx = dimind.tojsa(this._size[dim] === void 0 ? 1 : this._size[dim]);\n      } else if (dimind instanceof Matrix) {\n        dimidx = dimind._getdata();\n      } else {\n        //number\n        dimidx = [<number>dimind];\n      }\n\n      //range check\n      var dimsize: number;\n      if (dim == inds.length - 1) {\n        // last index is regarded as linear index of remaining dimensions\n        dimsize = 1;\n        for (var dimex = dim; dimex < this._ndims; dimex++) {\n          dimsize *= this._size[dimex];\n        }\n      } else {\n        dimsize = this._size[dim] || 1;//exceed dimension must be [1,1,...]\n      }\n      for (var i = 0; i < dimidx.length; i++) {\n        var dimval = dimidx[i];\n        if (dimval < 0) {//$M.end-foo\n          dimval += dimsize + 1;\n          dimidx[i] = dimval;\n        }\n        if ((dimval > dimsize) || (dimval < 1)) {\n          throw new Error('Index exceeds matrix dimension');\n        }\n      }\n\n      eachdimidx.push(dimidx);\n      eachdimstride.push(this._strides[dim] || 0);\n      output_size.push(dimidx.length);\n      output_length *= dimidx.length;\n      inputdimctr.push(0);\n    }\n\n    var output = new Matrix(output_size, this._klass);\n    var output_data = output._data;\n    var input_data = this._data;\n    for (var i = 0; i < output_length; i++) {\n      //calc input index\n      var input_raw_idx = 0;\n      for (var dim = 0; dim < eachdimidx.length; dim++) {\n        input_raw_idx += (eachdimidx[dim][inputdimctr[dim]] - 1) * eachdimstride[dim];\n      }\n\n      output_data[i] = input_data[input_raw_idx];\n\n      //increment input index\n      for (var dim = 0; dim < inputdimctr.length; dim++) {\n        var element = ++inputdimctr[dim];\n        if (element >= eachdimidx[dim].length) {\n          //overflow to next dimension\n          inputdimctr[dim] = 0;\n        } else {\n          break;\n        }\n      }\n    }\n\n    return output;\n  }\n\n  get_matrix_single(singleind: Colon | Matrix): Matrix {\n    var single_idx_array: number[] | AllowedTypedArray;\n    var output_size: number[];\n    if (singleind instanceof Colon) {\n      single_idx_array = singleind.tojsa(this._numel);\n      output_size = [1, single_idx_array.length];//row vector\n    } else if (singleind instanceof Matrix) {\n      // returns matrix of same shape\n      // value in matrix is used as linear index\n      single_idx_array = singleind._data;\n      output_size = singleind._size;\n    }\n\n    var output = new Matrix(output_size, this._klass);\n    var output_data = output._data;\n    var input_data = this._data;\n    for (var i = 0, length = single_idx_array.length; i < length; i++) {\n      output_data[i] = input_data[single_idx_array[i] - 1];\n    }\n\n    return output;\n  }\n\n  get_matrix_logical(map: Matrix): Matrix {\n    // equivalent to this.get(find(map))\n    var output_length = 0;\n    var map_data = map._getdata();\n    var max_i = -1;\n    for (var i = 0, length = map_data.length; i < length; i++) {\n      if (map_data[i]) {\n        output_length++;\n        max_i = i;\n      }\n    }\n\n    if (this._numel <= max_i) {\n      throw new Error('Index out of bounds');\n    }\n\n    var output = new Matrix([output_length, 1], this._klass);\n    var output_data = output._data;\n    var input_data = this._data;\n    var ptr = 0;\n    for (var i = 0, length = map_data.length; i < length; i++) {\n      if (map_data[i]) {\n        output_data[ptr++] = input_data[i];\n      }\n    }\n\n    return output;\n  }\n\n  set(ind: number | Matrix | Colon, val: number | Matrix | any[]): void;\n  set(row: number | Matrix | Colon, col: number | Matrix | Colon, val: number | Matrix | any[]): void;\n  set(...args: any[]): void;\n  set(...args: any[]): void {\n    //last argument is value, but subsequent function requires first argument to be value\n    var val = args.pop();\n    if (!(val instanceof Matrix) && val.length !== void 0) {\n      // js array (or array-like)\n      val = Matrix.jsa2mat(val, false, this._klass);\n    }\n    // scalar matrix converted to number\n    if (val instanceof Matrix && val._numel == 1) {\n      val = (<Matrix>val).get_scalar([1]);\n    }\n\n    var all_number = args.every((v) => typeof (v) === 'number');\n    if (all_number) {\n      this.set_scalar(val, args);\n    } else {\n      this.set_matrix_nd(val, args);\n      // if (args.length > 1) {\n      //   this.set_matrix_nd(val, args);\n      // } else {\n      //   if (args[0] instanceof Matrix && (<Matrix>args[0])._klass === 'logical') {\n      //     this.set_matrix_logical(val, args[0]);\n      //   } else {\n      //     this.set_matrix_single(val, args[0]);\n      //   }\n      // }\n    }\n  }\n\n  set_scalar(val: number | Matrix, inds: number[]): void {\n    var rawdata = this._alloccpu();\n    this._isvalidindexerr(inds);\n    var arrayidx = this._getarrayindex(inds);\n    var scalar_val: number;\n    if (val instanceof Matrix) {\n      if (val._numel != 1) {\n        throw new Error('Value is not scalar');\n      }\n      scalar_val = val._getdata()[0];\n    } else {\n      scalar_val = <number>val;\n    }\n\n    if (Matrix._logical_cast_required(this._klass)) {\n      scalar_val = Matrix._logical_cast(scalar_val);\n    }\n    rawdata[arrayidx] = scalar_val;\n  }\n\n  set_matrix_single(val: number | Matrix, singleind: Colon | Matrix): void {\n    var single_idx_array: number[] | AllowedTypedArray;\n    var output_size: number[];\n    if (singleind instanceof Colon) {\n      single_idx_array = singleind.tojsa(this._numel);\n    } else if (singleind instanceof Matrix) {\n      // value in matrix is used as linear index\n      // used as flattened value array, regardless of shape\n      single_idx_array = singleind.getdataref();\n    }\n\n    var rawdata = this._alloccpu();\n\n    if (val instanceof Matrix) {\n      if (single_idx_array.length != val._numel) {\n        throw new Error('Dimension mismatch');\n      }\n      var val_data = val._getdata();\n      // read over flattened val\n      if (Matrix._logical_cast_required(this._klass, val._klass)) {\n        rawdata[single_idx_array[i] - 1] = Matrix._logical_cast(val_data[i]);\n      } else {\n        for (var i = 0, length = single_idx_array.length; i < length; i++) {\n          rawdata[single_idx_array[i] - 1] = val_data[i];\n        }\n      }\n    } else {\n      var scalar_val;\n      if (Matrix._logical_cast_required(this._klass)) {\n        scalar_val = Matrix._logical_cast(<number>val);\n      } else {\n        scalar_val = <number>val;\n      }\n      for (var i = 0, length = single_idx_array.length; i < length; i++) {\n        rawdata[single_idx_array[i] - 1] = scalar_val;\n      }\n    }\n  }\n\n\n  set_matrix_nd(val: number | Matrix, inds: (number | Colon | Matrix)[]): void {\n    var inds_ndim = inds.length;\n    // replace logical matrix with vector\n    for (var i = 0; i < inds_ndim; i++) {\n      var ind = inds[i];\n      if (ind instanceof Matrix) {\n        if (ind._klass == 'logical') {\n          inds[i] = ind._find();\n        }\n      }\n    }\n\n    var virtual_input_shape: number[] = [];\n    if (this._ndims <= inds_ndim) {\n      // pad with 1\n      virtual_input_shape = this._size.concat();\n      while (virtual_input_shape.length < inds_ndim) {\n        virtual_input_shape.push(1);\n      }\n    } else {\n      // last dimension is like linear index\n      let cur_prod = 1;\n      for (let dim = 0; dim < inds_ndim - 1; dim++) {\n        virtual_input_shape.push(this._size[dim]);\n        cur_prod *= this._size[dim];\n      }\n      virtual_input_shape.push(this._numel / cur_prod);\n    }\n    var virtual_input_stride: number[] = [];\n    var stride_tmp = 1;\n    for (var dim = 0; dim < inds_ndim; dim++) {\n      virtual_input_stride.push(stride_tmp);\n      stride_tmp *= virtual_input_shape[dim];\n    }\n\n    var ind_iters = [];\n    var dst_shape: number[] = [];\n    var dst_stride = [];//not use dst._strides because tailing 1 dimension is omitted\n    var dst_stride_tmp = 1;\n    for (var dim = 0; dim < inds_ndim; dim++) {\n      var iter_and_length = Matrix._get_ind_iterator(inds[dim], virtual_input_shape[dim]);\n      ind_iters.push(iter_and_length.iter);\n      dst_shape.push(iter_and_length.length);\n      dst_stride.push(dst_stride_tmp);\n      dst_stride_tmp *= iter_and_length.length;\n    }\n    var dst_numel = dst_stride_tmp;\n\n    var scalar_val: number = null;\n    if (typeof (val) === 'number') {\n      scalar_val = <number>val;\n    } else if (val instanceof Matrix) {\n      if (val._numel === 1) {\n        scalar_val = val.valueOf();\n      }\n    }\n\n    if (scalar_val == null) {\n      // set matrix\n      // shape check; dimensions excluding value 1 must match\n      var dst_shape_exclude_one = dst_shape.filter((v) => v != 1);\n      var val_shape_exclude_one = (<Matrix>val)._size.filter((v) => v != 1);\n      if (dst_shape_exclude_one.length != val_shape_exclude_one.length) {\n        throw Error('Shape mismatch');\n      }\n      if (!dst_shape_exclude_one.every((v, i) => v == val_shape_exclude_one[i])) {\n        throw Error('Shape mismatch');\n      }\n\n      var dst_data = (<Matrix>val).getdataref();\n      var src_data = this._data;\n      for (var dst_idx = 0; dst_idx < dst_numel; dst_idx++) {\n        var input_linear_idx = 0;\n        for (var dim = 0; dim < inds_ndim; dim++) {\n          var dst_coord = Math.floor(dst_idx / dst_stride[dim]) % dst_shape[dim];\n          var src_coord = ind_iters[dim](dst_coord) - 1;\n          input_linear_idx += src_coord * virtual_input_stride[dim];\n        }\n        src_data[input_linear_idx] = dst_data[dst_idx];\n      }\n\n    } else {\n      // set scalar\n      var src_data = this._data;\n      for (var dst_idx = 0; dst_idx < dst_numel; dst_idx++) {\n        var input_linear_idx = 0;\n        for (var dim = 0; dim < inds_ndim; dim++) {\n          var dst_coord = Math.floor(dst_idx / dst_stride[dim]) % dst_shape[dim];\n          var src_coord = ind_iters[dim](dst_coord) - 1;\n          input_linear_idx += src_coord * virtual_input_stride[dim];\n        }\n        src_data[input_linear_idx] = scalar_val;\n      }\n    }\n\n  }\n\n  set_matrix_nd_old(val: number | Matrix, inds: (number | Colon | Matrix)[]): void {\n    //multidim indexing\n    //convert index of each dimension into array\n    var eachdimidx: (number[] | AllowedTypedArray)[] = [];\n    var eachdimstride: number[] = [];\n    var output_size: number[] = [];\n    var output_length = 1;\n    var inputdimctr: number[] = [];\n    for (var dim = 0; dim < inds.length; dim++) {\n      var dimind = inds[dim];\n      var dimidx;\n      if (dimind instanceof Colon) {\n        dimidx = dimind.tojsa(this._size[dim] || 1);\n      } else if (dimind instanceof Matrix) {\n        dimidx = dimind._getdata();\n      } else {\n        //number\n        dimidx = [<number>dimind];\n      }\n\n      //range check\n      var dim_size = this._size[dim] || 1;//exceed dimension must be [1,1,...]\n      for (var i = 0; i < dimidx.length; i++) {\n        if ((dimidx[i] > dim_size) || (dimidx[i] < 1)) {\n          throw new Error('Index exceeds matrix dimension');\n        }\n      }\n\n      eachdimidx.push(dimidx);\n      eachdimstride.push(this._strides[dim] || 0);\n      output_size.push(dimidx.length);\n      output_length *= dimidx.length;\n      inputdimctr.push(0);\n    }\n\n\n    var rawdata = this._alloccpu();\n    if (val instanceof Matrix) {\n      //val shape check\n      var is_vector = output_size.filter((v) => v != 1).length <= 1;\n      if (is_vector) {\n        // if shape is vector, only numel have to match\n        if (val._numel != output_length) {\n          throw new Error('Dimensions mismatch');\n        }\n      } else {\n        // shape must match (exclude tailing 1)\n        for (var dim = 0; dim < Math.max(val._size.length, output_size.length); dim++) {\n          if ((val._size[dim] || 1) != (output_size[dim] || 1)) {\n            throw new Error('Dimensions mismatch');\n          }\n        }\n      }\n\n      var val_data = val._getdata();\n      if (Matrix._logical_cast_required(this._klass, val._klass)) {\n        for (var i = 0; i < output_length; i++) {\n          //calc input index\n          var input_raw_idx = 0;\n          for (var dim = 0; dim < eachdimidx.length; dim++) {\n            input_raw_idx += (eachdimidx[dim][inputdimctr[dim]] - 1) * eachdimstride[dim];\n          }\n\n          rawdata[input_raw_idx] = Matrix._logical_cast(val_data[i]);\n\n          //increment input index\n          for (var dim = 0; dim < inputdimctr.length; dim++) {\n            var element = ++inputdimctr[dim];\n            if (element >= eachdimidx[dim].length) {\n              //overflow to next dimension\n              inputdimctr[dim] = 0;\n            } else {\n              break;\n            }\n          }\n        }\n\n      } else {\n        for (var i = 0; i < output_length; i++) {\n          //calc input index\n          var input_raw_idx = 0;\n          for (var dim = 0; dim < eachdimidx.length; dim++) {\n            input_raw_idx += (eachdimidx[dim][inputdimctr[dim]] - 1) * eachdimstride[dim];\n          }\n\n          rawdata[input_raw_idx] = val_data[i];\n\n          //increment input index\n          for (var dim = 0; dim < inputdimctr.length; dim++) {\n            var element = ++inputdimctr[dim];\n            if (element >= eachdimidx[dim].length) {\n              //overflow to next dimension\n              inputdimctr[dim] = 0;\n            } else {\n              break;\n            }\n          }\n        }\n\n      }\n\n    } else {\n      //val is scalar\n      var scalar_val;\n      if (Matrix._logical_cast_required(this._klass)) {\n        scalar_val = Matrix._logical_cast(<number>val);\n      } else {\n        scalar_val = <number>val;\n      }\n\n      for (var i = 0; i < output_length; i++) {\n        //calc input index\n        var input_raw_idx = 0;\n        for (var dim = 0; dim < eachdimidx.length; dim++) {\n          input_raw_idx += (eachdimidx[dim][inputdimctr[dim]] - 1) * eachdimstride[dim];\n        }\n\n        rawdata[input_raw_idx] = scalar_val;\n\n        //increment input index\n        for (var dim = 0; dim < inputdimctr.length; dim++) {\n          var element = ++inputdimctr[dim];\n          if (element >= eachdimidx[dim].length) {\n            //overflow to next dimension\n            inputdimctr[dim] = 0;\n          } else {\n            break;\n          }\n        }\n      }\n\n    }\n\n  }\n\n  set_matrix_logical(val: number | Matrix, map: Matrix): void {\n    // equivalent to this.set(val, find(map))\n    var output_length = 0;\n    var map_data = map._getdata();\n    var max_i = -1;\n    for (var i = 0, length = map_data.length; i < length; i++) {\n      if (map_data[i]) {\n        output_length++;\n        max_i = i;\n      }\n    }\n\n    if (this._numel < max_i) {\n      throw new Error('Index out of bounds');\n    }\n\n    var rawdata = this._alloccpu();\n    if (val instanceof Matrix) {\n      var val_data = val._getdata();\n      var ptr = 0;\n      if (Matrix._logical_cast_required(this._klass, val._klass)) {\n        for (var i = 0, length = map_data.length; i < length; i++) {\n          if (map_data[i]) {\n            rawdata[i] = Matrix._logical_cast(val_data[ptr++]);\n          }\n        }\n\n      } else {\n        for (var i = 0, length = map_data.length; i < length; i++) {\n          if (map_data[i]) {\n            rawdata[i] = val_data[ptr++];\n          }\n        }\n      }\n    } else {\n      var ptr = 0;\n      var scalar_val;\n      if (Matrix._logical_cast_required(this._klass)) {\n        scalar_val = Matrix._logical_cast(val);\n      } else {\n        scalar_val = <number>val;\n      }\n      for (var i = 0, length = map_data.length; i < length; i++) {\n        if (map_data[i]) {\n          rawdata[i] = scalar_val;\n        }\n      }\n    }\n\n  }\n\n  toString(): string {\n    var s = '';\n    var rows = this._size[0], cols = this._size[1];\n    var rawdata = this.getdataref();\n    for (var row = 0; row < rows; row++) {\n      for (var col = 0; col < cols; col++) {\n        s += rawdata[col * rows + row] + '\\t';\n      }\n      s += '\\n';\n    }\n    return s;\n  }\n\n  disp(X?: any): void {\n    var s = '';\n    if (this !== void 0) {\n      s = this.toString();\n    } else {\n      s = X.toString();\n    }\n    console.log(s);\n  }\n\n  reshape_inplace(sz: Matrix);\n  reshape_inplace(sz: number[]);\n  reshape_inplace(...sz: number[]);\n  reshape_inplace(...args: any[]): void {\n    var _size: number[];\n    var first_arg = args[0];\n    //convert to Array\n    if (first_arg instanceof Matrix) {\n      var tarray = first_arg._getdata();\n      _size = Array.prototype.slice.call(tarray);\n    } else if (first_arg.length !== void 0) {\n      _size = Array.prototype.slice.call(first_arg);\n    } else {\n      _size = Array.prototype.slice.call(args);\n    }\n\n    //type check\n    var tmpnumel: number = 1;\n    var strides: number[] = [];\n    var last_none_one_dim = 0;\n    if (_size.length < 2) {\n      throw new Error('matrix must have at least 2 dimensions');\n    }\n    //substitute -1 to remaining value\n    var minus_pos = -1;\n    var remaining_prod = 1;\n    for (var i = 0; i < _size.length; i++) {\n      if (_size[i] < 0) {\n        if (minus_pos >= 0) {\n          throw new Error('Only one free size is accepted');\n        }\n        minus_pos = i;\n      } else {\n        remaining_prod *= _size[i];\n      }\n    }\n    if (minus_pos >= 0) {\n      _size[minus_pos] = this._numel / remaining_prod;\n    }\n\n    for (var i = 0; i < _size.length; i++) {\n      var dimsize = _size[i];\n      if (typeof (dimsize) !== 'number' || dimsize < 0 || !Matrix._isinteger(dimsize)) {\n        throw new Error('size is invalid');\n      }\n      if (dimsize != 1) {\n        last_none_one_dim = i;\n      }\n      strides.push(tmpnumel);\n      tmpnumel *= dimsize;\n    }\n\n    if (tmpnumel !== this._numel) {\n      throw new Error('New shape must have same elements');\n    }\n\n    //remove tail dimensions with size 1 (retain minimum 2 dimensions)\n    last_none_one_dim = Math.max(last_none_one_dim, 1) + 1;\n    _size.splice(last_none_one_dim);\n    strides.splice(last_none_one_dim);\n\n    this._size = _size;\n    this._numel = tmpnumel;\n    this._ndims = _size.length;\n    this._strides = strides;\n  }\n\n  squeeze_inplace(): void {\n    if (this._ndims == 2) {\n      // keep [1,5] remained\n      return;\n    }\n    var new_size = this._size.filter((v) => v !== 1);\n    //append 1 to tail\n    while (new_size.length < 2) {\n      new_size.push(1);\n    }\n    var tmpnumel = 1;\n    var strides: number[] = [];\n    for (var dim = 0; dim < new_size.length; dim++) {\n      var dimsize = new_size[dim];\n      strides.push(tmpnumel);\n      tmpnumel *= dimsize;\n    }\n\n    this._size = new_size;\n    this._ndims = new_size.length;\n    this._strides = strides;\n  }\n\n  _find(): Matrix {\n    // returns nonzero-element indices\n    // if this is vector, direction (row/col) is kept.\n    // otherwise, column vector is returned.\n    var output_length = 0;\n    var src_data = this.getdataref();\n    for (var i = 0; i < src_data.length; i++) {\n      if (src_data[i]) {\n        output_length++;\n      }\n    }\n\n    var dst = new Matrix([output_length, 1], 'int32');\n    var dst_idx = 0;\n    var dst_data = dst._data;\n    for (var i = 0; dst_idx < output_length; i++) {\n      if (src_data[i]) {\n        dst_data[dst_idx++] = i + 1;\n      }\n    }\n    if (this._size[1] == this._numel) {\n      // row vector\n      dst.reshape_inplace(this._size);\n    }\n\n    return dst;\n  }\n}\n\nexport = Matrix;\n", "// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\nimport Colon = require('./colon');\n\nfunction colon(start?: number, stop_step?: number, stop?: number): Colon {\n  return new Colon(start, stop_step, stop);\n}\n\nnamespace colon {\n  export var s = Colon.fromstring;\n}\n\nexport = colon;\n", "// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\nimport Matrix = require('./matrix');\nexport type MatrixOrNumber = Matrix | number;\n\n\n/**\n * Convert array-like to Matrix, number to 1x1 Matrix\n */\nexport function as_mat(A: Matrix | any): Matrix {\n  if (A instanceof Matrix) {\n    return A;\n  } else {\n    //array to matrix\n    //number to 1x1 matrix\n    return Matrix.jsa2mat(<any>A);\n  }\n}\n\n/**\n * Convert array-like to Matrix, preserving other type\n */\nexport function as_mat_or_scalar(A: Matrix | any): Matrix | number {\n  if (A instanceof Matrix) {\n    return A;\n  } else if (typeof(A) === 'object' && A.length != null) {\n    //array-like to Matrix\n    return Matrix.jsa2mat(<any>A);\n  } else {\n    return A;//preserve number\n  }\n}\n\n//finds common output class for matrices\nexport function commonklassstr(...klasses: string[]): string {\n  // single > int32 > uint8 > logical\n  var klass_order = ['single','int32','uint8','logical'];\n  if (klasses.length == 0) {\n    return klass_order[0];\n  }\n  var best_klass = 3;\n  for (var i = 0; i < klasses.length; i++) {\n    var element = klasses[i];\n    var score = klass_order.indexOf(element);\n    if (score < 0) {\n      throw new Error('Unknown klass');\n    }\n    best_klass = Math.min(score, best_klass);\n  }\n  \n  return klass_order[best_klass];\n}\n\nexport function commonklass(...mats: MatrixOrNumber[]): string {\n  //number not affects class decision\n  var klasses: string[] = [];\n  for (var i = 0; i < mats.length; i++) {\n    var element = mats[i];\n    if (element instanceof Matrix) {\n      klasses.push(element._klass);\n    }\n  }\n  \n  return commonklassstr(...klasses);\n}\n\nexport function issamesize(sizea: number[], sizeb: number[]): boolean {\n  for (var i = 0; i < sizea.length; i++) {\n    if (sizea[i] != sizeb[i]) {\n      return false;\n    }\n  }\n  \n  return true;\n}\n\nexport function force_cpu(A: MatrixOrNumber): MatrixOrNumber {\n  if (A instanceof Matrix) {\n    return A.to_cpu();\n  } else {\n    return A;\n  }\n}\n\nexport function force_cpu_scalar(A: MatrixOrNumber): MatrixOrNumber {\n  if (A instanceof Matrix) {\n    if (A._numel == 1) {\n      return A.get();\n    } else {\n      return A.to_cpu();\n    }\n  } else {\n    return A;\n  }\n}\n\nexport function jsaequal(a: any[], b: any[]): boolean {\n  if (a.length != b.length) {\n    return false;\n  }\n\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] != b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function calc_zeros_size(args: any[]): {size: number[], klass:string} {\n  var size: number[];\n  var klass = 'single';\n  if (args.length >= 1 && typeof (args[args.length - 1]) === 'string') {\n    //zeros(_,typename)\n    klass = args[args.length - 1];\n    args.pop();\n  } else if (args.length >= 2 && args[args.length - 2] == 'like') {\n    //zeros('like', mat)\n    klass = args[args.length - 1]._klass;\n    args.pop();\n    args.pop();\n  }\n  if (args.length == 0) {\n    // return 1x1 matrix\n    size = [1,1];\n  } else {\n    if (args.length == 1) {\n      if (typeof (args[0]) === 'number') {\n        // nxn matrix\n        size = [args[0], args[0]];\n      } else if (args[0] instanceof Matrix) {\n        // size given as matrix\n        var sizemat: Matrix = args[0];\n        if (sizemat._size.length == 2 && sizemat._size[0] == 1 && sizemat._size[1] >= 1) {\n          size = Array.prototype.slice.call(sizemat._getdata());\n        } else {\n          throw new Error('matrix size is not valid row vector');\n        }\n      } else {\n        throw new Error('Unknown data type of argument 0');\n      }\n    } else {\n      size = args;\n    }\n  }\n  \n  return {size:size, klass:klass};\n}\n", "// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\r\nimport Matrix = require('./matrix');\r\nimport util = require('./util');\r\n\r\nexport type MatrixOrNumber = util.MatrixOrNumber;\r\nexport function make_compare_func_all(operation: string): (A: MatrixOrNumber, B: MatrixOrNumber) => Matrix {\r\n  var func_s_s = make_binary_arith_func(operation, false, false, 'logical');\r\n  var func_s_m = make_binary_arith_func(operation, false, true, 'logical');\r\n  var func_m_s = make_binary_arith_func(operation, true, false, 'logical');\r\n  var func_m_m = make_binary_arith_func(operation, true, true, 'logical');\r\n  return function(A: MatrixOrNumber, B: MatrixOrNumber) {\r\n    A = util.force_cpu_scalar(A);\r\n    B = util.force_cpu_scalar(B);\r\n    if (A instanceof Matrix) {\r\n      if (B instanceof Matrix) {\r\n        return func_m_m(A, B);\r\n      } else {\r\n        return func_m_s(A, B);\r\n      }\r\n    } else {\r\n      if (B instanceof Matrix) {\r\n        return func_s_m(A, B);\r\n      } else {\r\n        return func_s_s(A, B);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function make_binary_arith_func(operation: string, a_mat: boolean, b_mat: boolean, dst_klass: string): (A: MatrixOrNumber, B: MatrixOrNumber) => Matrix {\r\n  var l_shape;\r\n  var l_size_check = '';\r\n  var l_def_adata = '';\r\n  var l_def_bdata = '';\r\n  var l_get_a;\r\n  var l_get_b;\r\n  if (a_mat) {\r\n    l_shape = 'A._size';\r\n    l_def_adata = 'var a_data = A._data;';\r\n    l_get_a = 'a_data[i]';\r\n    if (b_mat) {\r\n      l_size_check = 'if (!e_util.jsaequal(A._size, B._size)) {throw new Error(\"Dimension mismatch\");}';\r\n    }\r\n  } else {\r\n    l_get_a = 'A';\r\n    if (b_mat) {\r\n      l_shape = 'B._size';\r\n    } else {\r\n      l_shape = '[1,1]';\r\n    }\r\n  }\r\n\r\n  if (b_mat) {\r\n    l_def_bdata = 'var b_data = B._data;';\r\n    l_get_b = 'b_data[i]';\r\n  } else {\r\n    l_get_b = 'B';\r\n  }\r\n\r\n  var l_opr_formatted = operation.replace('%a', l_get_a).replace('%b', l_get_b);\r\n\r\n  var f: any;\r\n  var e_Matrix = Matrix;\r\n  var e_util = util;\r\n\r\n  eval([\r\n    'f = function(A, B) {',\r\n    'var shape = ' + l_shape + ';',\r\n    l_size_check,\r\n    l_def_adata,\r\n    l_def_bdata,\r\n    'var dst = new e_Matrix(shape, \"' + dst_klass + '\");',\r\n    'var dst_data = dst._data;',\r\n    'for (var i = 0, length = dst._numel; i < length; i++) {',\r\n    '  dst_data[i] = ' + l_opr_formatted + ';',\r\n    '}',\r\n    'return dst;',\r\n    '}'\r\n  ].join('\\n'));\r\n  return f;\r\n}\r\n\r\nexport function make_binary_arith_func_all(operation: string): (A: MatrixOrNumber, B: MatrixOrNumber) => Matrix {\r\n  var funcs = {};\r\n  return function(A: MatrixOrNumber, B: MatrixOrNumber) {\r\n    var dst_klass = util.commonklass(A, B);\r\n    A = util.force_cpu_scalar(A);\r\n    B = util.force_cpu_scalar(B);\r\n    if (dst_klass == 'logical') {\r\n      dst_klass = 'single';\r\n    }\r\n    var a_mat = A instanceof Matrix;\r\n    var b_mat = B instanceof Matrix;\r\n    var func_name = '' + a_mat + '_' + b_mat + '_' + dst_klass;\r\n    var f = funcs[func_name];\r\n    if (!f) {\r\n      // compile (eval) function on first call\r\n      f = make_binary_arith_func(operation, a_mat, b_mat, dst_klass);\r\n      funcs[func_name] = f;\r\n    }\r\n\r\n    return f(A, B);\r\n  }\r\n}\r\n\r\nexport function make_unary_arith_func(operation: string, a_mat: boolean, dst_klass: string): (A: MatrixOrNumber) => Matrix {\r\n  var l_shape: string;\r\n  var l_def_adata = '';\r\n  var l_get_a;\r\n  if (a_mat) {\r\n    l_shape = 'A._size';\r\n    l_def_adata = 'var a_data = A._data;';\r\n    l_get_a = 'a_data[i]';\r\n  } else {\r\n    l_shape = '[1,1]';\r\n    l_get_a = 'A';\r\n  }\r\n\r\n  var l_opr_formatted = operation.replace(/%a/g, l_get_a);\r\n\r\n  var f: any;\r\n  var e_Matrix = Matrix;\r\n  var e_util = util;\r\n\r\n  eval([\r\n    'f = function(A) {',\r\n    'var shape = ' + l_shape + ';',\r\n    l_def_adata,\r\n    'var dst = new e_Matrix(shape, \"' + dst_klass + '\");',\r\n    'var dst_data = dst._data;',\r\n    'for (var i = 0, length = dst._numel; i < length; i++) {',\r\n    '  dst_data[i] = ' + l_opr_formatted + ';',\r\n    '}',\r\n    'return dst;',\r\n    '}'\r\n  ].join('\\n'));\r\n  return f;\r\n}\r\n\r\nexport function make_unary_arith_func_all(operation: string): (A: MatrixOrNumber) => Matrix {\r\n  var funcs = {};\r\n  return function(A: MatrixOrNumber) {\r\n    var dst_klass;\r\n    if (A instanceof Matrix) {\r\n      dst_klass = A._klass;\r\n      if (dst_klass == 'logical') {\r\n        dst_klass = 'single';\r\n      }\r\n    } else {\r\n      dst_klass = 'single';\r\n    }\r\n    A = util.force_cpu_scalar(A);\r\n    var a_mat = A instanceof Matrix;\r\n    var func_name = '' + a_mat + '_' + dst_klass;\r\n    var f = funcs[func_name];\r\n    if (!f) {\r\n      // compile (eval) function on first call\r\n      f = make_unary_arith_func(operation, a_mat, dst_klass);\r\n      funcs[func_name] = f;\r\n    }\r\n\r\n    return f(A);\r\n  }\r\n}\r\n\r\nfunction isequal_two(A: Matrix, B: Matrix): boolean {\r\n  A = A.to_cpu();\r\n  B = B.to_cpu();\r\n  if (!util.issamesize(A._size, B._size)) {\r\n    return false;\r\n  }\r\n\r\n  //(1,1)=>true,(NaN,NaN)=>false,(NaN,1)=>false\r\n  var a_data = A._data;\r\n  var b_data = B._data;\r\n  for (var i = 0, length = a_data.length; i < length; i++) {\r\n    if (a_data[i] !== b_data[i]) {//both are value or include NaN\r\n      // NaN !== NaN\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isequal(...As: Matrix[]): boolean {\r\n  if (!(As[0] instanceof Matrix)) { return false; }//scalar is not allowed\r\n  for (var i = 1; i < As.length; i++) {\r\n    if (!(As[i] instanceof Matrix)) { return false; }\r\n    if (!isequal_two(As[0], As[i])) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction isequaln_two(A: Matrix, B: Matrix): boolean {\r\n  A = A.to_cpu();\r\n  B = B.to_cpu();\r\n  if (!util.issamesize(A._size, B._size)) {\r\n    return false;\r\n  }\r\n\r\n  //(1,1)=>true,(NaN,NaN)=>true,(NaN,1)=>false\r\n  var a_data = A._data;\r\n  var b_data = B._data;\r\n  for (var i = 0, length = a_data.length; i < length; i++) {\r\n    var val_a = a_data[i], val_b = b_data[i];\r\n    if (val_a !== val_b) {\r\n      // NaN !== NaN\r\n      if ((val_a === val_a) || (val_b === val_b)) {//false if both are NaN\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function isequaln(...As: Matrix[]): boolean {\r\n  if (!(As[0] instanceof Matrix)) { return false; }//scalar is not allowed\r\n  for (var i = 1; i < As.length; i++) {\r\n    if (!(As[i] instanceof Matrix)) { return false; }\r\n    if (!isequaln_two(As[0], As[i])) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n\r\nfunction make_isclose_func_all(): (A: MatrixOrNumber, B: MatrixOrNumber, rtol?: number, atol?: number, equal_nan?: boolean) => Matrix {\r\n  var func_s_s = make_isclose_func(false, false);\r\n  var func_s_m = make_isclose_func(false, true);\r\n  var func_m_s = make_isclose_func(true, false);\r\n  var func_m_m = make_isclose_func(true, true);\r\n  return function(A: MatrixOrNumber, B: MatrixOrNumber, rtol: number = 1e-5, atol: number = 1e-8, equal_nan: boolean = false) {\r\n    A = util.force_cpu_scalar(A);\r\n    B = util.force_cpu_scalar(B);\r\n    if (A instanceof Matrix) {\r\n      if (B instanceof Matrix) {\r\n        return func_m_m(A, B, rtol, atol, equal_nan);\r\n      } else {\r\n        return func_m_s(A, B, rtol, atol, equal_nan);\r\n      }\r\n    } else {\r\n      if (B instanceof Matrix) {\r\n        return func_s_m(A, B, rtol, atol, equal_nan);\r\n      } else {\r\n        return func_s_s(A, B, rtol, atol, equal_nan);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function make_isclose_func(a_mat: boolean, b_mat: boolean): (A: MatrixOrNumber, B: MatrixOrNumber, rtol?: number, atol?: number, equal_nan?: boolean) => Matrix {\r\n  var l_shape;\r\n  var l_size_check = '';\r\n  var l_def_adata = '';\r\n  var l_def_bdata = '';\r\n  var l_get_a;\r\n  var l_get_b;\r\n  if (a_mat) {\r\n    l_shape = 'A._size';\r\n    l_def_adata = 'var a_data = A._data;';\r\n    l_get_a = 'a_data[i]';\r\n    if (b_mat) {\r\n      l_size_check = 'if (!e_util.jsaequal(A._size, B._size)) {throw new Error(\"Dimension mismatch\");}';\r\n    }\r\n  } else {\r\n    l_get_a = 'A';\r\n    if (b_mat) {\r\n      l_shape = 'B._size';\r\n    } else {\r\n      l_shape = '[1,1]';\r\n    }\r\n  }\r\n\r\n  if (b_mat) {\r\n    l_def_bdata = 'var b_data = B._data;';\r\n    l_get_b = 'b_data[i]';\r\n  } else {\r\n    l_get_b = 'B';\r\n  }\r\n\r\n  var f: any;\r\n  var e_Matrix = Matrix;\r\n  var e_util = util;\r\n\r\n  eval([\r\n    'f = function(A, B, rtol, atol, equal_nan) {',\r\n    'var shape = ' + l_shape + ';',\r\n    l_size_check,\r\n    l_def_adata,\r\n    l_def_bdata,\r\n    'var dst = new e_Matrix(shape, \"logical\");',\r\n    'var dst_data = dst._data;',\r\n    'if (equal_nan) {',\r\n    '  for (var i = 0, length = dst._numel; i < length; i++) {',\r\n    '    var val_a = ' + l_get_a + ';',\r\n    '    var val_b = ' + l_get_b + ';',\r\n    '    var absdiff = val_a - val_b;',\r\n    '    if (absdiff < 0) {absdiff = -absdiff}',\r\n    '    var ret = 0;',\r\n    '    if (absdiff <= atol + rtol * ((val_b > 0) ? val_b : -val_b)) {',\r\n    '      ret = 1;',\r\n    '    }',\r\n    '    if ((val_a !== val_a) && (val_b !== val_b)) {',\r\n    '      ret = 1;',\r\n    '    }',\r\n    '    dst_data[i] = ret;',\r\n    '  }',\r\n    '} else {',\r\n    '  for (var i = 0, length = dst._numel; i < length; i++) {',\r\n    '    var val_a = ' + l_get_a + ';',\r\n    '    var val_b = ' + l_get_b + ';',\r\n    '    var absdiff = val_a - val_b;',\r\n    '    if (absdiff < 0) {absdiff = -absdiff}',\r\n    '    var ret = 0;',\r\n    '    if (absdiff <= atol + rtol * ((val_b > 0) ? val_b : -val_b)) {',\r\n    '      ret = 1;',\r\n    '    }',\r\n    '    dst_data[i] = ret;',\r\n    '  }',\r\n    '}',\r\n    'return dst;',\r\n    '}'\r\n  ].join('\\n'));\r\n  return f;\r\n}\r\n\r\nexport var isclose = make_isclose_func_all();\r\n\r\nexport function allclose(A: MatrixOrNumber, B: MatrixOrNumber, rtol?: number, atol?: number, equal_nan?: boolean): boolean {\r\n  var isclose_result = isclose(A, B, rtol, atol, equal_nan);\r\n  var data = isclose_result.getdataref();\r\n  var prod = 1;\r\n  for (var i = 0; i < data.length; i++) {\r\n    prod *= data[i];\r\n  }\r\n\r\n  return prod != 0;\r\n}\r\n", "// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\nimport Matrix = require('./matrix');\nimport util = require('./util');\nimport colon = require('./colonwrap');\n\nexport function transpose(A: Matrix): Matrix {\n  if (A._ndims != 2) {\n    throw new Error('Matrix must be two-dimensional');\n  }\n  A = A.to_cpu();\n\n  var [dst_cols, dst_rows] = A._size;\n  var dst = new Matrix([dst_rows, dst_cols], A._klass);\n\n  var a_data = A._data;\n  var dst_data = dst._data;\n  var i = 0;\n  for (var dst_col = 0; dst_col < dst_cols; dst_col++) {\n    for (var dst_row = 0; dst_row < dst_rows; dst_row++) {\n      dst_data[i] = a_data[dst_row * dst_cols + dst_col];\n      i++;\n    }\n\n  }\n\n  return dst;\n}\n\nexport function repmat(A: Matrix, ...rs: number[]): Matrix;\nexport function repmat(A: Matrix, rs: number[]): Matrix;\nexport function repmat(A: Matrix, r: Matrix): Matrix;\nexport function repmat(A: Matrix, ...args: any[]): Matrix {\n  A = A.to_cpu();\n  //convert to Array\n  var _rs: number[];//number of repetion for each dim\n  var first_arg = args[0];\n  if (first_arg instanceof Matrix) {\n    var tarray = first_arg._getdata();\n    _rs = Array.prototype.slice.call(tarray);\n  } else if (first_arg.length !== void 0) {\n    _rs = Array.prototype.slice.call(first_arg);\n  } else {\n    _rs = Array.prototype.slice.call(args);\n  }\n  if (_rs.length === 1) {\n    //[2] => [2,2]\n    _rs.push(_rs[0]);\n  }\n\n  while (_rs.length < A._ndims) {\n    _rs.push(1);\n  }\n\n  // remove tailing 1\n  while ((_rs.length > A._ndims) && (_rs[_rs.length - 1] == 1)) {\n    _rs.pop();\n  }\n\n  var newdims = _rs.length;\n  var newsize: number[] = [];\n  var input_strides: number[] = [];\n  var output_strides: number[] = [];\n  var tmp_in_stride = 1;\n  var tmp_out_stride = 1;\n  var n_copy = 1;\n  var rs_strides: number[] = [];\n  for (var dim = 0; dim < newdims; dim++) {\n    var indimsize = A._ndims > dim ? A._size[dim] : 1;\n    var outdimsize = indimsize * _rs[dim];\n    rs_strides.push(n_copy);\n    n_copy *= _rs[dim];\n    newsize.push(outdimsize);\n    input_strides.push(tmp_in_stride);\n    output_strides.push(tmp_out_stride);\n    tmp_in_stride *= indimsize;\n    tmp_out_stride *= outdimsize;\n  }\n  input_strides.push(tmp_in_stride);//dummy\n  rs_strides.push(n_copy);//dummy\n\n  var output_steps: number[] = [];\n  for (var i = 0; i < n_copy; i++) {\n    var out_offset = 0;\n    for (var dim = 0; dim < newdims; dim++) {\n      out_offset += Math.floor(i % rs_strides[dim + 1] / rs_strides[dim]) * output_strides[dim] * (A._size[dim] || 1);\n    }\n    output_steps.push(out_offset);\n  }\n\n  var dst = new Matrix(newsize, A._klass);\n  var a_data = A._data;\n  var dst_data = dst._data;\n  for (var i = 0, i_length = A._numel; i < i_length; i++) {\n    var a_i = a_data[i];\n    var out_offset = 0;\n    for (var dim = 0; dim < newdims; dim++) {\n      out_offset += Math.floor(i % input_strides[dim + 1] / input_strides[dim]) * output_strides[dim];\n    }\n    for (var j = 0; j < n_copy; j++) {\n      var out_idx = out_offset + output_steps[j];\n      dst_data[out_idx] = a_i;\n    }\n\n  }\n  return dst;\n}\n\nexport function cat(dim: number, ...As: Matrix[]): Matrix {\n  //dimension other than concatenating dimension must be same\n  var dst_size = As[0]._size.concat();\n  // if dim == 4, [2, 3] => [2, 3, 1, 1]\n  while (dst_size.length < dim) {\n    dst_size.push(1);\n  }\n  var concat_offsets = [1];\n  for (var i = 1; i < As.length; i++) {\n    var A = As[i];\n    if (A._numel == 0) {\n      concat_offsets.push(0);//not used\n      continue;\n    }\n    var a_size = A._size;\n    if (a_size.length > dst_size.length) {\n      throw Error('Dimension mismatch');\n    }\n    for (var d = 0; d < dst_size.length; d++) {\n      var a_dim = a_size[d] || 1;\n      if (d == dim - 1) {\n        // dimension to concat\n        concat_offsets.push(dst_size[d] + 1);\n        dst_size[d] += a_dim;\n      } else {\n        if (a_dim != dst_size[d]) {\n          throw Error('Dimension mismatch');\n        }\n      }\n\n    }\n  }\n\n  var dst = new Matrix(dst_size, As[0]._klass);\n  for (var i = 0; i < As.length; i++) {\n    var A = As[i];\n    if (A._numel == 0) {\n      continue;\n    }\n    var args: any[] = [];\n    for (var d = 0; d < dst_size.length; d++) {\n      var element = A._size[d] || 1;\n      if (d == dim - 1) {\n        args.push(colon(concat_offsets[i], concat_offsets[i] + element - 1));\n      } else {\n        args.push(colon());\n      }\n    }\n    args.push(A);\n\n    dst.set(...args);\n  }\n\n  return dst;\n}\n\nexport function horzcat(...As: Matrix[]): Matrix {\n  return cat(2, ...As);\n}\n\nexport function vertcat(...As: Matrix[]): Matrix {\n  return cat(1, ...As);\n}\n\nexport function permute(A: Matrix, order: number[]): Matrix {\n  var src_size = A._size.concat();\n  var numel = A._numel;\n  if (order.length < src_size.length) {\n    throw Error('order must include at least input dimension');\n  }\n  var ndim = order.length;\n  var src_strides = A._strides.concat();\n  while (src_size.length < ndim) {\n    //append dimension of 1\n    src_size.push(1);\n    src_strides.push(numel);\n  }\n  var dst_size: number[] = [];\n  for (var d = 0; d < ndim; d++) {\n    var element = order[d] - 1;//order start from 1\n    dst_size.push(src_size[element]);\n  }\n\n  var dst = new Matrix(dst_size, A._klass);\n  var dst_strides = dst._strides.concat();\n  while (dst_strides.length < ndim) {\n    // occur when last dimensions are 1\n    dst_strides.push(numel);\n  }\n  var dst_strides_perm = [];\n  order.forEach((o, i) => dst_strides_perm[o - 1] = dst_strides[i]);\n  var src_data = A.getdataref();\n  var dst_data = dst._data;\n  for (var i = 0; i < numel; i++) {\n    var dst_idx = 0;\n    for (var d = 0; d < ndim; d++) {\n      dst_idx += Math.floor(i / src_strides[d]) % src_size[d] * dst_strides_perm[d];\n    }\n    dst_data[dst_idx] = src_data[i];\n  }\n  return dst;\n}\n\nexport function ipermute(A: Matrix, order: number[]): Matrix {\n  // reverse order\n  var rev_order = order.concat();//have same elements\n  for (var d = 0; d < order.length; d++) {\n    rev_order[order[d] - 1] = d + 1;\n  }\n  return permute(A, rev_order);\n}\n", "// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\nimport Matrix = require('./matrix');\nimport util = require('./util');\nimport func_generator = require('./func_generator');\n\nexport type MatrixOrNumber = util.MatrixOrNumber;\n\nfunction max_along_axis_old(A: Matrix, dim?: number): Matrix {\n  if (dim == null) {\n    //select first non-1 axis\n    dim = A._numel;\n    for (var i = 0; i < A._size.length; i++) {\n      var dimsize = A._size[i];\n      if (dimsize !== 1) {\n        dim = i + 1;\n        break;\n      }\n    }\n  }\n\n  if (dim > A._ndims) {\n    //max along axis with size 1\n    return A.copy();\n  }\n\n  var dstsize = A._size.slice();\n  if (dstsize[dim - 1] !== 0) {\n    //size 0 dimension is preserved\n    dstsize[dim - 1] = 1;\n  }\n\n  if ((A._numel === 0) || (A._size[dim - 1] === 1)) {\n    //only change shape\n    var dst_onlyreshape = A.copy();\n    dst_onlyreshape.reshape_inplace(dstsize);\n    return dst_onlyreshape;\n  }\n\n  //reduction actually needed\n  var dst = new Matrix(dstsize, A._klass);\n  var input_strides = A._strides;\n  var output_strides = dst._strides.slice();\n  while (output_strides.length <= input_strides.length) {\n    output_strides.push(dst._numel);\n  }\n\n  var reduction_step = input_strides[dim - 1];\n  var reduction_count = A._size[dim - 1];\n  var a_data = A._data;\n  var dst_data = dst._data;\n  var dims = A._ndims;\n  for (var dst_idx = 0, dst_numel = dst._numel; dst_idx < dst_numel; dst_idx++) {\n    var src_idx = 0;\n    for (var d = 0; d < dims; d++) {\n      src_idx += Math.floor(dst_idx % output_strides[d + 1] / output_strides[d]) * input_strides[d];\n    }\n\n    var val = a_data[src_idx];\n    var curret = val;\n    for (var red = 1; red < reduction_count; red++) {\n      src_idx += reduction_step;\n      val = a_data[src_idx];\n      if (val > curret) {\n        curret = val;\n      }\n    }\n\n    dst_data[dst_idx] = curret;\n  }\n\n  return dst;\n}\n\nfunction _argmax_ones_like(A: Matrix): { M: Matrix, I: Matrix } {\n  var amax = new Matrix(A._size, 'int32');\n  amax._data.fill(1);\n  return { M: A, I: amax };\n}\n\nfunction make_reduction_along_axis(var_decl: string, var_update: string, result_assign: string, out_argmax: boolean) {\n  var f: any;\n  eval([\n    \"f = function(A, dim) {\",\n    \"    if (dim == null) {\",\n    \"        //select first non-1 axis\",\n    \"        dim = A._numel;\",\n    \"        for (var i = 0; i < A._size.length; i++) {\",\n    \"            var dimsize = A._size[i];\",\n    \"            if (dimsize !== 1) {\",\n    \"                dim = i + 1;\",\n    \"                break;\",\n    \"            }\",\n    \"        }\",\n    \"    }\",\n    \"    if (dim > A._ndims) {\",\n    \"        //max along axis with size 1\",\n    out_argmax ? \"return _argmax_ones_like(A.copy());\" : \"return A.copy();\",\n    \"    }\",\n    \"    var dstsize = A._size.slice();\",\n    \"    if (dstsize[dim - 1] !== 0) {\",\n    \"        //size 0 dimension is preserved\",\n    \"        dstsize[dim - 1] = 1;\",\n    \"    }\",\n    \"    if (A._numel === 0) {\",\n    \"        //only change shape\",\n    \"        var dst_onlyreshape = A.copy();\",\n    \"        dst_onlyreshape.reshape_inplace(dstsize);\",\n    out_argmax ? \"return _argmax_ones_like(dst_onlyreshape);\" : \"return dst_onlyreshape;\",\n    \"    }\",\n    \"    //reduction actually needed\",\n    \"    var dst = new Matrix(dstsize, A._klass);\",\n    out_argmax ? \"var amax = new Matrix(dstsize, 'int32'); var amax_data = amax._data;\" : \"\",\n    \"    var input_strides = A._strides;\",\n    \"    var output_strides = dst._strides.slice();\",\n    \"    while (output_strides.length <= input_strides.length) {\",\n    \"        output_strides.push(dst._numel);\",\n    \"    }\",\n    \"    var reduction_step = input_strides[dim - 1];\",\n    \"    var reduction_count = A._size[dim - 1];\",\n    \"    var a_data = A._data;\",\n    \"    var dst_data = dst._data;\",\n    \"    var dims = A._ndims;\",\n    \"    for (var dst_idx = 0, dst_numel = dst._numel; dst_idx < dst_numel; dst_idx++) {\",\n    \"        var src_idx = 0;\",\n    \"        for (var d = 0; d < dims; d++) {\",\n    \"            src_idx += Math.floor(dst_idx % output_strides[d + 1] / output_strides[d]) * input_strides[d];\",\n    \"        }\",\n    \"        var val = a_data[src_idx];\",\n    //\"        var curret = val;\",\n    var_decl,\n    \"        for (var red = 1; red < reduction_count; red++) {\",\n    \"            src_idx += reduction_step;\",\n    \"            val = a_data[src_idx];\",\n    //\"            if (val > curret) {\",\n    //\"                curret = val;\",\n    //\"            }\",\n    var_update,\n    \"        }\",\n    //\"        dst_data[dst_idx] = curret;\",\n    result_assign,\n    \"    }\",\n    out_argmax ? \"return {M:dst,I:amax};\" : \"return dst;\",\n    \"}\",].join('\\n'));\n  return f;\n}\n\nfunction make_reduction_along_axis_stat(var_decl: string, var_update: string, result_assign: string) {\n  var f: any;\n  eval([\n    \"f = function(A, dim) {\",\n    \"    if (dim == null) {\",\n    \"        //select first non-1 axis\",\n    \"        dim = A._numel;\",\n    \"        for (var i = 0; i < A._size.length; i++) {\",\n    \"            var dimsize = A._size[i];\",\n    \"            if (dimsize !== 1) {\",\n    \"                dim = i + 1;\",\n    \"                break;\",\n    \"            }\",\n    \"        }\",\n    \"    }\",\n    \"    if (dim > A._ndims) {\",\n    \"        //max along axis with size 1\",\n    \"    }\",\n    \"    var dstsize = A._size.slice();\",\n    \"    if (dstsize[dim - 1] !== 0) {\",\n    \"        //size 0 dimension is preserved\",\n    \"        dstsize[dim - 1] = 1;\",\n    \"    }\",\n    \"    if (A._numel === 0) {\",\n    \"        //only change shape\",\n    \"        var dst_onlyreshape = A.copy();\",\n    \"        dst_onlyreshape.reshape_inplace(dstsize);\",\n    \"        return dst_onlyreshape;\",\n    \"    }\",\n    \"    //reduction actually needed\",\n    \"    var dst = new Matrix(dstsize, 'single');\",\n    \"    var input_strides = A._strides;\",\n    \"    var output_strides = dst._strides.slice();\",\n    \"    while (output_strides.length <= input_strides.length) {\",\n    \"        output_strides.push(dst._numel);\",\n    \"    }\",\n    \"    var reduction_step = input_strides[dim - 1];\",\n    \"    var reduction_count = A._size[dim - 1];\",\n    \"    var a_data = A._data;\",\n    \"    var dst_data = dst._data;\",\n    \"    var dims = A._ndims;\",\n    \"    for (var dst_idx = 0, dst_numel = dst._numel; dst_idx < dst_numel; dst_idx++) {\",\n    \"        var src_idx = 0;\",\n    \"        for (var d = 0; d < dims; d++) {\",\n    \"            src_idx += Math.floor(dst_idx % output_strides[d + 1] / output_strides[d]) * input_strides[d];\",\n    \"        }\",\n    \"        var val = a_data[src_idx];\",\n    //\"        var curret = val;\",\n    var_decl,\n    \"        for (var red = 1; red < reduction_count; red++) {\",\n    \"            src_idx += reduction_step;\",\n    \"            val = a_data[src_idx];\",\n    //\"            if (val > curret) {\",\n    //\"                curret = val;\",\n    //\"            }\",\n    var_update,\n    \"        }\",\n    //\"        dst_data[dst_idx] = curret;\",\n    result_assign,\n    \"    }\",\n    \"return dst;\",\n    \"}\",].join('\\n'));\n  return f;\n}\n\nvar max_along_axis = make_reduction_along_axis('var curret = val;',\n  'if(val>curret){curret=val;}',\n  'dst_data[dst_idx]=curret;', false);\nvar max_elementwise = func_generator.make_binary_arith_func_all('Math.max(%a,%b)');\n\nvar min_along_axis = make_reduction_along_axis('var curret = val;',\n  'if(val<curret){curret=val;}',\n  'dst_data[dst_idx]=curret;', false);\nvar min_elementwise = func_generator.make_binary_arith_func_all('Math.min(%a,%b)');\n\nexport function max(A: MatrixOrNumber, B?: MatrixOrNumber, dim?: number): Matrix {\n  if (B == null) {\n    //max along axis\n    return max_along_axis(util.as_mat(A), dim);\n  } else {\n    //elementwise max\n    return max_elementwise(A, B);\n  }\n}\n\n\nexport function min(A: MatrixOrNumber, B?: MatrixOrNumber, dim?: number): Matrix {\n  if (B == null) {\n    return min_along_axis(util.as_mat(A), dim);\n  } else {\n    return min_elementwise(A, B);\n  }\n}\n\n\nvar argmax_along_axis = make_reduction_along_axis('var curret = val, curamax = 0;',\n  'if(val>curret){curret=val;curamax=red;}',\n  'dst_data[dst_idx]=curret; amax_data[dst_idx]=curamax+1;', true);\nexport function argmax(A: MatrixOrNumber, dummy?: any, dim?: number): { M: Matrix, I: Matrix } {\n  return argmax_along_axis(util.as_mat(A), dim);\n}\n\nvar argmin_along_axis = make_reduction_along_axis('var curret = val, curamax = 0;',\n  'if(val<curret){curret=val;curamax=red;}',\n  'dst_data[dst_idx]=curret; amax_data[dst_idx]=curamax+1;', true);\nexport function argmin(A: MatrixOrNumber, dummy?: any, dim?: number): { M: Matrix, I: Matrix } {\n  return argmin_along_axis(util.as_mat(A), dim);\n}\n\nfunction sum_mean(A: Matrix, args: any[], f: (A: Matrix, dim: number) => Matrix): Matrix {\n  var dim = undefined;\n  var outtype = undefined;\n  while (args.length > 0) {\n    var arg = args.pop();\n    if (typeof (arg) === 'string') {\n      if (arg != 'native') {\n        throw new Error('Outtype other than native is currently not supported');\n      }\n    } else if (typeof (arg) === 'number') {\n      dim = arg;\n    } else {\n      throw new Error('Unknown argument ' + arg);\n    }\n  }\n  return f(A, dim);\n}\n\nvar sum_along_axis = make_reduction_along_axis_stat('var curret = val;',\n  'curret += val;', 'dst_data[dst_idx] = curret;');\nexport function sum(A: Matrix): Matrix;\nexport function sum(A: Matrix, dim: number, outtype?: string): Matrix;\nexport function sum(A: Matrix, outtype?: string): Matrix;\nexport function sum(A: Matrix, ...args: any[]): Matrix {\n  return sum_mean(A, args, sum_along_axis);\n}\n\nvar mean_along_axis = make_reduction_along_axis_stat('var curret = val;',\n  'curret += val;', 'dst_data[dst_idx] = curret / reduction_count;');\nexport function mean(A: Matrix): Matrix;\nexport function mean(A: Matrix, dim: number, outtype?: string): Matrix;\nexport function mean(A: Matrix, outtype?: string): Matrix;\nexport function mean(A: Matrix, ...args: any[]): Matrix {\n  return sum_mean(A, args, mean_along_axis);\n}\n\nvar prod_along_axis = make_reduction_along_axis_stat('var curret = val;',\n  'curret *= val;', 'dst_data[dst_idx] = curret;');\nexport function prod(A: Matrix): Matrix;\nexport function prod(A: Matrix, dim: number, outtype?: string): Matrix;\nexport function prod(A: Matrix, outtype?: string): Matrix;\nexport function prod(A: Matrix, ...args: any[]): Matrix {\n  return sum_mean(A, args, prod_along_axis);\n}\n\n//w=0: normalize by N-1\nvar variance_along_axis_w0 = make_reduction_along_axis_stat('var normalsum = val; var sqsum = val * val;',\n  'normalsum += val; sqsum += val * val;', 'dst_data[dst_idx] = (sqsum - normalsum * normalsum / reduction_count) / Math.max(reduction_count - 1, 1);');\n//w=1: normalize by N\nvar variance_along_axis_w1 = make_reduction_along_axis_stat('var normalsum = val; var sqsum = val * val;',\n  'normalsum += val; sqsum += val * val;', 'dst_data[dst_idx] = (sqsum - normalsum * normalsum / reduction_count) / reduction_count;');\nexport function variance(A: Matrix, w: number = 0, dim?: number): Matrix {\n  if (w == 0) {\n    return variance_along_axis_w0(A, dim);\n  } else if (w == 1) {\n    return variance_along_axis_w1(A, dim);\n  } else {\n    throw new Error('w must be 0 or 1');\n  }\n}\n\n//w=0: normalize by N-1\nvar std_along_axis_w0 = make_reduction_along_axis_stat('var normalsum = val; var sqsum = val * val;',\n  'normalsum += val; sqsum += val * val;', 'dst_data[dst_idx] = Math.sqrt((sqsum - normalsum * normalsum / reduction_count) / Math.max(reduction_count - 1, 1));');\n//w=1: normalize by N\nvar std_along_axis_w1 = make_reduction_along_axis_stat('var normalsum = val; var sqsum = val * val;',\n  'normalsum += val; sqsum += val * val;', 'dst_data[dst_idx] = Math.sqrt((sqsum - normalsum * normalsum / reduction_count) / reduction_count);');\nexport function std(A: Matrix, w: number = 0, dim?: number): Matrix {\n  if (w == 0) {\n    return std_along_axis_w0(A, dim);\n  } else if (w == 1) {\n    return std_along_axis_w1(A, dim);\n  } else {\n    throw new Error('w must be 0 or 1');\n  }\n}\n", "// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\nimport Matrix = require('./matrix');\nimport util = require('./util');\n\nexport function mtimes(A: Matrix, B: Matrix): Matrix {\n  if (A._ndims != 2 || B._ndims != 2) {\n    throw new Error('Matrix must be two-dimensional');\n  }\n\n  if (A._size[1] != B._size[0]) {\n    throw new Error('Shape mismatch');\n  }\n\n  if (A._klass != 'single' || B._klass != 'single') {\n    throw new Error('Matrix klass must be single');\n  }\n\n  var m = A._size[0], n = B._size[1], k = A._size[1];\n  var lda = A._strides[1];\n  var ldb = B._strides[1];\n  var data_a = A._data;\n  var data_b = B._data;\n  var dst = new Matrix([m, n], 'single');\n  var ldc = dst._strides[1];\n  var data_c = dst._data;\n\n  for (var i = 0; i < m; i++) {\n    for (var j = 0; j < n; j++) {\n      var sum = 0;\n      for (var r = 0; r < k; r++) {\n        sum += data_a[i + r * lda] * data_b[r + j * ldb];\n      }\n      data_c[i + j * ldc] = sum;\n    }\n  }\n\n  return dst;\n}\n", "// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\n// read/write numpy format matrix file\n\nimport Matrix = require('../matrix');\n\nfunction parse_header(header_data: Uint8Array): { descr_wo_endian: string, fortran_order: boolean, shape: number[], little_endian: boolean } {\n  //{'descr': '<i4', 'fortran_order': False, 'shape': (3, 1), }            \\n\n  var header_str = '';\n  for (var i = 0; i < header_data.length; i++) {\n    var element = header_data[i];\n    header_str += String.fromCharCode(element);\n  }\n\n  var hobj = /^\\{'descr': '(.*)', 'fortran_order': (True|False), 'shape': \\(([0-9, ]+)\\), \\} *\\n$/.exec(header_str);\n  if (hobj == null) {\n    throw Error('Failed to parse header string');\n  }\n\n  var typechars = hobj[1];//\"<i4\"\n  var little_endian = true;\n  switch (typechars.substr(0, 1)) {\n    case \"<\":\n    case \"|\"://not applicable (uint8)\n      little_endian = true;\n      break;\n    case \">\":\n      little_endian = false;\n      break;\n    default:\n      throw Error('Unknown endian');\n  }\n  var descr_wo_endian = typechars.substr(1, 2);\n\n  var fortran_order = hobj[2] == 'True';\n  var shape_str = hobj[3].split(',');\n  var shape: number[];\n  if (shape_str[1] == '') {\n    //1-d array (3,) to column vector (3,1)\n    shape = [Number(shape_str[0]), 1];\n  } else {\n    shape = shape_str.map((v) => Number(v.trim()));\n  }\n\n  return { descr_wo_endian: descr_wo_endian, fortran_order: fortran_order, shape: shape, little_endian: little_endian };\n}\n\nfunction is_little_endian(): boolean {\n  /**\n   * Check if this machine is little endian\n   */\n  var raw = new Uint8Array([0x1, 0x2, 0x3, 0x4]);\n  var view = new Uint32Array(raw.buffer);\n  if (view[0] == 0x01020304) {\n    //big endian\n    return false;\n  } else {\n    return true;\n  }\n}\n\nvar mat_klass_map = {\n  'b1': 'logical',\n  'u1': 'uint8',\n  'i4': 'int32',\n  'f4': 'single',\n  'f8': 'single'\n};\nvar view_accessor_map = {\n  'b1': DataView.prototype.getUint8,\n  'u1': DataView.prototype.getUint8,\n  'i4': DataView.prototype.getInt32,\n  'f4': DataView.prototype.getFloat32,\n  'f8': DataView.prototype.getFloat64\n};\nvar view_bytestep_map = { 'b1': 1, 'u1': 1, 'i4': 4, 'f4': 4, 'f8': 8 };\n\nexport function npyread(data: ArrayBuffer | Uint8Array): Matrix {\n  //for node: npyread(fs.readFileSync())\n  var byteOffset = 0;\n  if (ArrayBuffer.isView(data)) {\n    //data is Uint8Array\n    byteOffset = (<Uint8Array>data).byteOffset;\n    data = (<Uint8Array>data).buffer;\n  }\n\n  var header_view = new Uint8Array(data, byteOffset);\n  //check magic number\n  var expect_header = [0x93, 0x4e, 0x55, 0x4d, 0x50, 0x59, 0x01, 0x00];//only format 1 supported\n  for (var i = 0; i < expect_header.length; i++) {\n    if (header_view[i] != expect_header[i]) {\n      throw Error('Incompatible format header');\n    }\n  }\n  var header_len = header_view[8] + header_view[9] * 256;//16bit little endian\n  var data_type = parse_header(header_view.slice(10, 10 + header_len));\n  var mat_klass = mat_klass_map[data_type.descr_wo_endian];\n  if (mat_klass == null) {\n    throw Error('Unsupported data type');\n  }\n  var data_view = new DataView(data, byteOffset + 10 + header_len);\n  //b1 seems to have only 0/1, so no conversion needed\n  var mat = new Matrix(data_type.shape, mat_klass);\n  var mat_data = mat.getdataref();\n  var view_accessor = view_accessor_map[data_type.descr_wo_endian];\n  var view_bytestep = view_bytestep_map[data_type.descr_wo_endian];\n  var numel = mat._numel;\n  var view_little_endian = data_type.little_endian;\n  if (data_type.fortran_order) {\n    // sequentially copy\n    for (var i = 0; i < numel; i++) {\n      var val = view_accessor.call(data_view, view_bytestep * i, view_little_endian);\n      mat_data[i] = val;\n    }\n  } else {\n    //change order from c-order to fortran-order\n    /*\n    Size of matrix: (I, J, K)\n    c-order strides: (J*K, K, 1)\n    f-order strides: (1, I, I*J)\n    when linear index in c-order is x:\n    matrix index: (x / (J*K) % I * 1, x / K % J * I, x / 1 % K * I * J)\n    that is: x / cstride[i] % size[i] * fstride[i] (i = 0,1,2)\n    */\n    var size = mat._size;\n    var cstride = [];\n    var fstride = [];\n    var last_cstride = 1;\n    var last_fstride = 1;\n    for (var dim = 0; dim < size.length; dim++) {\n      cstride.unshift(last_cstride);\n      fstride.push(last_fstride);\n      last_cstride *= size[size.length - 1 - dim];\n      last_fstride *= size[dim];\n    }\n    for (var i = 0; i < numel; i++) {\n      var val = view_accessor.call(data_view, view_bytestep * i, view_little_endian);\n      var fidx = 0;\n      for (var dim = 0; dim < size.length; dim++) {\n        fidx += Math.floor(i / cstride[dim]) % size[dim] * fstride[dim];\n      }\n      mat_data[fidx] = val;\n    }\n\n  }\n\n  return mat;\n}\n\nvar save_klass_map = {'logical': 'b1', 'uint8': 'u1', 'int32': 'i4', 'single': 'f4'};\nvar header_padding = '';\nexport function npysave(A: Matrix): ArrayBuffer {\n\n  var klass = A._klass;\n  var endian_char;\n  switch (klass) {\n    case 'logical':\n    case 'uint8':\n      endian_char = '|';//not applicable\n      break;  \n    default:\n      endian_char = is_little_endian() ? '<' : '>';\n      break;\n  }\n  var header_str = \"{'descr': '\"+endian_char + save_klass_map[klass] + \n  \"', 'fortran_order': True, 'shape': (\" + A._size.join(', ') + \"), }\";\n  //pad header_str to be (multiple of 16) - (magic 10 + last \\n)\n  var pad_len = 16 - (header_str.length + 11) % 16;\n  header_str += '                '.substr(0, pad_len) + '\\n';\n  var header_len = header_str.length;\n  var header_total_len = header_len + 10;//header with magic number\n  var dst_size = A._numel * A._data_ctor.BYTES_PER_ELEMENT + header_total_len;\n  var dst = new ArrayBuffer(dst_size);\n  var dst_byte_offset = 0;\n  var header_dst_view = new Uint8Array(dst, dst_byte_offset, header_total_len);\n  var const_header = [0x93, 0x4e, 0x55, 0x4d, 0x50, 0x59, 0x01, 0x00];\n  for (var i = 0; i < const_header.length; i++) {\n    header_dst_view[i] = const_header[i];\n  }\n  header_dst_view[8] = header_len % 256;\n  header_dst_view[9] = Math.floor(header_len / 256);\n  for (var i = 0; i < header_len; i++) {\n    header_dst_view[10+i] = header_str.charCodeAt(i);\n  }\n\n  var body_dst_view = new A._data_ctor(dst, dst_byte_offset + header_total_len, A._numel);\n  body_dst_view.set(A.getdataref());\n  return dst;\n}\n", "'use strict';\n// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\n\n(function () {\n  var $M = require('../../sushi');\n\n  var $CL = {};\n  $CL.WebCL = createWebCLObject();\n  initWebCL($CL.WebCL);\n  initUtilityMethods($CL.WebCL);\n\n  function createWebCLObject() {\n    // create WebCL object\n    var web_cl;\n    try {\n      web_cl = require('node-opencl');\n    } catch (e) {\n      web_cl = void 0;\n    }\n    return web_cl;\n  }\n\n  function initWebCL(WebCL) {\n    // decide platform to use\n    var platform_list = WebCL.getPlatformIDs();\n    var platform_index = 0;\n    if ('OPENCL_PLATFORM_INDEX' in process.env) {\n      platform_index = Number(process.env['OPENCL_PLATFORM_INDEX']);\n      if (platform_index >= platform_list.length) {\n        throw new Error('Invalid platform index ' + platform_index);\n      }\n    } else {\n      //select by name\n      var platform_priority = ['CUDA', 'AMD', 'Apple', 'OpenCL'];\n      var priority = platform_priority.length + 1;\n      var includeIndexOf = function (array, search) {\n        for (var i = 0; i < array.length; i++) {\n          if (search.indexOf(array[i]) !== -1) {\n            return i;\n          }\n        }\n        return array.length;\n      };\n      for (var i = 0; i < platform_list.length; i++) {\n        var platform_tmp = platform_list[i];\n        var platform_info_tmp = WebCL.getPlatformInfo(platform_tmp, WebCL.PLATFORM_NAME);\n        var priority_tmp = includeIndexOf(platform_priority, platform_info_tmp);\n        if (priority_tmp < priority) {\n          priority = priority_tmp;\n          platform_index = i;\n          $CL.platform = platform_tmp;\n          $CL.platform_info = platform_info_tmp;\n        }\n      }\n    }\n    $CL.platform = platform_list[platform_index];\n    $CL.platform_info = WebCL.getPlatformInfo($CL.platform, WebCL.PLATFORM_NAME);\n\n    try {\n      var device_type = WebCL.DEVICE_TYPE_GPU;\n      $CL.devices = WebCL.getDeviceIDs($CL.platform, device_type);//causes exception on firefox + Intel OpenCL\n    } catch (ex) {\n      $CL.devices = [];\n    }\n    if ($CL.devices.length === 0) {\n      device_type = WebCL.DEVICE_TYPE_CPU;\n      $CL.devices = WebCL.getDeviceIDs($CL.platform, device_type);;\n    }\n\n    // device selector (experimental)\n    var device_index = 0;\n    // Explicit setting by environment variable\n    if ('OPENCL_DEVICE_INDEX' in process.env) {\n      device_index = Number(process.env['OPENCL_DEVICE_INDEX']);\n      if (device_index >= $CL.devices.length) {\n        throw new Error('Invalid device index ' + device_index);\n      }\n    }\n    $CL.selected_device = $CL.devices[device_index];\n    $CL.device_info = WebCL.getDeviceInfo($CL.selected_device, WebCL.DEVICE_NAME);\n    $CL.device_max_work_group_size = WebCL.getDeviceInfo($CL.selected_device, WebCL.DEVICE_MAX_WORK_GROUP_SIZE);\n\n    // initialize methods dependent on implementation\n    WebCL.type = {\n      CHAR: 0,\n      UCHAR: 1,\n      SHORT: 2,\n      USHORT: 3,\n      INT: 4,\n      UINT: 5,\n      LONG: 6,\n      ULONG: 7,\n      FLOAT: 8,\n      HALF: 9,\n      DOUBLE: 10,\n      QUAD: 11,\n      LONG_LONG: 12,\n      VEC2: 65536,\n      VEC3: 131072,\n      VEC4: 262144,\n      VEC8: 524288,\n      VEC16: 1048576,\n      LOCAL_MEMORY_SIZE: 255\n    };\n    var table_primitive = {};\n    table_primitive[WebCL.type.CHAR] = 'char';\n    table_primitive[WebCL.type.UCHAR] = 'uchar';\n    table_primitive[WebCL.type.SHORT] = 'short';\n    table_primitive[WebCL.type.USHORT] = 'ushort';\n    table_primitive[WebCL.type.INT] = 'int';\n    table_primitive[WebCL.type.UINT] = 'uint';\n    table_primitive[WebCL.type.LONG] = 'long';//64bit variable is not supported\n    table_primitive[WebCL.type.ULONG] = 'ulong';\n    table_primitive[WebCL.type.FLOAT] = 'float';\n    table_primitive[WebCL.type.HALF] = 'half';//16bit float is not supported\n    table_primitive[WebCL.type.DOUBLE] = 'double';\n    table_primitive[WebCL.type.QUAD] = 'quad';//not supported\n    table_primitive[WebCL.type.LONG_LONG] = 'long long';//not supported\n    var table_vec_len = {};\n    table_vec_len[0] = 1;\n    table_vec_len[WebCL.type.VEC2] = 2;\n    table_vec_len[WebCL.type.VEC3] = 3;\n    table_vec_len[WebCL.type.VEC4] = 4;\n    table_vec_len[WebCL.type.VEC8] = 8;\n    table_vec_len[WebCL.type.VEC16] = 16;\n    $CL.context = WebCL.createContext([WebCL.CONTEXT_PLATFORM, $CL.platform, 0], [$CL.selected_device]);\n    $CL.kernelSetArg = function (kernel, idx, param, type) {\n      var typestr = '';\n      if (type !== void 0) {\n        if (type == WebCL.type.LOCAL_MEMORY_SIZE) {\n          typestr = 'local';\n        } else {\n          var primitive = type & 0xFF;\n          typestr = table_primitive[primitive];\n          var vec = type & 0x1F0000;\n          var vec_len = table_vec_len[vec];\n          if (vec_len > 1) {\n            typestr += vec_len;\n          }\n        }\n      } else {\n        //buffer\n        typestr = 'cl_mem';\n      }\n      WebCL.setKernelArg(kernel, idx, typestr, param);\n    };\n\n    if (WebCL.createCommandQueueWithProperties !== undefined) {\n      $CL.queue = WebCL.createCommandQueueWithProperties($CL.context, $CL.selected_device, []); // OpenCL 2\n    } else {\n      $CL.queue = WebCL.createCommandQueue($CL.context, $CL.selected_device, 0); // OpenCL 1.x\n    }\n\n    $CL.buffers = 0;//number of existing buffers on device\n  }\n\n\n  function initUtilityMethods(WebCL) {\n    $CL.createKernel = function (code, name) {\n      if (!name) {\n        name = 'kernel_func';\n      }\n      var program = WebCL.createProgramWithSource($CL.context, code);\n      WebCL.buildProgram(program);\n      return WebCL.createKernel(program, name);\n    };\n\n    $CL.createBuffer = function (byte_length) {\n      var buffer = WebCL.createBuffer($CL.context, WebCL.MEM_READ_WRITE, byte_length);\n      $CL.buffers++;\n      return buffer;\n    };\n\n    $CL.writeBuffer = function (buffer, typed_array, offset) {\n      if (offset === void 0) { offset = 0; }\n      WebCL.enqueueWriteBuffer($CL.queue, buffer,\n        true,//blocking write\n        offset,\n        typed_array.byteLength,\n        typed_array);\n    }\n\n    $CL.executeKernel = function (kernel, params, parallelization, localWS) {\n      for (var i = 0; i < params.length; i++) {\n        if (params[i].type === void 0) {\n          // Matrix class\n          $CL.kernelSetArg(kernel, i, params[i].datum._clbuffer);\n        } else {\n          // native type\n          $CL.kernelSetArg(kernel, i, params[i].datum, params[i].type);\n        }\n      }\n\n      // scalar to array\n      if (parallelization != null && parallelization.length === void 0) {\n        parallelization = [parallelization];\n      }\n      if (localWS != null && localWS.length === void 0) {\n        localWS = [localWS];\n      }\n\n      var globalWS;\n      if (localWS == null) {\n        //n-d parallelization\n        var localWS_each = [64, 64, 8, 4][parallelization.length];\n        localWS = [];\n        globalWS = [];\n        for (var i = 0; i < parallelization.length; i++) {\n          localWS.push(localWS_each);\n          globalWS.push(Math.ceil(parallelization[i] / localWS_each) * localWS_each);\n        }\n      } else {\n        globalWS = [];\n        for (var i = 0; i < parallelization.length; i++) {\n          globalWS.push(Math.ceil(parallelization[i] / localWS[i]) * localWS[i]);\n        }\n      }\n      // Execute kernel\n      WebCL.enqueueNDRangeKernel($CL.queue, kernel,\n        globalWS.length,\n        null,\n        globalWS,\n        localWS);\n      $CL.flush();\n    };\n\n    $CL.flush = function () {\n      WebCL.flush($CL.queue);\n    };\n\n    $CL.finish = function () {\n      WebCL.finish($CL.queue);\n    };\n\n    $CL.readBuffer = function (buffer, typed_array, offset) {\n      if (offset === void 0) { offset = 0; }\n      WebCL.enqueueReadBuffer($CL.queue, buffer,\n        true,//blocks until the reading completes\n        offset,\n        typed_array.byteLength,\n        typed_array);\n    }\n\n    $CL.releaseBuffer = function (buffer) {\n      WebCL.releaseMemObject(buffer);\n      $CL.buffers--;\n    };\n  }\n\n  module.exports = $CL;\n})();\n", "'use strict';\n// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\n\n(function () {\n  var $M = require('../../sushi');\n\n  var $CL = {};\n  var env = getEnvironment();\n  $CL.WebCL = createWebCLObject();\n  initWebCL($CL.WebCL);\n  initUtilityMethods($CL.WebCL);\n\n  function getEnvironment() {\n    // check environment\n    var env;\n    if (typeof window !== 'undefined' && window.webcl !== void 0) {\n      env = 'ff';\n    } else if (typeof WebCL === 'function') {\n      env = 'chromium';\n    } else {\n      throw new Error('WebCL object not found. WebCL may be not supported on this browser.');\n    }\n    return env;\n  }\n\n  function createWebCLObject() {\n    // create WebCL object\n    var web_cl = void 0;\n    switch (env) {\n      case 'chromium':\n        web_cl = new WebCL();\n        break;\n      case 'ff':\n        web_cl = window.webcl;\n        break;\n    }\n    return web_cl;\n  }\n\n  function initWebCL(WebCL) {\n    // decide platform to use\n    var platform_list = WebCL.getPlatforms();\n    var platform_index = 0;\n    //select by name\n    var platform_priority = ['CUDA', 'AMD', 'Apple', 'OpenCL'];\n    var priority = platform_priority.length + 1;\n    var includeIndexOf = function (array, search) {\n      for (var i = 0; i < array.length; i++) {\n        if (search.indexOf(array[i]) !== -1) {\n          return i;\n        }\n      }\n      return array.length;\n    };\n    for (var i = 0; i < platform_list.length; i++) {\n      var platform_tmp = platform_list[i];\n      var platform_info_tmp = platform_tmp.getInfo(WebCL.PLATFORM_NAME);\n      var priority_tmp = includeIndexOf(platform_priority, platform_info_tmp);\n      if (priority_tmp < priority) {\n        priority = priority_tmp;\n        platform_index = i;\n        $CL.platform = platform_tmp;\n        $CL.platform_info = platform_info_tmp;\n      }\n    }\n    $CL.platform = platform_list[platform_index];\n    $CL.platform_info = $CL.platform.getInfo(WebCL.PLATFORM_NAME);\n\n    try {\n      var device_type = WebCL.DEVICE_TYPE_GPU;\n      $CL.devices = $CL.platform.getDevices(device_type);//causes exception on firefox + Intel OpenCL\n    } catch (ex) {\n      $CL.devices = [];\n    }\n    if ($CL.devices.length === 0) {\n      device_type = WebCL.DEVICE_TYPE_CPU;\n      $CL.devices = $CL.platform.getDevices(device_type);;\n    }\n\n    // device selector (experimental)\n    var device_index = 0;\n    // selection by url (xxx?device_index=X)\n    var url_vars = function () {\n      var vars = {};\n      var param = location.search.substring(1).split('&');\n      for (var i = 0; i < param.length; i++) {\n        var keySearch = param[i].search(/=/);\n        var key = '';\n        if (keySearch != -1) key = param[i].slice(0, keySearch);\n        var val = param[i].slice(param[i].indexOf('=', 0) + 1);\n        if (key != '') vars[key] = decodeURI(val);\n      }\n      return vars;\n    } ();\n    device_index =\n      url_vars.device_index ?\n        Math.min(url_vars.device_index, $CL.devices.length - 1) :\n        0;\n    $CL.selected_device = $CL.devices[device_index];\n    $CL.device_info = $CL.selected_device.getInfo(WebCL.DEVICE_NAME);\n    $CL.device_max_work_group_size = $CL.selected_device.getInfo(WebCL.DEVICE_MAX_WORK_GROUP_SIZE);\n\n    // initialize methods dependent on implementation\n    WebCL.type = {\n      CHAR: 0,\n      UCHAR: 1,\n      SHORT: 2,\n      USHORT: 3,\n      INT: 4,\n      UINT: 5,\n      LONG: 6,\n      ULONG: 7,\n      FLOAT: 8,\n      HALF: 9,\n      DOUBLE: 10,\n      QUAD: 11,\n      LONG_LONG: 12,\n      VEC2: 65536,\n      VEC3: 131072,\n      VEC4: 262144,\n      VEC8: 524288,\n      VEC16: 1048576,\n      LOCAL_MEMORY_SIZE: 255\n    };\n\n    switch (env) {\n      case 'ff':\n        $CL.context = WebCL.createContext($CL.platform, device_type);\n        var table_primitive = {};\n        table_primitive[WebCL.type.CHAR] = Uint8Array;\n        table_primitive[WebCL.type.UCHAR] = Int8Array;\n        table_primitive[WebCL.type.SHORT] = Int16Array;\n        table_primitive[WebCL.type.USHORT] = Uint16Array;\n        table_primitive[WebCL.type.INT] = Int32Array;\n        table_primitive[WebCL.type.UINT] = Uint32Array;\n        table_primitive[WebCL.type.LONG] = Int32Array;//64bit variable is not supported\n        table_primitive[WebCL.type.ULONG] = Uint32Array;\n        table_primitive[WebCL.type.FLOAT] = Float32Array;\n        table_primitive[WebCL.type.HALF] = Float32Array;//16bit float is not supported\n        table_primitive[WebCL.type.DOUBLE] = Float64Array;\n        table_primitive[WebCL.type.QUAD] = Float32Array;//not supported\n        table_primitive[WebCL.type.LONG_LONG] = Float32Array;//not supported\n        var table_vec_len = {};\n        table_vec_len[0] = 1;\n        table_vec_len[WebCL.type.VEC2] = 2;\n        table_vec_len[WebCL.type.VEC3] = 3;\n        table_vec_len[WebCL.type.VEC4] = 4;\n        table_vec_len[WebCL.type.VEC8] = 8;\n        table_vec_len[WebCL.type.VEC16] = 16;\n        $CL.kernelSetArg = function (kernel, idx, param, type) {\n          if (type !== void 0) {\n            if (type == WebCL.type.LOCAL_MEMORY_SIZE) {\n              param = new Uint32Array([param]);\n            } else {\n              var primitive = type & 0xFF;\n              var array_ctor = table_primitive[primitive];\n              var vec = type & 0x1F0000;\n              var vec_len = table_vec_len[vec];\n              if (vec_len > 1) {\n                param = new array_ctor(param);//param is array\n              } else {\n                param = new array_ctor([param]);//param is scalar value\n              }\n            }\n          }\n          kernel.setArg(idx, param);\n        };\n        break;\n      case 'chromium':\n        //TODO\n        var properties = new WebCLContextProperties();\n        properties.platform = $CL.platform;\n        properties.deviceType = device_type;\n        properties.devices = $CL.devices;\n        properties.shareGroup = 1;\n        $CL.context = WebCL.createContext(properties);\n        $CL.kernelSetArg = function (kernel, idx, param, type) {\n          if (type !== void 0) {\n            switch (type) {\n              case WebCL.type.UINT:\n                var type_tmp = WebCL.KERNEL_ARG_UINT;\n                break;\n              case WebCL.type.INT:\n                var type_tmp = WebCL.KERNEL_ARG_INT;\n                break;\n              case WebCL.type.FLOAT:\n                var type_tmp = WebCL.KERNEL_ARG_FLOAT;\n                break;\n            }\n            kernel.setKernelArg(idx, param, type_tmp);\n          } else {\n            kernel.setKernelArgGlobal(idx, param);\n          }\n        };\n        break;\n    }\n\n    switch (env) {\n      case 'ff':\n        $CL.queue =\n          $CL.context.createCommandQueue($CL.selected_device, 0);\n        break;\n      case 'chromium':\n        $CL.queue =\n          $CL.context.createCommandQueue($CL.devices, null);\n        break;\n    }\n\n    $CL.buffers = 0;//number of existing buffers on device\n  }\n\n\n  function initUtilityMethods(WebCL) {\n    $CL.createKernel = function (code, name) {\n      if (!name) {\n        name = 'kernel_func';\n      }\n      var program = $CL.context.createProgram(code);\n      switch (env) {\n        case 'ff':\n          program.build($CL.devices);\n          break;\n        case 'chromium':\n          program.buildProgram(null, null, null);\n          break;\n      }\n      return program.createKernel(name);\n    };\n\n    $CL.createBuffer = function (byte_length) {\n      var buffer = $CL.context.createBuffer(WebCL.MEM_READ_WRITE, byte_length);\n      $CL.buffers++;\n      return buffer;\n    };\n\n    $CL.writeBuffer = function (buffer, typed_array, offset) {\n      if (offset === void 0) { offset = 0; }\n      if (typed_array.byteOffset === 0) {\n        $CL.queue.enqueueWriteBuffer(buffer,\n          true,//blocking write\n          offset,\n          typed_array.byteLength,\n          typed_array);\n      } else {\n        //workaround for firefox\n        var tmpbuf = new typed_array.constructor(typed_array);\n        $CL.queue.enqueueWriteBuffer(buffer,\n          true,//blocking write\n          offset,\n          tmpbuf.byteLength,\n          tmpbuf);\n      }\n    };\n\n    $CL.executeKernel = function (kernel, params, parallelization, localWS) {\n      for (var i = 0; i < params.length; i++) {\n        if (params[i].type === void 0) {\n          // Matrix class\n          $CL.kernelSetArg(kernel, i, params[i].datum._clbuffer);\n        } else {\n          // native type\n          $CL.kernelSetArg(kernel, i, params[i].datum, params[i].type);\n        }\n      }\n\n      // scalar to array\n      if (parallelization != null && parallelization.length === void 0) {\n        parallelization = [parallelization];\n      }\n      if (localWS != null && localWS.length === void 0) {\n        localWS = [localWS];\n      }\n\n      var globalWS;\n      if (localWS == null) {\n        //n-d parallelization\n        var localWS_each = [64, 64, 8, 4][parallelization.length];\n        localWS = [];\n        globalWS = [];\n        for (var i = 0; i < parallelization.length; i++) {\n          localWS.push(localWS_each);\n          globalWS.push(Math.ceil(parallelization[i] / localWS_each) * localWS_each);\n        }\n      } else {\n        globalWS = [];\n        for (var i = 0; i < parallelization.length; i++) {\n          globalWS.push(Math.ceil(parallelization[i] / localWS[i]) * localWS[i]);\n        }\n      }\n      // Execute kernel\n      switch (env) {\n        case 'ff':\n          $CL.queue.enqueueNDRangeKernel(kernel,\n            globalWS.length,\n            null,\n            globalWS,\n            localWS);\n          break;\n        case 'chromium':\n          globalWS = new Int32Array(globalWS);\n          $CL.queue.enqueueNDRangeKernel(kernel,\n            null,\n            globalWS,\n            localWS);\n          $CL.queue.finish();\n          break;\n      }\n      $CL.queue.flush();\n    };\n\n    $CL.flush = function () {\n      $CL.queue.flush();\n    };\n\n    $CL.finish = function () {\n      $CL.queue.finish();\n    };\n\n    $CL.readBuffer = function (buffer, typed_array, offset) {\n      if (offset === void 0) { offset = 0; }\n      if (typed_array.byteOffset === 0) {\n        $CL.queue.enqueueReadBuffer(buffer,\n          true,//blocks until the reading completes\n          offset,\n          typed_array.byteLength,\n          typed_array);\n      } else {\n        //workaround of bug in firefox webcl that byteOffset is ignored\n        var tmpbuf = new typed_array.constructor(typed_array.length);\n        $CL.queue.enqueueReadBuffer(buffer,\n          true,//blocks until the reading completes\n          offset,\n          tmpbuf.byteLength,\n          tmpbuf);\n        typed_array.set(tmpbuf);\n      }\n    }\n\n    switch (env) {\n      case 'ff':\n        $CL.releaseBuffer = function (buffer) {\n          buffer.release();\n          $CL.buffers--;\n        };\n        break;\n      case 'chromium':\n        $CL.releaseBuffer = function (buffer) {\n          buffer.releaseCL();\n          $CL.buffers--;\n        };\n        break;\n    }\n  }\n\n  module.exports = $CL;\n})();\n", "'use strict';\n// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\n\n(function () {\n  var $CL;\n  if (typeof window === 'undefined') {\n    $CL = require('./driver_opencl.js');\n  } else {\n    $CL = require('./driver_webcl.js');\n  }\n  \n  module.exports = $CL;\n})();\n", "// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\nimport Matrix = require('../matrix');\nimport Colon = require('../colon');\nimport typedef = require('../typedef');\nimport $CL = require('./handwrittenjs/driver');\nvar WebCL = $CL.WebCL;\n\nvar ctypes = { single: 'float', int32: 'int', uint8: 'uchar', logical: 'uchar' };\nvar webcltypes = { single: WebCL.type.FLOAT, int32: WebCL.type.INT, uint8: WebCL.type.UCHAR, logical: WebCL.type.UCHAR };\n\ntype AllowedTypedArray = typedef.AllowedTypedArray;\n\nclass MatrixCL extends Matrix {\n  _clbuffer: $CL.clBuffer;\n  static kernel_cache = {};\n  constructor(size: number[], klass?: string) {\n    super(size, klass, true);\n    var buffer_size = this._numel * this._data_ctor.BYTES_PER_ELEMENT;\n    if (this._numel == 0) {\n      // buffer of 0 byte cannot be constructed, but allocate buffer to avoid exception\n      buffer_size = 4;\n    }\n    this._clbuffer = $CL.createBuffer(buffer_size);\n  }\n\n  to_cpu(): Matrix {\n    var cpumat = new Matrix(this._size, this._klass);\n    this.read(cpumat._data);\n    return cpumat;\n  }\n\n  private throw_if_destructed() {\n    if (!this._clbuffer) {\n      throw new Error('Attempting use destructed matrix');\n    }\n  }\n\n  write(src_typed_array: any, dst_bytes_offset?: number) {\n    this.throw_if_destructed();\n    if (src_typed_array.length > 0) {\n      $CL.writeBuffer(this._clbuffer, src_typed_array, dst_bytes_offset);\n    }\n  }\n\n  read(dst_typed_array: any, src_bytes_offset?: number) {\n    this.throw_if_destructed();\n    if (dst_typed_array.length > 0) {\n      $CL.readBuffer(this._clbuffer, dst_typed_array, src_bytes_offset);\n    }\n  }\n\n  static _fromnativemat(A: Matrix): MatrixCL {\n    if (A instanceof MatrixCL) {\n      return <MatrixCL>A.copy();\n    } else {\n      var matcl = new MatrixCL(A._size, A._klass);\n      matcl.write(A._getdata());\n      return matcl;\n    }\n  }\n\n  static _fromtypedarray(src_typed_array: typedef.AllowedTypedArray, klass: string): MatrixCL {\n    var mat = new MatrixCL([1, src_typed_array.length], klass);\n    mat.write(src_typed_array);\n    return mat;\n  }\n\n  destruct() {\n    if (this._clbuffer) {\n      $CL.releaseBuffer(this._clbuffer);\n      this._clbuffer = null;\n    }\n  }\n\n  inspect(depth: number): string {\n    var shape_str = this._size.join('x');\n    if (this._numel <= 100) {\n      return 'MatrixCL ' + shape_str + ' ' + this._klass + '\\n' + this.toString();\n    } else {\n      return 'MatrixCL ' + shape_str + ' ' + this._klass;\n    }\n  }\n\n  _getdata(): typedef.AllowedTypedArray {\n    //get copy of data in TypedArray\n    var typed_array = new this._data_ctor(this._numel);\n    this.read(typed_array);\n    return typed_array;\n  }\n\n  getdataref(src_offset: number = 0, length?: number): typedef.AllowedTypedArray {\n    //get read-only view of array\n    // copy minimum range of gpu array\n    if (length == null) {\n      length = this._numel - src_offset;\n    }\n    var typed_array = new this._data_ctor(length);\n    this.read(typed_array, src_offset * this._data_ctor.BYTES_PER_ELEMENT);\n    return typed_array;\n  }\n\n  getdatacopy(src_offset: number = 0, length?: number, dst?: typedef.AllowedTypedArray): typedef.AllowedTypedArray {\n    if (length == null) {\n      length = this._numel - src_offset;\n    }\n    if (!dst) {\n      dst = new this._data_ctor(length);\n    }\n\n    var range_view = new this._data_ctor(dst.buffer, dst.byteOffset, length);\n    this.read(range_view, src_offset * this._data_ctor.BYTES_PER_ELEMENT);\n\n    return dst;\n  }\n\n  setdata(src: typedef.AllowedTypedArray, dst_offset: number = 0): void {\n    //set raw data into buffer\n    this.write(src, dst_offset * this._data_ctor.BYTES_PER_ELEMENT);\n  }\n\n  static get_cast_str(dst_klass: string, src_klass: string): string {\n    var cast_str: string;\n    if (src_klass == dst_klass) {\n      cast_str = '(x)';\n    } else if (dst_klass != 'logical') {\n      cast_str = '(' + dst_klass + ')(x)';\n    } else {\n      cast_str = '((x != 0) ? 1 : 0)';\n    }\n    return cast_str;\n  }\n\n  copy(klass?: string): Matrix {\n    var clone = new MatrixCL(this._size, klass || this._klass);\n    var kernel_name = 'copy_' + clone._klass + '_' + this._klass;\n    var kernel = MatrixCL.kernel_cache[kernel_name];\n    if (!kernel) {\n      kernel = $CL.createKernel([\n        '#define DST_TYPE ' + ctypes[clone._klass],\n        '#define SRC_TYPE ' + ctypes[this._klass],\n        '#define TYPE_CAST(x) ' + MatrixCL.get_cast_str(clone._klass, this._klass),\n        '__kernel void kernel_func(__global DST_TYPE *dst, __global SRC_TYPE *src, uint length) {',\n        '  uint i = get_global_id(0);',\n        '  if (i >= length) { return; }',\n        '  dst[i] = TYPE_CAST(src[i]);',\n        '}'\n      ].join('\\n'));\n      MatrixCL.kernel_cache[kernel_name] = kernel;\n    }\n\n    if (this._numel > 0) {\n      $CL.executeKernel(kernel, [\n        { access: WebCL.MEM_WRITE_ONLY, datum: clone },\n        { access: WebCL.MEM_READ_ONLY, datum: this },\n        { datum: this._numel, type: WebCL.type.UINT }\n      ], this._numel);\n    }\n    return clone;\n  }\n\n  _fill(val: number): void {\n    var kernel_name = 'fill_' + this._klass;\n    var kernel = MatrixCL.kernel_cache[kernel_name];\n    if (!kernel) {\n      kernel = $CL.createKernel([\n        '#define DST_TYPE ' + ctypes[this._klass],\n        '__kernel void kernel_func(__global DST_TYPE *dst, uint length, DST_TYPE val) {',\n        '  uint i = get_global_id(0);',\n        '  if (i >= length) { return; }',\n        '  dst[i] = val;',\n        '}'\n      ].join('\\n'));\n      MatrixCL.kernel_cache[kernel_name] = kernel;\n    }\n\n    if (this._numel > 0) {\n      $CL.executeKernel(kernel, [\n        { access: WebCL.MEM_WRITE_ONLY, datum: this },\n        { datum: this._numel, type: WebCL.type.UINT },\n        { datum: val, type: webcltypes[this._klass] }\n      ], this._numel);\n    }\n  }\n\n  get(): number;\n  get(...args: number[]): number;\n  get(...args: any[]): Matrix;\n  get(...args: any[]): any {\n    if (args.length == 0) {\n      // get scalar\n      return this.get_scalar([1]);\n    }\n    var all_number = args.every((v) => typeof (v) === 'number');\n    if (all_number) {\n      return this.get_scalar(args);\n    } else {\n      return this.get_matrix_nd(args);\n    }\n  }\n\n  get_scalar(inds: number[]): number {\n    this._isvalidindexerr(inds);\n    var arrayidx = this._getarrayindex(inds);\n    var dst_typed_array = new this._data_ctor(1);//read only 1 element\n    this.read(dst_typed_array, arrayidx * this._data_ctor.BYTES_PER_ELEMENT);\n    return dst_typed_array[0];\n  }\n\n  private static _get_ind_iterator_cl(ind: (number | Colon | Matrix), dim_size: number): { kernel_arg: { access?: any, datum: any, type?: any }, to_destruct: MatrixCL, length: number, typename: string } {\n    // return index within valid range\n    if (typeof (ind) === 'number') {\n      var ind_positive = <number>ind;\n      if (ind_positive < 0) {//end-xxx\n        ind_positive += dim_size + 1;\n      }\n      if (ind_positive <= 0 || ind_positive > dim_size) {\n        throw Error('Index exceeds matrix dimension');\n      }\n      return {\n        kernel_arg: { datum: ind_positive, type: webcltypes.int32 },\n        to_destruct: null, length: 1,\n        typename: 'int'\n      };\n    } else if (ind instanceof Colon) {\n      var start = ind.start;\n      var stop = ind.stop;\n      var step = ind.step;\n      if (ind.all) {\n        start = 1;\n        stop = dim_size;\n        step = 1;\n      }\n      if (start < 0) {\n        start += dim_size + 1;\n      }\n      if (stop < 0) {\n        stop += dim_size + 1;\n      }\n      var length: number = 0;\n      if ((step > 0 && stop >= start) || (step < 0 && stop <= start)) {\n        length = Math.floor((stop - start) / step) + 1;\n        // check if in valid range\n        var final_value = start + step * (length - 1);\n        if ((start <= 0 || start > dim_size) || (final_value <= 0 || final_value > dim_size)) {\n          throw Error('Index exceeds matrix dimension');\n        }\n      }\n      return {\n        kernel_arg: { datum: [start, step, stop, length], type: webcltypes.int32 | WebCL.type.VEC4 },\n        to_destruct: null,\n        length: length,\n        typename: 'int4'\n      }\n    } else if (ind instanceof Matrix) {\n      var to_destruct = null;\n      var ind_mat: MatrixCL;\n      if (ind instanceof MatrixCL) {\n        ind_mat = ind;\n      } else {\n        ind_mat = MatrixCL._fromnativemat(ind);\n        to_destruct = ind_mat;\n      }\n      // check if in valid range\n\n      var kernel_name = '_get_ind_iterator_cl_' + ind._klass;\n      var kernel = MatrixCL.kernel_cache[kernel_name];\n      if (!kernel) {\n        var kernel_str = [\n          '#define SRC_TYPE ' + ctypes[ind._klass],\n          '__kernel void kernel_func(__global int *dst, __global const SRC_TYPE *src, int dim_size, uint src_length) {',\n          '  uint i = get_global_id(0);',\n          '  if (i >= src_length) { return; }',\n          '  int src_val = (int)src[i];',\n          '  if (src_val == 0 || src_val > dim_size || src_val < -dim_size) {',\n          '    dst[0] = 1;',\n          '  }',\n          '}'\n        ].join('\\n');\n        kernel = $CL.createKernel(kernel_str);\n        MatrixCL.kernel_cache[kernel_name] = kernel;\n      }\n      if (ind_mat._numel > 0) {\n        var validity_result = new MatrixCL([1, 1], 'int32');\n        validity_result._fill(0);\n        $CL.executeKernel(kernel, [\n          { access: WebCL.MEM_WRITE_ONLY, datum: validity_result },\n          { access: WebCL.MEM_READ_ONLY, datum: ind_mat },\n          { datum: dim_size, type: WebCL.type.INT },\n          { datum: ind_mat._numel, type: WebCL.type.UINT }\n        ], ind_mat._numel);\n        if (validity_result.getdataref()[0]) {\n          validity_result.destruct();\n          if (to_destruct) {\n            to_destruct.destruct();\n          }\n          throw Error('Index exceeds matrix dimension');\n        }\n        validity_result.destruct();\n      }\n\n      return {\n        kernel_arg: { datum: ind_mat, access: WebCL.MEM_READ_ONLY },\n        to_destruct: to_destruct,\n        length: ind_mat._numel,\n        typename: '__global ' + ctypes[ind_mat._klass] + ' *'\n      }\n    }\n  }\n\n  get_matrix_nd(inds: (number | Colon | Matrix)[]): Matrix {\n    var inds_ndim = inds.length;\n    var destruct_targets: Matrix[] = [];\n    try {\n      // replace logical matrix with vector\n      for (var i = 0; i < inds_ndim; i++) {\n        var ind = inds[i];\n        if (ind instanceof Matrix) {\n          if (ind._klass == 'logical') {\n            var idxarray = ind._find();\n            inds[i] = idxarray\n            destruct_targets.push(idxarray);\n          }\n        }\n      }\n\n      var virtual_input_shape: number[] = [];\n      if (this._ndims <= inds_ndim) {\n        // pad with 1\n        virtual_input_shape = this._size.concat();\n        while (virtual_input_shape.length < inds_ndim) {\n          virtual_input_shape.push(1);\n        }\n      } else {\n        // last dimension is like linear index\n        let cur_prod = 1;\n        for (let dim = 0; dim < inds_ndim - 1; dim++) {\n          virtual_input_shape.push(this._size[dim]);\n          cur_prod *= this._size[dim];\n        }\n        virtual_input_shape.push(this._numel / cur_prod);\n      }\n      var virtual_input_stride: number[] = [];\n      var stride_tmp = 1;\n      for (var dim = 0; dim < inds_ndim; dim++) {\n        virtual_input_stride.push(stride_tmp);\n        stride_tmp *= virtual_input_shape[dim];\n      }\n\n      var kernel_args = [];\n      var kernel_type_names = [];\n      var dst_shape = [];\n      var dst_stride = [];//not use dst._strides because tailing 1 dimension is omitted\n      var dst_stride_tmp = 1;\n      for (var dim = 0; dim < inds_ndim; dim++) {\n        var iter_and_length = MatrixCL._get_ind_iterator_cl(inds[dim], virtual_input_shape[dim]);\n        if (iter_and_length.to_destruct) {\n          destruct_targets.push(iter_and_length.to_destruct);\n        }\n        kernel_args.push(iter_and_length.kernel_arg);\n        kernel_type_names.push(iter_and_length.typename);\n        dst_shape.push(iter_and_length.length);\n        dst_stride.push(dst_stride_tmp);\n        dst_stride_tmp *= iter_and_length.length;\n      }\n      var dst_numel = dst_stride_tmp;\n\n      var dst_reshape_shape = null;\n      if (inds_ndim == 1) {\n        // linear indexing case\n        dst_shape.push(1);//avoid error on new Matrix()\n        // if ind is logical matrix, regarded as vector in the following\n        // colon is row vector\n        // src and ind are both vectors => follows direction of src\n        // otherwise: follows ind's shape\n        var is_ind_vector = false;\n        var only_ind = inds[0];\n        if (only_ind instanceof Matrix) {\n          if (only_ind._ndims == 2 && (only_ind._size[0] == 1 || only_ind._size[1] == 1)) {\n            is_ind_vector = true;\n          }\n        } else if (only_ind instanceof Colon) {\n          is_ind_vector = true;\n        }\n        var is_src_vector = false;\n        if (this._ndims == 2 && (this._size[0] == 1 || this._size[1] == 1)) {\n          is_src_vector = true;\n        }\n\n        if (is_src_vector && is_ind_vector) {\n          // follow direction of src\n          if (this._size[0] == 1) {\n            // reshape to row vector\n            dst_reshape_shape = [1, dst_shape[0]];\n          }\n        } else {\n          // follow ind's shape\n          if (only_ind instanceof Matrix) {\n            dst_reshape_shape = only_ind._size;\n          } else if (only_ind instanceof Colon) {\n            // reshape to row vector\n            dst_reshape_shape = [1, dst_shape[0]];\n          }\n        }\n      }\n\n      var dst = new MatrixCL(dst_shape, this._klass);\n      var kernel_name = 'get_matrix_nd_' + this._klass + '_' + inds_ndim + '_' + kernel_type_names.join(',');\n      var kernel = MatrixCL.kernel_cache[kernel_name];\n      if (!kernel) {\n        var kernel_index_args_str = '';\n        for (var dim = 0; dim < inds_ndim; dim++) {\n          kernel_index_args_str += ',' + kernel_type_names[dim] + ' ind' + dim;//variable ind0, ind1, ...\n        }\n\n        var kernel_add_dim = '';\n        for (var dim = 0; dim < inds_ndim; dim++) {\n          kernel_add_dim += 'ADD_IND(' + dim + ');';\n        }\n\n        var kernel_get_ind_func = '';\n        for (var dim = 0; dim < inds_ndim; dim++) {\n          kernel_get_ind_func += 'int get_ind' + dim;\n          var kernel_type_name = kernel_type_names[dim];\n          switch (kernel_type_name) {\n            case 'int':\n              kernel_get_ind_func += '(int indexer, int offset, int dim_size) {return indexer;}';\n              break;\n            case 'int4':\n              kernel_get_ind_func += '(int4 indexer, int offset, int dim_size) {return indexer.x + indexer.y * offset;}';\n              break;\n            default:\n              kernel_get_ind_func += '(' + kernel_type_name + ' indexer, int offset, int dim_size) {int val = (int)indexer[offset]; if (val < 0) { return val + dim_size + 1; } else { return val; }}';\n              break;\n          }\n          kernel_get_ind_func += '\\n';\n        }\n\n        var kernel_str = [\n          '#define DIMS ' + inds_ndim,\n          '#define SRC_DST_TYPE ' + ctypes[this._klass],\n          kernel_get_ind_func,\n          '#define ADD_IND(dim) {dst_coord = (i / dst_stride[dim]) % dst_shape[dim]; src_coord = (get_ind ## dim(ind ## dim, dst_coord, src_shape[dim])) - 1; src_linear_index += src_coord * src_stride[dim];}',\n          '__kernel void kernel_func(__global SRC_DST_TYPE *dst, __global const SRC_DST_TYPE *src, __global const int *size_strides, uint output_length',\n          kernel_index_args_str,\n          ') {',\n          '  uint i = get_global_id(0);',\n          '  if (i >= output_length) { return; }',\n          '  __global const int *src_stride = size_strides, *src_shape = size_strides + DIMS * 1, *dst_stride = size_strides + DIMS * 2, *dst_shape = size_strides + DIMS * 3;',\n          '  int dst_coord, src_coord;',\n          '  int src_linear_index = 0;',\n          kernel_add_dim,\n          '  dst[i] = src[src_linear_index];',\n          '}'\n        ].join('\\n');\n        kernel = $CL.createKernel(kernel_str);\n\n        MatrixCL.kernel_cache[kernel_name] = kernel;\n      }\n\n      if (dst_numel > 0) {\n        var size_strides = [];//src_stride/src_shape/dst_stride/dst_shape; dst_shape is last because [1] may be added above\n        size_strides.push(...virtual_input_stride);\n        size_strides.push(...virtual_input_shape);\n        size_strides.push(...dst_stride);\n        size_strides.push(...dst_shape);\n\n        var size_strides_mat = MatrixCL._fromtypedarray(new Int32Array(size_strides), 'int32');\n        destruct_targets.push(size_strides_mat);\n\n        kernel_args.unshift({ access: WebCL.MEM_WRITE_ONLY, datum: dst },\n          { access: WebCL.MEM_READ_ONLY, datum: this },\n          { access: WebCL.MEM_READ_ONLY, datum: size_strides_mat },\n          { datum: dst_numel, type: WebCL.type.UINT });\n        $CL.executeKernel(kernel, kernel_args, dst_numel);\n\n      }\n\n      if (dst_reshape_shape) {\n        dst.reshape_inplace(dst_reshape_shape);\n      }\n\n      return dst;\n    } finally {\n      for (var i = 0; i < destruct_targets.length; i++) {\n        destruct_targets[i].destruct();\n      }\n    }\n  }\n\n  set(ind: number | Matrix | Colon, val: number | Matrix | any[]): void;\n  set(row: number | Matrix | Colon, col: number | Matrix | Colon, val: number | Matrix | any[]): void;\n  set(...args: any[]): void;\n  set(...args: any[]): void {\n    //last argument is value, but subsequent function requires first argument to be value\n    var val = args.pop();\n    if (!(val instanceof Matrix) && val.length !== void 0) {\n      // js array (or array-like)\n      val = Matrix.jsa2mat(val, false, this._klass);\n    }\n    // scalar matrix converted to number\n    if (val instanceof Matrix && val._numel == 1) {\n      val = (<Matrix>val).get_scalar([1]);\n    }\n\n    var all_number = args.every((v) => typeof (v) === 'number');\n    if (all_number) {\n      this.set_scalar(val, args);\n    } else {\n      this.set_matrix_nd(val, args);\n    }\n  }\n\n  set_scalar(val: number | Matrix, inds: number[]): void {\n    this._isvalidindexerr(inds);\n    var arrayidx = this._getarrayindex(inds);\n    var scalar_val: number;\n    if (val instanceof Matrix) {\n      if (val._numel != 1) {\n        throw new Error('Value is not scalar');\n      }\n      scalar_val = val.get_scalar([1]);\n    } else {\n      scalar_val = <number>val;\n    }\n\n    if (Matrix._logical_cast_required(this._klass)) {\n      scalar_val = Matrix._logical_cast(scalar_val);\n    }\n\n    var typed_array = new this._data_ctor(1);\n    typed_array[0] = scalar_val;\n    this.write(typed_array, arrayidx * this._data_ctor.BYTES_PER_ELEMENT);\n  }\n\n  static cast_scalar_val(val: number, klass: string): number {\n    switch (klass) {\n      case 'int32':\n        val = val | 0;\n        break;\n      case 'uint8':\n        val = val & 0xFF;\n        break;\n      case 'logical':\n        val = val ? 1 : 0;\n        break;\n    }\n    return val;\n  }\n\n  set_matrix_single(val: number | Matrix, singleind: Colon | Matrix): void {\n    var index_mat: MatrixCL;\n    var destruct_index_mat = true;\n    var val_mat: MatrixCL;\n    var destruct_val_mat = false;\n    var input_size: number[];\n    if (singleind instanceof Colon) {\n      var single_idx_array = singleind.tojsa(this._numel);\n      input_size = [1, single_idx_array.length];//row vector\n      index_mat = new MatrixCL(input_size, 'int32');\n      index_mat.write(new Int32Array(single_idx_array));\n    } else if (singleind instanceof MatrixCL) {\n      index_mat = singleind;\n      destruct_index_mat = false;\n    } else if (singleind instanceof Matrix) {\n      index_mat = MatrixCL._fromnativemat(singleind);\n    }\n\n    try {\n      if (val instanceof Matrix) {\n        if (index_mat._numel != val._numel) {\n          throw new Error('Dimension mismatch');\n        }\n\n        if (val instanceof MatrixCL) {\n          val_mat = val;\n        } else {\n          val_mat = MatrixCL._fromnativemat(val);\n          destruct_val_mat = true;\n        }\n\n        var kernel_name = 'set_matrix_single_matrix_' + this._klass + '_' + val_mat._klass + '_' + index_mat._klass;\n        var kernel = MatrixCL.kernel_cache[kernel_name];\n        if (!kernel) {\n          kernel = $CL.createKernel([\n            '#define SRC_TYPE ' + ctypes[val_mat._klass],\n            '#define DST_TYPE ' + ctypes[this._klass],\n            '#define INDEX_TYPE ' + ctypes[index_mat._klass],\n            '#define TYPE_CAST(x) ' + MatrixCL.get_cast_str(this._klass, val_mat._klass),\n            '__kernel void kernel_func(__global DST_TYPE *dst, __global SRC_TYPE *src, __global INDEX_TYPE *index, uint index_length) {',\n            '  uint i = get_global_id(0);',\n            '  if (i >= index_length) { return; }',\n            '  dst[(uint)index[i]-1] = TYPE_CAST(src[i]);',\n            '}'\n          ].join('\\n'));\n          MatrixCL.kernel_cache[kernel_name] = kernel;\n        }\n        if (index_mat._numel > 0) {\n          $CL.executeKernel(kernel, [\n            { access: WebCL.MEM_WRITE_ONLY, datum: this },\n            { access: WebCL.MEM_READ_ONLY, datum: val_mat },\n            { access: WebCL.MEM_READ_ONLY, datum: index_mat },\n            { datum: index_mat._numel, type: WebCL.type.UINT }\n          ], index_mat._numel);\n        }\n      } else {\n        var kernel_name = 'set_matrix_single_scalar_' + this._klass + '_' + index_mat._klass;\n        var kernel = MatrixCL.kernel_cache[kernel_name];\n        if (!kernel) {\n          kernel = $CL.createKernel([\n            '#define DST_TYPE ' + ctypes[this._klass],\n            '#define INDEX_TYPE ' + ctypes[index_mat._klass],\n            '__kernel void kernel_func(__global DST_TYPE *dst, DST_TYPE src, __global INDEX_TYPE *index, uint index_length) {',\n            '  uint i = get_global_id(0);',\n            '  if (i >= index_length) { return; }',\n            '  dst[(uint)index[i]-1] = src;',\n            '}'\n          ].join('\\n'));\n          MatrixCL.kernel_cache[kernel_name] = kernel;\n        }\n        var scalar_val = MatrixCL.cast_scalar_val(<number>val, this._klass);\n        if (index_mat._numel > 0) {\n          $CL.executeKernel(kernel, [\n            { access: WebCL.MEM_WRITE_ONLY, datum: this },\n            { datum: scalar_val, type: webcltypes[this._klass] },\n            { access: WebCL.MEM_READ_ONLY, datum: index_mat },\n            { datum: index_mat._numel, type: WebCL.type.UINT }\n          ], index_mat._numel);\n        }\n      }\n    } catch (error) {\n      throw error;\n    } finally {\n      if (destruct_index_mat) {\n        index_mat.destruct();\n      }\n    }\n\n  }\n\n\n  set_matrix_nd(val: number | Matrix, inds: (number | Colon | Matrix)[]): void {\n    var inds_ndim = inds.length;\n    var destruct_targets: Matrix[] = [];\n    try {\n      // replace logical matrix with vector\n      for (var i = 0; i < inds_ndim; i++) {\n        var ind = inds[i];\n        if (ind instanceof Matrix) {\n          if (ind._klass == 'logical') {\n            var idxarray = ind._find();\n            inds[i] = idxarray\n            destruct_targets.push(idxarray);\n          }\n        }\n      }\n\n      var virtual_input_shape: number[] = [];\n      if (this._ndims <= inds_ndim) {\n        // pad with 1\n        virtual_input_shape = this._size.concat();\n        while (virtual_input_shape.length < inds_ndim) {\n          virtual_input_shape.push(1);\n        }\n      } else {\n        // last dimension is like linear index\n        let cur_prod = 1;\n        for (let dim = 0; dim < inds_ndim - 1; dim++) {\n          virtual_input_shape.push(this._size[dim]);\n          cur_prod *= this._size[dim];\n        }\n        virtual_input_shape.push(this._numel / cur_prod);\n      }\n      var virtual_input_stride: number[] = [];\n      var stride_tmp = 1;\n      for (var dim = 0; dim < inds_ndim; dim++) {\n        virtual_input_stride.push(stride_tmp);\n        stride_tmp *= virtual_input_shape[dim];\n      }\n\n      var kernel_args = [];\n      var kernel_type_names = [];\n      var dst_shape = [];\n      var dst_stride = [];//not use dst._strides because tailing 1 dimension is omitted\n      var dst_stride_tmp = 1;\n      var squeezed_dst_shape = [];\n      for (var dim = 0; dim < inds_ndim; dim++) {\n        var iter_and_length = MatrixCL._get_ind_iterator_cl(inds[dim], virtual_input_shape[dim]);\n        if (iter_and_length.to_destruct) {\n          destruct_targets.push(iter_and_length.to_destruct);\n        }\n        kernel_args.push(iter_and_length.kernel_arg);\n        kernel_type_names.push(iter_and_length.typename);\n        dst_shape.push(iter_and_length.length);\n        if (iter_and_length.length != 1) {\n          squeezed_dst_shape.push(iter_and_length.length);\n        }\n        dst_stride.push(dst_stride_tmp);\n        dst_stride_tmp *= iter_and_length.length;\n      }\n      var dst_numel = dst_stride_tmp;\n\n      var val_is_matrix = false;\n      if (val instanceof Matrix) {\n        if ((<Matrix>val)._numel == 1) {\n          //1x1 mat: treat as scalar\n          val = (<Matrix>val).get();\n        } else {\n          val_is_matrix = true;\n          if (!(val instanceof MatrixCL)) {\n            // cpu matrix\n            val = MatrixCL._fromnativemat(<Matrix>val);\n            destruct_targets.push(<Matrix>val);\n          }\n        }\n      }\n\n      if (val_is_matrix) {\n        // check shape\n        // squeezed_dst_shape is 1-d, number of element must match\n        // otherwise, squeezed shape of val must match\n        var val_numel = (<Matrix>val)._numel;\n\n        var raise_error = false;\n        if (squeezed_dst_shape.length == 0) {\n          // set of scalar\n          if (val_numel != 1) {\n            raise_error = true;\n          }\n        } else if (squeezed_dst_shape.length == 1) {\n          if (val_numel != squeezed_dst_shape[0]) {\n            raise_error = true;\n          }\n        } else {\n          var val_shape = (<Matrix>val)._size;\n          var squeezed_val_shape = val_shape.filter((v) => v != 1);\n          if (!squeezed_val_shape.every((v, i) => v == squeezed_dst_shape[i])) {\n            raise_error = true;\n          }\n        }\n\n        if (raise_error) {\n          throw new Error('The shape of matrix does not fit');\n        }\n      }\n\n      var kernel_name = 'set_matrix_nd_' + this._klass + '_' + val_is_matrix + '_' + inds_ndim + '_' + kernel_type_names.join(',');\n      var kernel = MatrixCL.kernel_cache[kernel_name];\n      if (!kernel) {\n        var kernel_index_args_str = '';\n        for (var dim = 0; dim < inds_ndim; dim++) {\n          kernel_index_args_str += ',' + kernel_type_names[dim] + ' ind' + dim;//variable ind0, ind1, ...\n        }\n\n        var kernel_add_dim = '';\n        for (var dim = 0; dim < inds_ndim; dim++) {\n          kernel_add_dim += 'ADD_IND(' + dim + ');';\n        }\n\n        var kernel_get_ind_func = '';\n        for (var dim = 0; dim < inds_ndim; dim++) {\n          kernel_get_ind_func += 'int get_ind' + dim;\n          var kernel_type_name = kernel_type_names[dim];\n          switch (kernel_type_name) {\n            case 'int':\n              kernel_get_ind_func += '(int indexer, int offset, int dim_size) {return indexer;}';\n              break;\n            case 'int4':\n              kernel_get_ind_func += '(int4 indexer, int offset, int dim_size) {return indexer.x + indexer.y * offset;}';\n              break;\n            default:\n              kernel_get_ind_func += '(' + kernel_type_name + ' indexer, int offset, int dim_size) {int val = (int)indexer[offset]; if (val < 0) { return val + dim_size + 1; } else { return val; }}';\n              break;\n          }\n          kernel_get_ind_func += '\\n';\n        }\n\n        var kernel_str = [\n          '#define DIMS ' + inds_ndim,\n          '#define SRC_TYPE ' + ctypes[this._klass],\n          '#define DST_TYPE ' + ctypes[val_is_matrix ? (<Matrix>val)._klass : this._klass],\n          '#define TYPE_CAST(x) ' + MatrixCL.get_cast_str(this._klass, val_is_matrix ? (<Matrix>val)._klass : this._klass),\n          kernel_get_ind_func,\n          '#define ADD_IND(dim) {dst_coord = (i / dst_stride[dim]) % dst_shape[dim]; src_coord = (get_ind ## dim(ind ## dim, dst_coord, src_shape[dim])) - 1; src_linear_index += src_coord * src_stride[dim];}',\n          '__kernel void kernel_func(',\n          val_is_matrix ? '__global const DST_TYPE *dst' : 'DST_TYPE dst',\n          ', __global SRC_TYPE *src, __global const int *size_strides, uint output_length',\n          kernel_index_args_str,\n          ') {',\n          '  uint i = get_global_id(0);',\n          '  if (i >= output_length) { return; }',\n          '  __global const int *src_stride = size_strides, *src_shape = size_strides + DIMS * 1, *dst_stride = size_strides + DIMS * 2, *dst_shape = size_strides + DIMS * 3;',\n          '  int dst_coord, src_coord;',\n          '  int src_linear_index = 0;',\n          kernel_add_dim,\n          val_is_matrix ? '  src[src_linear_index] = TYPE_CAST(dst[i]);' : '  src[src_linear_index] = TYPE_CAST(dst);',\n          '}'\n        ].join('\\n');\n        kernel = $CL.createKernel(kernel_str);\n\n        MatrixCL.kernel_cache[kernel_name] = kernel;\n      }\n\n      if (dst_numel > 0) {\n        var size_strides = [];//src_stride/src_shape/dst_stride/dst_shape; dst_shape is last because [1] may be added above\n        size_strides.push(...virtual_input_stride);\n        size_strides.push(...virtual_input_shape);\n        size_strides.push(...dst_stride);\n        size_strides.push(...dst_shape);\n\n        var size_strides_mat = MatrixCL._fromtypedarray(new Int32Array(size_strides), 'int32');\n        destruct_targets.push(size_strides_mat);\n\n        kernel_args.unshift(\n          { access: WebCL.MEM_WRITE_ONLY, datum: this },\n          { access: WebCL.MEM_READ_ONLY, datum: size_strides_mat },\n          { datum: dst_numel, type: WebCL.type.UINT });\n        if (val_is_matrix) {\n          kernel_args.unshift({ access: WebCL.MEM_READ_ONLY, datum: val });\n        } else {\n          kernel_args.unshift({ datum: <number>val, type: webcltypes[this._klass] });\n        }\n        $CL.executeKernel(kernel, kernel_args, dst_numel);\n\n      }\n\n    } finally {\n      for (var i = 0; i < destruct_targets.length; i++) {\n        destruct_targets[i].destruct();\n      }\n    }\n  }\n\n  _find(): MatrixCL {\n    //not paralleled; very slow\n\n    //first, count output size\n    var count_mat = new MatrixCL([1, 2], 'int32');\n    var kernel_name = 'matrix_find_count_' + this._klass;\n    var kernel = MatrixCL.kernel_cache[kernel_name];\n    if (!kernel) {\n      kernel = $CL.createKernel([\n        '#define SRC_TYPE ' + ctypes[this._klass],\n        '__kernel void kernel_func(__global int *count, __global SRC_TYPE *logical_index, uint numel) {',\n        '  int ctr = 0;',\n        '  int max_i = -1;',\n        '  if (get_global_id(0) > 0) {return;}',\n        '  for (uint i = 0; i < numel; i++) {',\n        '    SRC_TYPE val = logical_index[i];',\n        '    if (val) {',\n        '      ctr++;',\n        '      max_i = i;',\n        '    }',\n        '  }',\n        '  count[0] = ctr;',\n        '  count[1] = max_i;',\n        '}'\n      ].join('\\n'));\n      MatrixCL.kernel_cache[kernel_name] = kernel;\n    }\n\n    var count_array = new Int32Array(2);//default value 0\n    if (this._numel > 0) {\n      $CL.executeKernel(kernel, [\n        { access: WebCL.MEM_WRITE_ONLY, datum: count_mat },\n        { access: WebCL.MEM_READ_ONLY, datum: this },\n        { datum: this._numel, type: WebCL.type.UINT }\n      ], 1);\n      count_mat.read(count_array);\n    }\n\n    var output_length = count_array[0];\n    var max_i = count_array[1];\n\n    //second, write indices\n    var output = new MatrixCL([output_length, 1], 'int32');\n    var kernel_name = 'matrix_find_write_' + this._klass;\n    var kernel = MatrixCL.kernel_cache[kernel_name];\n    if (!kernel) {\n      kernel = $CL.createKernel([\n        '#define SRC_TYPE ' + ctypes[this._klass],\n        '__kernel void kernel_func(__global int *dst, __global SRC_TYPE *src, uint output_length) {',\n        '  uint i = get_global_id(0);',\n        '  if (i > 0) { return; }',\n        '  int out_idx = 0;',\n        '  int in_idx = 0;',\n        '  while (out_idx < output_length) {',\n        '    if (src[in_idx]) {',\n        '      dst[out_idx++] = in_idx + 1;',\n        '    }',\n        '    in_idx++;',\n        '  }',\n        '}'\n      ].join('\\n'));\n      MatrixCL.kernel_cache[kernel_name] = kernel;\n    }\n\n    if (output_length > 0) {\n      $CL.executeKernel(kernel, [\n        { access: WebCL.MEM_WRITE_ONLY, datum: output },\n        { access: WebCL.MEM_READ_ONLY, datum: this },\n        { datum: output_length, type: WebCL.type.UINT }\n      ], 1);\n    }\n    if (this._size[1] == this._numel) {\n      // row vector\n      output.reshape_inplace(this._size);\n    }\n\n    count_mat.destruct();\n\n    return output;\n  }\n\n}\n\nexport = MatrixCL;\n", "'use strict';\r\n// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\r\n\r\nvar $M = require('../../sushi');\r\n\r\n(function () {\r\n  var $CL = require('./driver');\r\n  $M.CL = $CL;\r\n\r\n  var Matrix = require('../../matrix');\r\n  var MatrixCL = require('../matrix_cl');\r\n  var WebCL = $M.CL.WebCL;\r\n  var ctypes = { single: 'float', int32: 'int', uint8: 'uchar', logical: 'uchar' };\r\n  module.exports.ctypes = ctypes;\r\n  var webcltypes = { single: WebCL.type.FLOAT, int32: WebCL.type.INT, uint8: WebCL.type.UCHAR, logical: WebCL.type.UCHAR };\r\n  module.exports.webcltypes = webcltypes;\r\n  \r\n  // unify matrices into cpu / gpu, number is not changed\r\n  var unify_mats = function (inputs) {\r\n    // determine if MatrixCL exists\r\n    var matcl_exist = false;\r\n    for (var i = 0; i < inputs.length; i++) {\r\n      var mati = inputs[i];\r\n      if (mati instanceof MatrixCL) {\r\n        matcl_exist = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    var unified_mats = { cl: matcl_exist, length: inputs.length };\r\n    if (matcl_exist) {\r\n      // cast all Matrix into MatrixCL\r\n      for (var i = 0; i < inputs.length; i++) {\r\n        var mati = inputs[i];\r\n        if ((mati instanceof Matrix) && !(mati instanceof MatrixCL)) {\r\n          unified_mats[i] = MatrixCL._fromnativemat(mati);\r\n        } else {\r\n          unified_mats[i] = mati;\r\n        }\r\n      }\r\n    } else {\r\n      for (var i = 0; i < inputs.length; i++) {\r\n        var mati = inputs[i];\r\n        unified_mats[i] = mati;\r\n      }\r\n    }\r\n\r\n    return unified_mats;\r\n  }\r\n  \r\n  module.exports.unify_mats = unify_mats;\r\n\r\n  var unify_call = function (native_func, cl_func) {\r\n    //call function using specified arguments unified\r\n    var unified_mats = unify_mats(Array.prototype.slice.call(arguments, 2));\r\n    if (unified_mats.cl) {\r\n      return cl_func.apply(null, unified_mats);\r\n    } else {\r\n      return native_func.apply(null, unified_mats);\r\n    }\r\n  }\r\n\r\n  module.exports.unify_call = unify_call;\r\n})();\r\n", "'use strict';\n// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\n// overwrites binary arithmetic functions\n\nvar $M = require('../../sushi');\nvar util = require('../../util');\nvar util_cl = require('./util_cl');\n\n(function () {\n  var $CL = require('./driver');\n  $M.CL = $CL;\n\n  var Matrix = require('../../matrix');\n  var MatrixCL = require('../matrix_cl');\n  var WebCL = $M.CL.WebCL;\n  var ctypes = util_cl.ctypes;\n  var webcltypes = util_cl.webcltypes;\n\n  var binary_arith_cl = function (A, B, name, operator) {\n    var dst_klass = util.commonklass(A, B);\n    if (dst_klass == 'logical') {\n      dst_klass = 'single';\n    }\n    var left_type, right_type;\n    var left_scalar = null, right_scalar = null;\n    var left_isscalar = true, right_isscalar = true;\n    var kernel_param_a, kernel_param_b;\n    if (A instanceof Matrix) {\n      if (A._numel == 1) {\n        left_type = ctypes[dst_klass];\n        left_scalar = A.get();\n      } else {\n        left_type = '__global ' + ctypes[A._klass] + ' *';\n        kernel_param_a = { access: WebCL.MEM_READ_ONLY, datum: A };\n        left_isscalar = false;\n      }\n    } else {\n      left_type = ctypes[dst_klass];\n      left_scalar = A;\n    }\n    if (left_isscalar) {\n      kernel_param_a = { datum: MatrixCL.cast_scalar_val(left_scalar, dst_klass), type: webcltypes[dst_klass] };\n    }\n\n    if (B instanceof Matrix) {\n      if (B._numel == 1) {\n        right_type = ctypes[dst_klass];\n        right_scalar = B.get();\n      } else {\n        right_type = '__global ' + ctypes[B._klass] + ' *';\n        kernel_param_b = { access: WebCL.MEM_READ_ONLY, datum: B };\n        right_isscalar = false;\n      }\n    } else {\n      right_type = ctypes[dst_klass];\n      right_scalar = B;\n    }\n    if (right_isscalar) {\n      kernel_param_b = { datum: MatrixCL.cast_scalar_val(right_scalar, dst_klass), type: webcltypes[dst_klass] };\n    }\n\n    var kernel_name = 'binary_arith_cl_' + name + '_' + (left_isscalar || A._klass) + '_' + (right_isscalar || B._klass) + '_' + dst_klass;\n    var kernel = MatrixCL.kernel_cache[kernel_name];\n    if (!kernel) {\n      kernel = $CL.createKernel([\n        '#define LEFT_TYPE ' + left_type,\n        '#define RIGHT_TYPE ' + right_type,\n        '#define DST_TYPE ' + ctypes[dst_klass],\n        '#define LEFT_ACCESS(i) ' + (left_isscalar ? 'a' : 'a[(i)]'),\n        '#define RIGHT_ACCESS(i) ' + (right_isscalar ? 'b' : 'b[(i)]'),\n        '#define OPERATOR(left, right) ' + operator,\n        '__kernel void kernel_func(__global DST_TYPE *dst, LEFT_TYPE a, RIGHT_TYPE b, uint length) {',\n        '  uint i = get_global_id(0);',\n        '  if (i >= length) { return; }',\n        '  dst[i] = (DST_TYPE)OPERATOR(LEFT_ACCESS(i), RIGHT_ACCESS(i));',\n        '}'\n      ].join('\\n'));\n      MatrixCL.kernel_cache[kernel_name] = kernel;\n    }\n\n    var dst_size;\n    if (left_isscalar) {\n      if (right_isscalar) {\n        dst_size = [1, 1];\n      } else {\n        dst_size = B._size;\n      }\n    } else {\n      dst_size = A._size;\n      if (!right_isscalar) {\n        // both matrix; size check\n        if (!util.issamesize(A._size, B._size)) {\n          throw new Error('Dimension mismatch');\n        }\n      }\n    }\n\n    var dst = new MatrixCL(dst_size, dst_klass);\n    if (dst._numel > 0) {\n      $CL.executeKernel(kernel, [\n        { access: WebCL.MEM_WRITE_ONLY, datum: dst },\n        kernel_param_a,\n        kernel_param_b,\n        { datum: dst._numel, type: WebCL.type.UINT }],\n        dst._numel);\n    }\n    return dst;\n  }\n\n  var subsitute_binary_arith = function (name, operator) {\n    var func_native = $M[name];\n    var func_cl = function (A, B) {\n      return binary_arith_cl(A, B, name, operator);\n    };\n    $M[name] = function (A, B) {\n      var ret = $M.autodestruct(function () {\n        return util_cl.unify_call(func_native, func_cl, A, B);\n      });\n      return ret;\n    };\n  }\n  subsitute_binary_arith('plus', '((left) + (right))');\n  subsitute_binary_arith('minus', '((left) - (right))');\n  subsitute_binary_arith('times', '((left) * (right))');\n  subsitute_binary_arith('rdivide', '((left) / (right))');\n  subsitute_binary_arith('ldivide', '((right) / (left))');\n  subsitute_binary_arith('power', '(pow((float)(left), (float)(right)))');\n  $M.CL._max_elementwise_cl = function (A, B) {\n    return binary_arith_cl(A, B, 'max_elementwise_cl', '(((left) > (right)) ? (left) : (right))');\n  };\n  $M.CL._min_elementwise_cl = function (A, B) {\n    return binary_arith_cl(A, B, 'min_elementwise_cl', '(((left) < (right)) ? (left) : (right))');\n  };\n\n\n  var compare_cl = function (A, B, name, operator) {\n    var dst_klass = util.commonklass(A, B);\n    var left_type, right_type;\n    var left_scalar = null, right_scalar = null;\n    var left_isscalar = true, right_isscalar = true;\n    var kernel_param_a, kernel_param_b;\n    if (A instanceof Matrix) {\n      if (A._numel == 1) {\n        left_type = ctypes[dst_klass];\n        left_scalar = A.get();\n      } else {\n        left_type = '__global ' + ctypes[A._klass] + ' *';\n        kernel_param_a = { access: WebCL.MEM_READ_ONLY, datum: A };\n        left_isscalar = false;\n      }\n    } else {\n      left_type = ctypes[dst_klass];\n      left_scalar = A;\n    }\n    if (left_isscalar) {\n      kernel_param_a = { datum: MatrixCL.cast_scalar_val(left_scalar, dst_klass), type: webcltypes[dst_klass] };\n    }\n\n    if (B instanceof Matrix) {\n      if (B._numel == 1) {\n        right_type = ctypes[dst_klass];\n        right_scalar = B.get();\n      } else {\n        right_type = '__global ' + ctypes[B._klass] + ' *';\n        kernel_param_b = { access: WebCL.MEM_READ_ONLY, datum: B };\n        right_isscalar = false;\n      }\n    } else {\n      right_type = ctypes[dst_klass];\n      right_scalar = B;\n    }\n    if (right_isscalar) {\n      kernel_param_b = { datum: MatrixCL.cast_scalar_val(right_scalar, dst_klass), type: webcltypes[dst_klass] };\n    }\n\n    var kernel_name = 'compare_cl_' + name + '_' + (left_isscalar || A._klass) + '_' + (right_isscalar || B._klass);\n    var kernel = MatrixCL.kernel_cache[kernel_name];\n    if (!kernel) {\n      kernel = $CL.createKernel([\n        '#define LEFT_TYPE ' + left_type,\n        '#define RIGHT_TYPE ' + right_type,\n        '#define LEFT_ACCESS(i) ' + (left_isscalar ? 'a' : 'a[(i)]'),\n        '#define RIGHT_ACCESS(i) ' + (right_isscalar ? 'b' : 'b[(i)]'),\n        '#define OPERATOR(left, right) ' + operator,\n        '__kernel void kernel_func(__global uchar *dst, LEFT_TYPE a, RIGHT_TYPE b, uint length) {',\n        '  uint i = get_global_id(0);',\n        '  if (i >= length) { return; }',\n        '  dst[i] = OPERATOR(LEFT_ACCESS(i), RIGHT_ACCESS(i));',\n        '}'\n      ].join('\\n'));\n      MatrixCL.kernel_cache[kernel_name] = kernel;\n    }\n\n    var dst_size;\n    if (left_isscalar) {\n      if (right_isscalar) {\n        dst_size = [1, 1];\n      } else {\n        dst_size = B._size;\n      }\n    } else {\n      dst_size = A._size;\n      if (!right_isscalar) {\n        // both matrix; size check\n        if (!util.issamesize(A._size, B._size)) {\n          throw new Error('Dimension mismatch');\n        }\n      }\n    }\n\n    var dst = new MatrixCL(dst_size, 'logical');\n    if (dst._numel > 0) {\n      $CL.executeKernel(kernel, [\n        { access: WebCL.MEM_WRITE_ONLY, datum: dst },\n        kernel_param_a,\n        kernel_param_b,\n        { datum: dst._numel, type: WebCL.type.UINT }],\n        dst._numel);\n    }\n    return dst;\n  };\n\n  var subsitute_compare = function (name, operator) {\n    var func_native = $M[name];\n    var func_cl = function (A, B) {\n      return compare_cl(A, B, name, operator);\n    };\n    $M[name] = function (A, B) {\n      var ret = $M.autodestruct(function () {\n        return util_cl.unify_call(func_native, func_cl, A, B);\n      });\n      return ret;\n    };\n  };\n\n  subsitute_compare('eq', '((left) == (right))');\n  subsitute_compare('ge', '((left) >= (right))');\n  subsitute_compare('gt', '((left) > (right))');\n  subsitute_compare('le', '((left) <= (right))');\n  subsitute_compare('lt', '((left) < (right))');\n  subsitute_compare('ne', '((left) != (right))');\n\n  var isequal_cl_both = function (mats, nan_equal) {\n    var A = mats[0];\n    var eqmat = new MatrixCL([1, 1], 'logical');\n    eqmat.set(1, 0);\n    for (var i = 1; i < mats.length; i++) {\n      var B = mats[i];\n      if (!util.issamesize(A._size, B._size)) {\n        return false;\n      }\n\n      var kernel_name = 'isequal_cl_' + A._klass + '_' + B._klass + '_' + nan_equal;\n      var kernel = MatrixCL.kernel_cache[kernel_name];\n      if (!kernel) {\n        var condition = 'aval != bval';\n        if (nan_equal) {\n          if (A._klass === 'single' && B._klass === 'single') {\n            condition += '&& !(isnan(aval) && isnan(bval))';//become false if both is nan\n          }\n        }\n\n        kernel = $CL.createKernel([\n          '#define LEFT_TYPE ' + ctypes[A._klass],\n          '#define RIGHT_TYPE ' + ctypes[B._klass],\n          '__kernel void kernel_func(__global uchar *dst, __global LEFT_TYPE *a, __global RIGHT_TYPE *b, uint length) {',\n          '  uint i = get_global_id(0);',\n          '  if (i >= length) { return; }',\n          '  LEFT_TYPE aval = a[i];',\n          '  RIGHT_TYPE bval = b[i];',\n          '  if (' + condition + ') {*dst = 1;}',\n          '}'\n        ].join('\\n'));\n        MatrixCL.kernel_cache[kernel_name] = kernel;\n      }\n\n      if (A._numel > 0) {\n        $CL.executeKernel(kernel, [\n          { access: WebCL.MEM_WRITE_ONLY, datum: eqmat },\n          { access: WebCL.MEM_READ_ONLY, datum: A },\n          { access: WebCL.MEM_READ_ONLY, datum: B },\n          { datum: A._numel, type: WebCL.type.UINT }],\n          A._numel);\n      }\n      if (eqmat.get()) {\n        //non-equal value found\n        return false;\n      }\n    }\n    return true;\n  };\n\n  var isequal_cl = function () {\n    return isequal_cl_both(arguments, false);\n  };\n\n  var isequaln_cl = function () {\n    return isequal_cl_both(arguments, true);\n  }\n\n  var isequal_native = $M.isequal;\n  $M.isequal = function () {\n    var mats = arguments;//variable length input\n    var ret = $M.autodestruct(function () {\n      // Array.concat does not work on array-like (arguments)\n      var unify_call_args = [isequal_native, isequal_cl];\n      Array.prototype.push.apply(unify_call_args, mats);\n      return util_cl.unify_call.apply(null, unify_call_args);\n    });\n    return ret;\n  };\n  \n  var isequaln_native = $M.isequaln;\n  $M.isequaln = function () {\n    var mats = arguments;\n    var ret = $M.autodestruct(function () {\n      var unify_call_args = [isequaln_native, isequaln_cl];\n      Array.prototype.push.apply(unify_call_args, mats);\n      return util_cl.unify_call.apply(null, unify_call_args);\n    });\n    return ret;\n  };\n\n})();\n", "'use strict';\n// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\n// overwrites unary arithmetic functions\n\nvar $M = require('../../sushi');\nvar util = require('../../util');\nvar util_cl = require('./util_cl');\n\n(function () {\n  var $CL = require('./driver');\n  $M.CL = $CL;\n\n  var Matrix = require('../../matrix');\n  var MatrixCL = require('../matrix_cl');\n  var WebCL = $M.CL.WebCL;\n  var ctypes = util_cl.ctypes;\n  var webcltypes = util_cl.webcltypes;\n\n  var unary_arith_cl = function (A, name, operator) {\n    // A is MatrixCL (not number)\n    var dst_klass = A._klass;\n    if (dst_klass == 'logical') {\n      dst_klass = 'single';\n    }\n\n    var kernel_name = 'unary_arith_cl_' + name + '_' + A._klass + '_' + dst_klass;\n    var kernel = MatrixCL.kernel_cache[kernel_name];\n    if (!kernel) {\n      kernel = $CL.createKernel([\n        '#define SRC_TYPE  ' + ctypes[A._klass],\n        '#define DST_TYPE ' + ctypes[dst_klass],\n        '#define OPERATOR(left) ' + operator,\n        '__kernel void kernel_func(__global DST_TYPE *dst, __global SRC_TYPE *a, uint length) {',\n        '  uint i = get_global_id(0);',\n        '  if (i >= length) { return; }',\n        '  dst[i] = (DST_TYPE)OPERATOR(a[i]);',\n        '}'\n      ].join('\\n'));\n      MatrixCL.kernel_cache[kernel_name] = kernel;\n    }\n\n    var dst = new MatrixCL(A._size, dst_klass);\n    if (dst._numel > 0) {\n      $CL.executeKernel(kernel, [\n        { access: WebCL.MEM_WRITE_ONLY, datum: dst },\n        {access:WebCL.MEM_READ_ONLY,datum:A},\n        { datum: dst._numel, type: WebCL.type.UINT }],\n        dst._numel);\n    }\n    return dst;\n  }\n\n  var subsitute_unary_arith = function (name, operator) {\n    var func_native = $M[name];\n    var func_cl = function (A) {\n      return unary_arith_cl(A, name, operator);\n    };\n    $M[name] = function (A) {\n      if (A instanceof MatrixCL) {\n        return func_cl(A);\n      } else {\n        return func_native(A);\n      }\n    };\n  }\n  subsitute_unary_arith('uplus', '(left)');\n  subsitute_unary_arith('uminus', '-(left)');\n  subsitute_unary_arith('floor', 'floor((float)(left))');\n  subsitute_unary_arith('fix', '((left) > 0 ? floor((float)(left)): ceil((float)(left)))');\n  subsitute_unary_arith('ceil', 'ceil((float)(left))');\n  subsitute_unary_arith('exp', 'exp((float)(left))');\n  subsitute_unary_arith('log', 'log((float)(left))');\n\n})();\n", "'use strict';\n// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\n// overwrites shape conversion functions\n\nvar $M = require('../../sushi');\nvar util = require('../../util');\nvar util_cl = require('./util_cl');\n\n\n(function () {\n  var $CL = require('./driver');\n  $M.CL = $CL;\n\n  var Matrix = require('../../matrix');\n  var MatrixCL = require('../matrix_cl');\n  var WebCL = $M.CL.WebCL;\n  var ctypes = util_cl.ctypes;\n  var webcltypes = util_cl.webcltypes;\n\n  var transpose_native = $M.transpose;\n  var transpose_cl = function (A) {\n    if (A._ndims != 2) {\n      throw new Error('Matrix must be two-dimensional');\n    }\n\n    var dst_cols = A._size[0], dst_rows = A._size[1];\n    var dst = new MatrixCL([dst_rows, dst_cols], A._klass);\n\n    \n    if (dst_cols % 64 == 0 && dst_rows % 64 == 0) {\n      var kernel_name = 'transpose_cl_' + A._klass + '_64';\n      var kernel = MatrixCL.kernel_cache[kernel_name];\n      var tile_size = 64;\n      var block_size = 16;\n      if (!kernel) {\n        kernel = $CL.createKernel([\n          '#define SRC_DST_TYPE ' + ctypes[A._klass],\n          '#define TILE_SIZE ' + tile_size,\n          '#define BLOCK_SIZE ' + block_size,\n          '__kernel void kernel_func(__global SRC_DST_TYPE *dst, __global SRC_DST_TYPE *src,',\n          'uint dst_rows, uint dst_cols)',\n          '{',\n          'uint r0 = get_group_id(0);',\n          'uint r1 = get_group_id(1);',\n          //'uint l0 = get_local_id(0);',\n          'uint l1 = get_local_id(1);',\n          '__local SRC_DST_TYPE block_cache[BLOCK_SIZE][BLOCK_SIZE];',\n          'for (int tile_x = 0; tile_x < (TILE_SIZE / BLOCK_SIZE); tile_x++) {',\n          'for (int tile_y = 0; tile_y < (TILE_SIZE / BLOCK_SIZE); tile_y++) {',\n          'for (int i = 0; i < BLOCK_SIZE; i++) {',\n          'block_cache[l1][i] = src[(r0 * TILE_SIZE + tile_x * BLOCK_SIZE + l1)+(r1 * TILE_SIZE + tile_y * BLOCK_SIZE + i)*dst_cols];',\n          '}',\n          'barrier(CLK_LOCAL_MEM_FENCE);',\n          'for (int i = 0; i < BLOCK_SIZE; i++) {',\n          'dst[(r1 * TILE_SIZE + tile_y * BLOCK_SIZE + l1) + (r0 * TILE_SIZE + tile_x * BLOCK_SIZE + i) * dst_rows] = block_cache[i][l1];',\n          '}',\n          'barrier(CLK_LOCAL_MEM_FENCE);',\n          '}',\n          '}',\n          '}'\n        ].join('\\n'));\n        MatrixCL.kernel_cache[kernel_name] = kernel;\n      }\n\n      if (dst._numel > 0) {\n        $CL.executeKernel(kernel, [\n          { access: WebCL.MEM_WRITE_ONLY, datum: dst },\n          { access: WebCL.MEM_READ_ONLY, datum: A },\n          { datum: dst_rows, type: WebCL.type.UINT },\n          { datum: dst_cols, type: WebCL.type.UINT }\n        ], [dst_cols / tile_size, dst_rows / (tile_size / block_size)], [1, block_size]);\n      }\n    } else if (dst_cols % 16 == 0 && dst_rows % 16 == 0) {\n      var kernel_name = 'transpose_cl_' + A._klass + '_16';\n      var kernel = MatrixCL.kernel_cache[kernel_name];\n      var block_size = 16;\n      if (!kernel) {\n        kernel = $CL.createKernel([\n          '#define SRC_DST_TYPE ' + ctypes[A._klass],\n          '#define BLOCK_SIZE ' + block_size,\n          '__kernel void kernel_func(__global SRC_DST_TYPE *dst, __global SRC_DST_TYPE *src,',\n          'uint dst_rows, uint dst_cols)',\n          '{',\n          'uint r0 = get_group_id(0);',\n          'uint r1 = get_group_id(1);',\n          //'uint l0 = get_local_id(0);',\n          'uint l1 = get_local_id(1);',\n          '__local SRC_DST_TYPE block_cache[BLOCK_SIZE][BLOCK_SIZE];',\n          'for (int i = 0; i < BLOCK_SIZE; i++) {',\n          'block_cache[l1][i] = src[(r0 * BLOCK_SIZE + l1)+(r1 * BLOCK_SIZE + i)*dst_cols];',\n          '}',\n          'barrier(CLK_LOCAL_MEM_FENCE);',\n          'for (int i = 0; i < BLOCK_SIZE; i++) {',\n          'dst[(r1 * BLOCK_SIZE + l1) + (r0 * BLOCK_SIZE + i) * dst_rows] = block_cache[i][l1];',\n          '}',\n          '}'\n        ].join('\\n'));\n        MatrixCL.kernel_cache[kernel_name] = kernel;\n      }\n\n      if (dst._numel > 0) {\n        $CL.executeKernel(kernel, [\n          { access: WebCL.MEM_WRITE_ONLY, datum: dst },\n          { access: WebCL.MEM_READ_ONLY, datum: A },\n          { datum: dst_rows, type: WebCL.type.UINT },\n          { datum: dst_cols, type: WebCL.type.UINT }\n        ], [dst_cols / block_size, dst_rows], [1, block_size]);\n      }\n    } else {\n      var kernel_name = 'transpose_cl_' + A._klass;\n      var kernel = MatrixCL.kernel_cache[kernel_name];\n      if (!kernel) {\n        kernel = $CL.createKernel([\n          '#define SRC_DST_TYPE ' + ctypes[A._klass],\n          '__kernel void kernel_func(__global SRC_DST_TYPE *dst, __global SRC_DST_TYPE *src,',\n          'uint dst_rows, uint dst_cols, uint length)',\n          '{',\n          'uint i = get_global_id(0);',\n          'if (i >= length) {return;}',\n          'uint dst_row = i % dst_rows, dst_col = i / dst_rows;',\n          'dst[i] = src[dst_row * dst_cols + dst_col];',\n          '}'\n        ].join('\\n'));\n        MatrixCL.kernel_cache[kernel_name] = kernel;\n      }\n\n      if (dst._numel > 0) {\n        $CL.executeKernel(kernel, [\n          { access: WebCL.MEM_WRITE_ONLY, datum: dst },\n          { access: WebCL.MEM_READ_ONLY, datum: A },\n          { datum: dst_rows, type: WebCL.type.UINT },\n          { datum: dst_cols, type: WebCL.type.UINT },\n          { datum: dst._numel, type: WebCL.type.UINT }\n        ], dst._numel);\n      }\n\n    }\n\n    return dst;\n  };\n\n  $M.transpose = function (A) {\n    if (A instanceof MatrixCL) {\n      return transpose_cl(A);\n    } else {\n      return transpose_native(A);\n    }\n  }\n  $M.t = $M.transpose;\n\n  var repmat_native = $M.repmat;\n  var repmat_cl = function (A) {\n    //convert to Array\n    var _rs;//number of repetion for each dim\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n    var first_arg = args[0];\n    if (first_arg instanceof Matrix) {\n      var tarray = first_arg._getdata();\n      _rs = Array.prototype.slice.call(tarray);\n    } else if (first_arg.length !== void 0) {\n      _rs = Array.prototype.slice.call(first_arg);\n    } else {\n      _rs = Array.prototype.slice.call(args);\n    }\n    if (_rs.length === 1) {\n      //[2] => [2,2]\n      _rs.push(_rs[0]);\n    }\n\n    while (_rs.length < A._ndims) {\n      _rs.push(1);\n    }\n\n    // remove tailing 1\n    while ((_rs.length > A._ndims) && (_rs[_rs.length - 1] == 1)) {\n      _rs.pop();\n    }\n\n    var newdims = _rs.length;\n    var newsize = [];\n    var input_strides = new Int32Array(newdims + 1);\n    var output_strides = new Int32Array(newdims + 1);\n    var tmp_in_stride = 1;\n    var tmp_out_stride = 1;\n    var n_copy = 1;\n    var rs_strides = [];\n    for (var dim = 0; dim < newdims; dim++) {\n      var indimsize = A._ndims > dim ? A._size[dim] : 1;\n      var outdimsize = indimsize * _rs[dim];\n      rs_strides.push(n_copy);\n      n_copy *= _rs[dim];\n      newsize.push(outdimsize);\n      input_strides[dim] = (tmp_in_stride);\n      output_strides[dim] = (tmp_out_stride);\n      tmp_in_stride *= indimsize;\n      tmp_out_stride *= outdimsize;\n    }\n    input_strides[newdims] = (tmp_in_stride);//dummy\n    rs_strides.push(n_copy);//dummy\n\n    var output_steps = new Int32Array(n_copy);\n    for (var i = 0; i < n_copy; i++) {\n      var out_offset = 0;\n      for (var dim = 0; dim < newdims; dim++) {\n        out_offset += Math.floor(i % rs_strides[dim + 1] / rs_strides[dim]) * output_strides[dim] * (A._size[dim] || 1);\n      }\n      output_steps[i] = (out_offset);\n    }\n\n    var dst = new MatrixCL(newsize, A._klass);\n    var kernel_name = 'repmat_cl_' + newdims + '_' + A._klass;\n    var kernel = MatrixCL.kernel_cache[kernel_name];\n    if (!kernel) {\n      kernel = $CL.createKernel([\n        '#define DIMS ' + newdims,\n        '#define SRC_DST_TYPE ' + ctypes[A._klass],\n        '__kernel void kernel_func(__global SRC_DST_TYPE *dst, __global SRC_DST_TYPE *src,',\n        '__global int *input_strides, __global int *output_strides, __global int *output_steps,',\n        'uint n_copy, uint length)',\n        '{',\n        'uint i = get_global_id(0);',\n        'if (i >= length) {return;}',\n        'int out_offset = 0;',\n        'SRC_DST_TYPE val = src[i];',\n        'for (int dim = 0; dim < DIMS; dim++) {',\n        '  out_offset += i % input_strides[dim+1] / input_strides[dim] * output_strides[dim];',\n        '}',\n        'for (int j = 0; j < n_copy; j++) {',\n        '  dst[out_offset + output_steps[j]] = val;',\n        '}',\n        '}'\n      ].join('\\n'));\n      MatrixCL.kernel_cache[kernel_name] = kernel;\n    }\n\n    if (dst._numel > 0) {\n      var input_strides_mat = MatrixCL._fromtypedarray(input_strides, 'int32');\n      var output_strides_mat = MatrixCL._fromtypedarray(output_strides, 'int32');\n      var output_steps_mat = MatrixCL._fromtypedarray(output_steps, 'int32');\n      $CL.executeKernel(kernel, [\n        { access: WebCL.MEM_WRITE_ONLY, datum: dst },\n        { access: WebCL.MEM_READ_ONLY, datum: A },\n        { access: WebCL.MEM_READ_ONLY, datum: input_strides_mat },\n        { access: WebCL.MEM_READ_ONLY, datum: output_strides_mat },\n        { access: WebCL.MEM_READ_ONLY, datum: output_steps_mat },\n        { datum: n_copy, type: WebCL.type.UINT },\n        { datum: A._numel, type: WebCL.type.UINT }\n      ], A._numel);\n      input_strides_mat.destruct();\n      output_strides_mat.destruct();\n      output_steps_mat.destruct();\n    }\n\n    return dst;\n  };\n\n  $M.repmat = function (A) {\n    if (A instanceof MatrixCL) {\n      return repmat_cl.apply(null, arguments);\n    } else {\n      return repmat_native.apply(null, arguments);\n    }\n  };\n\n  var permute_native = $M.permute;\n  var permute_cl = function (A, order) {\n    var src_size = A._size.concat();\n    var numel = A._numel;\n    if (order.length < src_size.length) {\n      throw Error('order must include at least input dimension');\n    }\n    var ndim = order.length;\n    var src_strides = A._strides.concat();\n    while (src_size.length < ndim) {\n      //append dimension of 1\n      src_size.push(1);\n      src_strides.push(numel);\n    }\n    var dst_size = [];\n    for (var d = 0; d < ndim; d++) {\n      var element = order[d] - 1;//order start from 1\n      dst_size.push(src_size[element]);\n    }\n\n    var dst = new MatrixCL(dst_size, A._klass);\n    var dst_strides = dst._strides.concat();\n    while (dst_strides.length < ndim) {\n      // occur when last dimensions are 1\n      dst_strides.push(numel);\n    }\n    var dst_strides_perm = [];\n    for (var i = 0; i < order.length; i++) {\n      var o = order[i];\n      dst_strides_perm[o - 1] = dst_strides[i];\n    }\n    //order.forEach((o, i) => dst_strides_perm[o - 1] = dst_strides[i]);//ES6\n    var perm_stride = MatrixCL._fromtypedarray(new Int32Array(src_strides.concat(src_size, dst_strides_perm)), 'int32');\n\n    var kernel_name = 'permute_cl_' + A._klass + '_' + ndim;\n    var kernel = MatrixCL.kernel_cache[kernel_name];\n    if (!kernel) {\n      kernel = $CL.createKernel([\n        '#define SRC_DST_TYPE ' + ctypes[A._klass],\n        '#define DIMS ' + ndim,\n        '__kernel void kernel_func(__global SRC_DST_TYPE *dst, __global const SRC_DST_TYPE *src,',\n        '__global const int *perm_stride, uint length)',\n        '{',\n        'uint i = get_global_id(0);',\n        'if (i >= length) {return;}',\n        '__global int *src_strides = perm_stride;',\n        '__global int *src_size = perm_stride + DIMS;',\n        '__global int *dst_strides_perm = perm_stride + DIMS * 2;',\n        'uint dst_idx = 0;',\n        'for (int dim = 0; dim < DIMS; dim++) {',\n        '  dst_idx += i / src_strides[dim] % src_size[dim] * dst_strides_perm[dim];',\n        '}',\n        'dst[dst_idx] = src[i];',\n        '}'\n      ].join('\\n'));\n      MatrixCL.kernel_cache[kernel_name] = kernel;\n    }\n\n    if (dst._numel > 0) {\n      $CL.executeKernel(kernel, [\n        { access: WebCL.MEM_WRITE_ONLY, datum: dst },\n        { access: WebCL.MEM_READ_ONLY, datum: A },\n        { access: WebCL.MEM_READ_ONLY, datum: perm_stride },\n        { datum: dst._numel, type: WebCL.type.UINT }\n      ], dst._numel, 256);\n    }\n\n    perm_stride.destruct();\n\n    return dst;\n  };\n\n  $M.permute = function (A, order) {\n    if (A instanceof MatrixCL) {\n      return permute_cl(A, order);\n    } else {\n      return permute_native(A, order);\n    }\n  };\n\n  var ipermute_native = $M.ipermute;\n  $M.ipermute = function (A, order) {\n    if (A instanceof MatrixCL) {\n      // reverse order\n      var rev_order = order.concat();//have same elements\n      for (var d = 0; d < order.length; d++) {\n        rev_order[order[d] - 1] = d + 1;\n      }\n      return permute_cl(A, rev_order);\n    } else {\n      return ipermute_native(A, order);\n    }\n  };\n})();\n", "'use strict';\n// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\n// overwrites reduction functions\n\nvar $M = require('../../sushi');\nvar util = require('../../util');\nvar util_cl = require('./util_cl');\n\n(function () {\n  var $CL = require('./driver');\n  $M.CL = $CL;\n\n  var Matrix = require('../../matrix');\n  var MatrixCL = require('../matrix_cl');\n  var WebCL = $M.CL.WebCL;\n  var ctypes = util_cl.ctypes;\n  var webcltypes = util_cl.webcltypes;\n\n  var maxmin_reduction_along_axis_cl = function (A, dim, name, is_min, is_argmax) {\n    if (dim == null) {\n      //select first non-1 axis\n      dim = A._numel;\n      for (var i = 0; i < A._size.length; i++) {\n        var dimsize = A._size[i];\n        if (dimsize !== 1) {\n          dim = i + 1;\n          break;\n        }\n      }\n    }\n\n    if (dim > A._ndims) {\n      //max along axis with size 1\n      if (is_argmax) {\n        var amat = new MatrixCL(A._size, 'int32');\n        amat._fill(1);\n        return { M: A.copy(), I: amat };\n      } else {\n        return A.copy();\n      }\n    }\n\n    var dstsize = A._size.slice();\n    if (dstsize[dim - 1] !== 0) {\n      //size 0 dimension is preserved\n      dstsize[dim - 1] = 1;\n    }\n\n    if ((A._numel === 0) || (A._size[dim - 1] === 1)) {\n      //only change shape\n      var dst_onlyreshape = A.copy();\n      dst_onlyreshape.reshape_inplace(dstsize);\n      if (is_argmax) {\n        var amat = new MatrixCL(dstsize, 'int32');\n        amat._fill(1);\n        return { M: dst_onlyreshape, I: amat };\n      } else {\n        return dst_onlyreshape;\n      }\n    }\n\n    //reduction actually needed\n    var dst = new MatrixCL(dstsize, A._klass);\n    var argmax = null;\n    if (is_argmax) {\n      argmax = new MatrixCL(dstsize, 'int32');\n    }\n    var input_strides = A._strides;\n    var output_strides = dst._strides.slice();\n    while (output_strides.length <= input_strides.length) {\n      output_strides.push(dst._numel);\n    }\n    var output_strides_mat = MatrixCL._fromtypedarray(new Int32Array(output_strides), 'int32');\n    var input_strides_mat = MatrixCL._fromtypedarray(new Int32Array(A._strides), 'int32');\n\n    var reduction_step = input_strides[dim - 1];\n    var reduction_count = A._size[dim - 1];\n    var dims = A._ndims;\n\n    var kernel_name = 'maxmin_reduction_cl_' + name + '_' + (A._klass) + '_' + dims;\n    var kernel = MatrixCL.kernel_cache[kernel_name];\n    if (!kernel) {\n      kernel = $CL.createKernel([\n        '#define SRC_DST_TYPE ' + ctypes[A._klass],\n        '#define DIMS ' + dims,\n        '__kernel void kernel_func(__global SRC_DST_TYPE *dst, __global SRC_DST_TYPE *src,',\n        is_argmax ? '__global int *argmax,' : '',\n        ' uint length,',\n        '__global int *output_strides, __global int *input_strides, int reduction_step, int reduction_count) {',\n        '  int i = (int)get_global_id(0);',\n        '  if (i >= length) { return; }',\n        '  int src_idx = 0;',\n        '  for (int d = 0; d < DIMS; d++) {',\n        '    src_idx += i % output_strides[d+1] / output_strides[d] * input_strides[d];',\n        '  }',\n        '  SRC_DST_TYPE val = src[src_idx];',\n        '  SRC_DST_TYPE accum = val;',\n        is_argmax ? '  int accumarg = 0;' : '',\n        '  for (int red = 1; red < reduction_count; red++) {',\n        '    src_idx += reduction_step;',\n        '    val = src[src_idx];',\n        is_min ? (is_argmax ? 'if (val < accum) { accum = val; accumarg = red; }' : 'if (val < accum) { accum = val; }')\n          : (is_argmax ? 'if (val > accum) { accum = val; accumarg = red; }' : 'if (val > accum) { accum = val; }'),//'    if (val > accum) { accum = val; }'\n        '  }',\n        '  dst[i] = accum;',\n        is_argmax ? 'argmax[i] = accumarg + 1;' : '',\n        '}'\n      ].join('\\n'));\n      MatrixCL.kernel_cache[kernel_name] = kernel;\n    }\n\n    if (dst._numel > 0) {\n      if (is_argmax) {\n        $CL.executeKernel(kernel, [\n          { access: WebCL.MEM_WRITE_ONLY, datum: dst },\n          { access: WebCL.MEM_READ_ONLY, datum: A },\n          { access: WebCL.MEM_WRITE_ONLY, datum: argmax },\n          { datum: dst._numel, type: WebCL.type.INT },\n          { access: WebCL.MEM_READ_ONLY, datum: output_strides_mat },\n          { access: WebCL.MEM_READ_ONLY, datum: input_strides_mat },\n          { datum: reduction_step, type: WebCL.type.INT },\n          { datum: reduction_count, type: WebCL.type.INT }\n        ], dst._numel);\n\n      } else {\n        $CL.executeKernel(kernel, [\n          { access: WebCL.MEM_WRITE_ONLY, datum: dst },\n          { access: WebCL.MEM_READ_ONLY, datum: A },\n          { datum: dst._numel, type: WebCL.type.INT },\n          { access: WebCL.MEM_READ_ONLY, datum: output_strides_mat },\n          { access: WebCL.MEM_READ_ONLY, datum: input_strides_mat },\n          { datum: reduction_step, type: WebCL.type.INT },\n          { datum: reduction_count, type: WebCL.type.INT }\n        ], dst._numel);\n      }\n    }\n\n    if (is_argmax) {\n      return { M: dst, I: argmax };\n    } else {\n      return dst;\n    }\n  };\n\n  var stat_reduction_along_axis_cl = function (A, dim, name, init_accum, update_accum, assign_result) {\n    // for statistics methods, output is single klass\n    if (dim == null) {\n      //select first non-1 axis\n      dim = A._numel;\n      for (var i = 0; i < A._size.length; i++) {\n        var dimsize = A._size[i];\n        if (dimsize !== 1) {\n          dim = i + 1;\n          break;\n        }\n      }\n    }\n\n    var virtual_input_shape = A._size.concat();\n    while (dim > virtual_input_shape.length) {\n      // A._size = [10, 20], dim = 4 => virtual_input_shape = [10, 20, 1, 1]\n      virtual_input_shape.push(1);\n    }\n    var dstsize = virtual_input_shape.concat();\n    if (dstsize[dim - 1] !== 0) {\n      //size 0 dimension is preserved\n      dstsize[dim - 1] = 1;\n    }\n\n    //reduction actually needed\n    var dst = new MatrixCL(dstsize, 'single');\n    if (A._numel == 0) {\n      return dst;//empty\n    }\n    var dims = virtual_input_shape.length;\n    var input_strides = [];\n    var tmp = 1;\n    for (var i = 0; i < dims; i++) {\n      input_strides.push(tmp);\n      tmp *= virtual_input_shape[i];\n    }\n    var output_strides = [];\n    tmp = 1;\n    for (var i = 0; i < dims; i++) {\n      output_strides.push(tmp);\n      tmp *= dstsize[i];\n    }\n    output_strides.push(tmp);//excess 1 dimension required\n\n    var output_strides_mat = MatrixCL._fromtypedarray(new Int32Array(output_strides), 'int32');\n    var input_strides_mat = MatrixCL._fromtypedarray(new Int32Array(input_strides), 'int32');\n\n    var reduction_step = input_strides[dim - 1];\n    var reduction_count = virtual_input_shape[dim - 1];\n\n    var kernel_name = 'stat_reduction_cl_' + name + '_' + (A._klass) + '_' + dims;\n    var kernel = MatrixCL.kernel_cache[kernel_name];\n    if (!kernel) {\n      kernel = $CL.createKernel([\n        '#define SRC_TYPE ' + ctypes[A._klass],\n        '#define DST_TYPE float',\n        '#define DIMS ' + dims,\n        '__kernel void kernel_func(__global DST_TYPE *dst, __global const SRC_TYPE *src,',\n        ' uint length,',\n        '__global const int *output_strides, __global const int *input_strides, int reduction_step, int reduction_count) {',\n        '  int i = (int)get_global_id(0);',\n        '  if (i >= length) { return; }',\n        '  int src_idx = 0;',\n        '  for (int d = 0; d < DIMS; d++) {',\n        '    src_idx += i % output_strides[d+1] / output_strides[d] * input_strides[d];',\n        '  }',\n        '  DST_TYPE val = src[src_idx];',\n        init_accum,//'  DST_TYPE accum = val;',\n        '  for (int red = 1; red < reduction_count; red++) {',\n        '    src_idx += reduction_step;',\n        '    val = (DST_TYPE)src[src_idx];',\n        update_accum,\n        '  }',\n        assign_result,//'  dst[i] = accum;',\n        '}'\n      ].join('\\n'));\n      MatrixCL.kernel_cache[kernel_name] = kernel;\n    }\n\n    $CL.executeKernel(kernel, [\n      { access: WebCL.MEM_WRITE_ONLY, datum: dst },\n      { access: WebCL.MEM_READ_ONLY, datum: A },\n      { datum: dst._numel, type: WebCL.type.INT },\n      { access: WebCL.MEM_READ_ONLY, datum: output_strides_mat },\n      { access: WebCL.MEM_READ_ONLY, datum: input_strides_mat },\n      { datum: reduction_step, type: WebCL.type.INT },\n      { datum: reduction_count, type: WebCL.type.INT }\n    ], dst._numel);\n\n    output_strides_mat.destruct();\n    input_strides_mat.destruct();\n\n    return dst;\n  };\n\n  var max_native = $M.max;\n  $M.max = function (A, B, dim) {\n    return $M.autodestruct(function () {\n      var mats = util_cl.unify_mats([A, B]);\n      if (mats.cl) {\n        if (B == null) {\n          return maxmin_reduction_along_axis_cl(A, dim, 'max', false, false);\n        } else {\n          return $M.CL._max_elementwise_cl(mats[0], mats[1]);\n        }\n      } else {\n        return max_native(mats[0], mats[1], dim);\n      }\n    });\n  };\n\n  var min_native = $M.min;\n  $M.min = function (A, B, dim) {\n    return $M.autodestruct(function () {\n      var mats = util_cl.unify_mats([A, B]);\n      if (mats.cl) {\n        if (B == null) {\n          return maxmin_reduction_along_axis_cl(A, dim, 'min', true, false);\n        } else {\n          return $M.CL._min_elementwise_cl(mats[0], mats[1]);\n        }\n      } else {\n        return min_native(mats[0], mats[1], dim);\n      }\n    });\n  };\n\n  var argmax_native = $M.argmax;\n  $M.argmax = function (A, dummy, dim) {\n    if (A instanceof MatrixCL) {\n      return maxmin_reduction_along_axis_cl(A, dim, 'argmax', false, true);\n    } else {\n      return argmax_native(A, dummy, dim);\n    }\n  };\n  var argmin_native = $M.argmin;\n  $M.argmin = function (A, dummy, dim) {\n    if (A instanceof MatrixCL) {\n      return maxmin_reduction_along_axis_cl(A, dim, 'argmin', true, true);\n    } else {\n      return argmin_native(A, dummy, dim);\n    }\n  };\n\n  var replace_sum = function (f_native, name, init_accum, update_accum, assign_result) {\n    return function (A) {//(A: Matrix, dim: number, outtype?: string)\n      if (A instanceof MatrixCL) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        var dim = undefined;\n        var outtype = undefined;\n        for (var i = 1; i < arguments.length; i++) {\n          var arg = arguments[i];\n          if (typeof (arg) === 'string') {\n            if (arg != 'native') {\n              throw new Error('Outtype other than native is currently not supported');\n            }\n          } else if (typeof (arg) === 'number') {\n            dim = arg;\n          } else {\n            throw new Error('Unknown argument ' + arg);\n          }\n        }\n        return stat_reduction_along_axis_cl(A, dim, name,\n          init_accum, update_accum, assign_result);\n      } else {\n        //use native\n        return f_native.apply(null, arguments);\n      }\n    };\n  }\n\n  $M.sum = replace_sum($M.sum, 'sum', 'DST_TYPE accum = val;', 'accum += val;', 'dst[i] = accum;');\n  $M.mean = replace_sum($M.mean, 'mean', 'DST_TYPE accum = val;', 'accum += val;', 'dst[i] = accum / reduction_count;');\n  $M.prod = replace_sum($M.prod, 'prod', 'DST_TYPE accum = val;', 'accum *= val;', 'dst[i] = accum;');\n\n  var replace_variance = function (f_native, name, do_sqrt) {\n    return function (A, w, dim) {//(A: Matrix, w: number = 0, dim?: number)\n      if (A instanceof MatrixCL) {\n        var assign_result;\n        if (w == null || w == 0) {\n          assign_result = 'dst[i] = ' + do_sqrt + '((sqsum - normalsum * normalsum / reduction_count) / (reduction_count > 1 ? reduction_count - 1 : 1));';\n        } else if (w == 1) {\n          assign_result = 'dst[i] = ' + do_sqrt + '((sqsum - normalsum * normalsum / reduction_count) / reduction_count);';\n        } else {\n          throw new Error('w must be 0 or 1');\n        }\n        return stat_reduction_along_axis_cl(A, dim, name + w,\n          'DST_TYPE normalsum = (DST_TYPE)val; DST_TYPE sqsum = (DST_TYPE)val * (DST_TYPE)val;', 'normalsum += val; sqsum += (DST_TYPE)val * (DST_TYPE)val;', assign_result);\n      } else {\n        //use native\n        return f_native.apply(null, arguments);\n      }\n    };\n  }\n\n  $M.variance = replace_variance($M.variance, 'variance', '');\n  $M.std = replace_variance($M.std, 'std', 'sqrt');\n})();\n", "'use strict';\n/* ************************************************************************\n * This is the JavaScript porting of sgemm code in clBLAS.\n * Ported by Machine Intelligence Laboratory (The University of Tokyo)\n * Original license is the following:\n * Copyright 2013 Advanced Micro Devices, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ************************************************************************/\n\n(function () {\n  var $M = require('../../sushi');\n  var util = require('../../util');\n  var util_cl = require('./util_cl');\n  var $CL = require('./driver');\n  $M.CL = $CL;\n\n  var Matrix = require('../../matrix');\n  var MatrixCL = require('../matrix_cl');\n  var WebCL = $M.CL.WebCL;\n  var ctypes = util_cl.ctypes;\n  var webcltypes = util_cl.webcltypes;\n\n  var select_macroTileNumRowsCols = function (m, n) {\n    var size_limits = [4000, 2448, 1600, 1008, 960, 896, 864, 784, 768, 720, 464, 304, 0];\n    var fallback = [96, 96, 96, 96, 32, 32, 32, 32, 32, 32, 48, 32, 16];\n    var divisors = [[96],//4000\n      [96],//2448\n      [96, 64, 80],//1600\n      [96, 64, 80, 48],//1008\n      [64, 48, 80, 32],//960\n      [64, 96, 48, 80, 32],//896\n      [96, 48, 80, 64, 32],//864\n      [48, 80, 64, 32, 16],//784\n      [48, 80, 64, 32, 16],//768\n      [64, 80, 96, 48],//720\n      [48, 64, 32, 80],//464\n      [48, 32, 16],//304\n      [16]];//0\n    \n    for (var index = 0; index < size_limits.length; index++) {\n      var size_limit = size_limits[index];\n      if (m * n < size_limit * size_limit) {\n        continue;\n      }\n      var divisor = divisors[index];\n      for (var j = 0; j < divisor.length; j++) {\n        var div = divisor[j];\n        if (m % div == 0 && n % div == 0) {\n          return div;\n        }\n      }\n\n      return fallback[index];\n    }\n\n    return 16;//not reachable\n  }\n\n  var sgemm = function (transa, transb, m, n, k, alpha, A, ldA, B, ldB, beta, C, ldC, offsetA, offsetB, offsetC) {\n    //console.log('sgemm ' + transa + transb + ',' + m + ',' + n + ',' + k);\n    offsetA = offsetA | 0;\n    offsetB = offsetB | 0;\n    offsetC = offsetC | 0;\n    var betazero = '1';\n    var caccess = WebCL.MEM_READ_WRITE;\n    if (beta == 0) {\n      betazero = '0';\n      caccess = WebCL.MEM_WRITE_ONLY;\n    }\n    var workGroupNumRows = 16, workGroupNumCols = 16;\n    var macroTileNumRowsCols = select_macroTileNumRowsCols(m, n);\n    var unroll = 1;\n    if (k % 16 == 0) {\n      unroll = 16;\n    } else if (k % 8 == 0) {\n      unroll = 8;\n    }\n    if (macroTileNumRowsCols == 96 && unroll == 16) {\n      unroll = 8;//the combination very slow on S9170 GPU\n    }\n\n    var macroTileNumRows = macroTileNumRowsCols, macroTileNumCols = macroTileNumRowsCols;\n    var globalWorkSizeRows = Math.floor(m / macroTileNumRows) * workGroupNumRows;\n    var globalWorkSizeCols = Math.floor(n / macroTileNumCols) * workGroupNumCols;\n    if (globalWorkSizeRows > 0 && globalWorkSizeCols > 0) {\n      //console.log('sgemm_Row_' + transa + transb + '_B' + betazero + '_MX' + macroTileNumRows + '_NX' + macroTileNumCols + '_KX' + unroll);\n      var kernel_tile = getgemmkernel('sgemm_Col_' + transa + transb + '_B' + betazero + '_MX' + macroTileNumRows + '_NX' + macroTileNumCols + '_KX' + unroll);\n      $CL.executeKernel(\n        kernel_tile,\n        [\n          { access: WebCL.MEM_READ_ONLY, datum: A },\n          { access: WebCL.MEM_READ_ONLY, datum: B },\n          { access: caccess, datum: C },\n          { datum: alpha, type: WebCL.type.FLOAT },//alpha\n          { datum: beta, type: WebCL.type.FLOAT },//beta=0\n          { datum: m, type: WebCL.type.UINT },//M\n          { datum: n, type: WebCL.type.UINT },//N\n          { datum: k, type: WebCL.type.UINT },//K\n          { datum: ldA, type: WebCL.type.UINT },//lda\n          { datum: ldB, type: WebCL.type.UINT },//ldb\n          { datum: ldC, type: WebCL.type.UINT },//ldc\n          { datum: offsetA, type: WebCL.type.UINT },//offseta\n          { datum: offsetB, type: WebCL.type.UINT },//offsetb\n          { datum: offsetC, type: WebCL.type.UINT },//offsetc\n        ],\n        [globalWorkSizeRows, globalWorkSizeCols],\n        [workGroupNumRows, workGroupNumCols]\n        );\n    }\n    if (m % macroTileNumRows != 0 && globalWorkSizeCols > 0) {\n      var kernel_row = getgemmkernel('sgemm_Col_' + transa + transb + '_B' + betazero + '_ML' + macroTileNumRows + '_NX' + macroTileNumCols + '_KX' + unroll);\n      $CL.executeKernel(\n        kernel_row,\n        [\n          { access: WebCL.MEM_READ_ONLY, datum: A },\n          { access: WebCL.MEM_READ_ONLY, datum: B },\n          { access: caccess, datum: C },\n          { datum: alpha, type: WebCL.type.FLOAT },//alpha\n          { datum: beta, type: WebCL.type.FLOAT },//beta=0\n          { datum: m, type: WebCL.type.UINT },//M\n          { datum: n, type: WebCL.type.UINT },//N\n          { datum: k, type: WebCL.type.UINT },//K\n          { datum: ldA, type: WebCL.type.UINT },//lda\n          { datum: ldB, type: WebCL.type.UINT },//ldb\n          { datum: ldC, type: WebCL.type.UINT },//ldc\n          { datum: offsetA, type: WebCL.type.UINT },//offseta\n          { datum: offsetB, type: WebCL.type.UINT },//offsetb\n          { datum: offsetC, type: WebCL.type.UINT },//offsetc\n        ],\n        [workGroupNumRows, globalWorkSizeCols],\n        [workGroupNumRows, workGroupNumCols]\n        );\n    }\n\n    if (globalWorkSizeRows > 0 && n % macroTileNumCols != 0) {\n      var kernel_col = getgemmkernel('sgemm_Col_' + transa + transb + '_B' + betazero + '_MX' + macroTileNumRows + '_NL' + macroTileNumCols + '_KX' + unroll);\n      $CL.executeKernel(\n        kernel_col,\n        [\n          { access: WebCL.MEM_READ_ONLY, datum: A },\n          { access: WebCL.MEM_READ_ONLY, datum: B },\n          { access: caccess, datum: C },\n          { datum: alpha, type: WebCL.type.FLOAT },//alpha\n          { datum: beta, type: WebCL.type.FLOAT },//beta=0\n          { datum: m, type: WebCL.type.UINT },//M\n          { datum: n, type: WebCL.type.UINT },//N\n          { datum: k, type: WebCL.type.UINT },//K\n          { datum: ldA, type: WebCL.type.UINT },//lda\n          { datum: ldB, type: WebCL.type.UINT },//ldb\n          { datum: ldC, type: WebCL.type.UINT },//ldc\n          { datum: offsetA, type: WebCL.type.UINT },//offseta\n          { datum: offsetB, type: WebCL.type.UINT },//offsetb\n          { datum: offsetC, type: WebCL.type.UINT },//offsetc\n        ],\n        [globalWorkSizeRows, workGroupNumCols],\n        [workGroupNumRows, workGroupNumCols]\n        );\n    }\n    if ((m % macroTileNumRows != 0) && (n % macroTileNumCols != 0)) {\n      var kernel_corner = getgemmkernel('sgemm_Col_' + transa + transb + '_B' + betazero + '_ML' + macroTileNumRows + '_NL' + macroTileNumCols + '_KX' + unroll);\n      $CL.executeKernel(\n        kernel_corner,\n        [\n          { access: WebCL.MEM_READ_ONLY, datum: A },\n          { access: WebCL.MEM_READ_ONLY, datum: B },\n          { access: caccess, datum: C },\n          { datum: alpha, type: WebCL.type.FLOAT },//alpha\n          { datum: beta, type: WebCL.type.FLOAT },//beta=0\n          { datum: m, type: WebCL.type.UINT },//M\n          { datum: n, type: WebCL.type.UINT },//N\n          { datum: k, type: WebCL.type.UINT },//K\n          { datum: ldA, type: WebCL.type.UINT },//lda\n          { datum: ldB, type: WebCL.type.UINT },//ldb\n          { datum: ldC, type: WebCL.type.UINT },//ldc\n          { datum: offsetA, type: WebCL.type.UINT },//offseta\n          { datum: offsetB, type: WebCL.type.UINT },//offsetb\n          { datum: offsetC, type: WebCL.type.UINT },//offsetc\n        ],\n        [workGroupNumRows, workGroupNumCols],\n        [workGroupNumRows, workGroupNumCols]\n        );\n    }\n  };\n\n  $M.CL.sgemm = sgemm;\n\n  var mtimes_native = $M.mtimes;\n  var mtimes_cl = function (A, B) {\n    if (A._ndims != 2 || B._ndims != 2) {\n      throw new Error('Matrix must be two-dimensional');\n    }\n    if (A._size[1] != B._size[0]) {\n      throw new Error('Shape mismatch');\n    }\n    if (A._klass != 'single' || B._klass != 'single') {\n      throw new Error('Matrix klass must be single');\n    }\n    var m = A._size[0], n = B._size[1], k = A._size[1];\n    var C = new MatrixCL([m, n], 'single');\n    var lda = A._strides[1];\n    var ldb = B._strides[1];\n    var ldc = C._strides[1];\n    sgemm('N', 'N', m, n, k, 1.0, A, lda, B, ldb, 0.0, C, ldc);\n    return C;\n  };\n\n  $M.mtimes = function (A, B) {\n    return $M.autodestruct(function () {\n      return util_cl.unify_call(mtimes_native, mtimes_cl, A, B);\n    });\n  };\n\n  var getgemmkernel = function () {\n    var kernels = {};\n\n    var KernelParameters = function (name) {\n      this.name = name;//cgemm_Col_CC_B0_ML080_NL080_KX08\n      var items = name.split('_');\n      this.precision = items[0].substr(0, 1);\n      this.microTileNumRows = parseInt(items[4].substr(2), 10) / this.workGroupNumRows;\n      this.microTileNumCols = parseInt(items[5].substr(2), 10) / this.workGroupNumCols;\n      this.unroll = parseInt(items[6].substr(2), 10);\n      this.localRowPad = 0;\n      this.localColPad = 0;\n      this.order = items[1] == 'Col' ? 'clblasColumnMajor' : 'clblasRowMajor';\n      this.transA = items[2].substr(0, 1);\n      this.transB = items[2].substr(1, 1);\n      this.beta = parseInt(items[3].substr(1, 1), 10);\n      this._isRowKernel = items[4].substr(1, 1) == 'L';\n      this._isColKernel = items[5].substr(1, 1) == 'L';\n    };\n\n    KernelParameters.prototype.workGroupNumRows = 16;\n    KernelParameters.prototype.workGroupNumCols = 16;\n\n    KernelParameters.prototype.isValid = function () {\n      return true;\n    };\n\n    KernelParameters.prototype.getName = function () {\n      return this.name;\n    };\n\n    KernelParameters.prototype.isRowKernel = function () {\n      return this._isRowKernel;\n    };\n\n    KernelParameters.prototype.isColKernel = function () {\n      return this._isColKernel;\n    };\n\n    var Common = {};\n    Common.hostDataChar = { \"s\": \"s\", \"d\": \"d\", \"c\": \"c\", \"z\": \"z\" };\n    Common.hostDataType = { \"s\": \"float\", \"d\": \"double\", \"c\": \"float2\", \"z\": \"double2\" };\n    Common.openclDataType = { \"s\": \"float\", \"d\": \"double\", \"c\": \"float2\", \"z\": \"double2\" };\n\n    Common.precisionInt = { \"s\": 0, \"d\": 1, \"c\": 2, \"z\": 3 };\n    Common.orderInt = { \"clblasRowMajor\": 0, \"clblasColumnMajor\": 1 };\n    Common.transposeInt = { \"N\": 0, \"T\": 1, \"C\": 2 };\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Make OpenCL Kernel String\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    function makeOpenCLKernelString(kernel) {\n      //var endLine = \"\\\\n\\\"\\n\\\"\";\n      var endLine = \"\\n\";\n\n      ////////////////////////////////////////////////////////////////////////\n      // parameters valid?\n      if (kernel.isValid() == false) {\n        return kernel.getName() + \" invalid\";\n      }\n\n      ////////////////////////////////////////////////////////////////////////\n      // initializations\n      var kStr = \"\";\n      kStr += endLine;\n      kStr += \"/* \" + kernel.getName() + \" */\";\n      kStr += endLine;\n\n      ////////////////////////////////////////////////////////////////////////\n      // Double precision pragma\n      var prec = kernel.precision;\n      if (prec == \"d\" || prec == \"z\") {\n        kStr += endLine;\n        kStr += \"//pragma OPENCL EXTENSION cl_khr_fp64 : enable\" + endLine;\n      }\n\n      ////////////////////////////////////////////////////////////////////////\n      // kernel parameters\n      kStr += endLine;\n      kStr += \"/* kernel parameters */\" + endLine;\n      //if kernel.order == \"clblasColumnMajor\":\n      //  kStr += \"#define COLUMN_MAJOR          1\" + endLine\n      //else:\n      //  kStr += \"#define COLUMN_MAJOR          0\" + endLine\n      //if kernel.transA == \"T\":\n      //  kStr += \"#define TRANSPOSE_A           1\" + endLine\n      //else:\n      //  kStr += \"#define TRANSPOSE_A           0\" + endLine\n      //if kernel.transB == \"T\":\n      //  kStr += \"#define TRANSPOSE_B           1\" + endLine\n      //else:\n      //  kStr += \"#define TRANSPOSE_B           0\" + endLine\n      //kStr += \"\" + endLine\n      kStr += \"#define WG_NUM_ROWS          \" + (kernel.workGroupNumRows + endLine);\n      kStr += \"#define WG_NUM_COLS          \" + (kernel.workGroupNumCols + endLine);\n      kStr += \"#define MICRO_TILE_NUM_ROWS  \" + (kernel.microTileNumRows + endLine);\n      kStr += \"#define MICRO_TILE_NUM_COLS  \" + (kernel.microTileNumCols + endLine);\n      kStr += \"#define MACRO_TILE_NUM_ROWS  \" + ((kernel.workGroupNumRows * kernel.microTileNumRows) + endLine);\n      kStr += \"#define MACRO_TILE_NUM_COLS  \" + ((kernel.workGroupNumCols * kernel.microTileNumCols) + endLine);\n      kStr += \"#define NUM_UNROLL_ITER      \" + (kernel.unroll + endLine);\n      kStr += \"\" + endLine;\n      kStr += \"#define LOCAL_ROW_PAD        \" + (kernel.localRowPad + endLine);\n      kStr += \"#define LOCAL_COL_PAD        \" + (kernel.localColPad + endLine);\n\n      ////////////////////////////////////////////////////////////////////////\n      // global memory indices\n      // A\n      kStr += endLine;\n      kStr += \"/* global memory indices */\" + endLine;\n      if ((kernel.order == \"clblasColumnMajor\") == (kernel.transA == \"N\")) {\n        kStr += \"#define GET_GLOBAL_INDEX_A(ROW,COL) ((COL)*lda+(ROW))\" + endLine;\n      } else {\n        kStr += \"#define GET_GLOBAL_INDEX_A(ROW,COL) ((ROW)*lda+(COL))\" + endLine;\n      }\n      // B\n      if ((kernel.order == \"clblasColumnMajor\") == (kernel.transB == \"N\")) {\n        kStr += \"#define GET_GLOBAL_INDEX_B(ROW,COL) ((COL)*ldb+(ROW))\" + endLine;\n      } else {\n        kStr += \"#define GET_GLOBAL_INDEX_B(ROW,COL) ((ROW)*ldb+(COL))\" + endLine;\n      }\n      // C\n      if (kernel.order == \"clblasColumnMajor\") {\n        kStr += \"#define GET_GLOBAL_INDEX_C(ROW,COL) ((COL)*ldc+(ROW))\" + endLine;\n      } else {\n        kStr += \"#define GET_GLOBAL_INDEX_C(ROW,COL) ((ROW)*ldc+(COL))\" + endLine;\n      }\n\n      ////////////////////////////////////////////////////////////////////////\n      // local memory indices\n      // A\n      kStr += endLine;\n      kStr += \"/* local memory indices */\" + endLine;\n      kStr += \"#define GET_LOCAL_INDEX_A(ROW,COL) ((ROW) + (COL)*((MACRO_TILE_NUM_ROWS)+(LOCAL_COL_PAD)) )\" + endLine;\n      // B\n      kStr += \"#define GET_LOCAL_INDEX_B(ROW,COL) ((COL) + (ROW)*((MACRO_TILE_NUM_COLS)+(LOCAL_ROW_PAD)) )\" + endLine;\n\n      ////////////////////////////////////////////////////////////////////////\n      // data types\n      kStr += endLine;\n      kStr += \"/* data types */\" + endLine;\n      kStr += \"#define DATA_TYPE_STR \" + (Common.openclDataType[kernel.precision] + endLine);\n      if (kernel.precision == \"s\" || kernel.precision == \"d\") {\n        // real arithmetic\n        kStr += \"#define TYPE_MAD(MULA,MULB,DST) DST = mad(MULA,MULB,DST);\" + endLine;\n        if (kernel.beta == 1) {\n          kStr += \"#define TYPE_MAD_WRITE(DST,ALPHA,REG,BETA) DST = (ALPHA)*(REG) + (BETA)*(DST);\" + endLine;\n        } else {\n          kStr += \"#define TYPE_MAD_WRITE(DST,ALPHA,REG,BETA) DST = (ALPHA)*(REG);\" + endLine;\n        }\n      } else {\n        // complex arithmetic\n        if (kernel.transA != \"C\" && kernel.transB != \"C\") {\n          // neither conjugate\n          kStr += (\n            \"#define TYPE_MAD(MULA,MULB,DST) \\\\\" + endLine +\n            \"  DST.s0 = mad(  MULA.s0, MULB.s0, DST.s0 ); \\\\\" + endLine +\n            \"  DST.s0 = mad( -MULA.s1, MULB.s1, DST.s0 ); \\\\\" + endLine +\n            \"  DST.s1 = mad(  MULA.s0, MULB.s1, DST.s1 ); \\\\\" + endLine +\n            \"  DST.s1 = mad(  MULA.s1, MULB.s0, DST.s1 );\" + endLine);\n        } else if (kernel.transA == \"C\" && kernel.transB != \"C\") {\n          // A conjugate (negate imaginary A.s1)\n          kStr += (\n            \"#define TYPE_MAD(MULA,MULB,DST) \\\\\" + endLine +\n            \"  DST.s0 = mad(  MULA.s0, MULB.s0, DST.s0 ); \\\\\" + endLine +\n            \"  DST.s0 = mad(  MULA.s1, MULB.s1, DST.s0 ); \\\\\" + endLine +\n            \"  DST.s1 = mad(  MULA.s0, MULB.s1, DST.s1 ); \\\\\" + endLine +\n            \"  DST.s1 = mad( -MULA.s1, MULB.s0, DST.s1 );\" + endLine);\n        } else if (kernel.transA != \"C\" && kernel.transB == \"C\") {\n          // B conjugate (negate imaginary B.s1)\n          kStr += (\n            \"#define TYPE_MAD(MULA,MULB,DST) \\\\\" + endLine +\n            \"  DST.s0 = mad(  MULA.s0,  MULB.s0, DST.s0 ); \\\\\" + endLine +\n            \"  DST.s0 = mad( -MULA.s1, -MULB.s1, DST.s0 ); \\\\\" + endLine +\n            \"  DST.s1 = mad(  MULA.s0, -MULB.s1, DST.s1 ); \\\\\" + endLine +\n            \"  DST.s1 = mad(  MULA.s1,  MULB.s0, DST.s1 );\" + endLine);\n        } else {\n          // A & B conjugate (negate imaginary .s1)\n          kStr += (\n            \"#define TYPE_MAD(MULA,MULB,DST) \\\\\" + endLine +\n            \"  DST.s0 = mad(  MULA.s0,  MULB.s0, DST.s0 ); \\\\\" + endLine +\n            \"  DST.s0 = mad(  MULA.s1, -MULB.s1, DST.s0 ); \\\\\" + endLine +\n            \"  DST.s1 = mad(  MULA.s0, -MULB.s1, DST.s1 ); \\\\\" + endLine +\n            \"  DST.s1 = mad( -MULA.s1,  MULB.s0, DST.s1 );\" + endLine);\n        }\n        if (kernel.beta == 1) {\n          kStr += (\n            \"#define TYPE_MAD_WRITE( DST, ALPHA, REG, BETA ) \\\\\" + endLine +\n            \"  /* (1) */ \\\\\" + endLine +\n            \"  type_mad_tmp = REG.s0; \\\\\" + endLine +\n            \"  REG.s0 *= ALPHA.s0; \\\\\" + endLine +\n            \"  REG.s0 = mad( -ALPHA.s1, REG.s1, REG.s0 ); \\\\\" + endLine +\n            \"  REG.s1 *= ALPHA.s0; \\\\\" + endLine +\n            \"  REG.s1 = mad(  ALPHA.s1, type_mad_tmp, REG.s1 ); \\\\\" + endLine +\n            \"  /* (2) */ \\\\\" + endLine +\n            \"  REG.s0 = mad(  BETA.s0, DST.s0, REG.s0 ); \\\\\" + endLine +\n            \"  REG.s0 = mad( -BETA.s1, DST.s1, REG.s0 ); \\\\\" + endLine +\n            \"  REG.s1 = mad(  BETA.s1, DST.s0, REG.s1 ); \\\\\" + endLine +\n            \"  REG.s1 = mad(  BETA.s0, DST.s1, REG.s1 ); \\\\\" + endLine +\n            \"  /* (3) */ \\\\\" + endLine +\n            \"  DST = REG;\" + endLine);\n        } else {\n          kStr += (\n            \"#define TYPE_MAD_WRITE( DST, ALPHA, REG, BETA ) \\\\\" + endLine +\n            \"  /* (1) */ \\\\\" + endLine +\n            \"  type_mad_tmp = REG.s0; \\\\\" + endLine +\n            \"  REG.s0 *= ALPHA.s0; \\\\\" + endLine +\n            \"  REG.s0 = mad( -ALPHA.s1, REG.s1, REG.s0 ); \\\\\" + endLine +\n            \"  REG.s1 *= ALPHA.s0; \\\\\" + endLine +\n            \"  REG.s1 = mad(  ALPHA.s1, type_mad_tmp, REG.s1 ); \\\\\" + endLine +\n            \"  /* (2) */ \\\\\" + endLine +\n            \"  REG.s0 = mad(  BETA.s0, DST.s0, REG.s0 ); \\\\\" + endLine +\n            \"  REG.s0 = mad( -BETA.s1, DST.s1, REG.s0 ); \\\\\" + endLine +\n            \"  REG.s1 = mad(  BETA.s1, DST.s0, REG.s1 ); \\\\\" + endLine +\n            \"  REG.s1 = mad(  BETA.s0, DST.s1, REG.s1 ); \\\\\" + endLine +\n            \"  /* (3) */ \\\\\" + endLine +\n            \"  DST = REG;\" + endLine);\n        }\n      }\n\n      ////////////////////////////////////////////////////////////////////////\n      // micro-tile\n      kStr += endLine;\n      kStr += \"/* \" + kernel.microTileNumRows + \"x\" + kernel.microTileNumCols + \" micro-tile */\" + endLine;\n      kStr += \"#define MICRO_TILE \\\\\" + endLine;\n      for (var a = 0; a < kernel.microTileNumRows; a++) {\n        kStr += \"  rA[\" + a + \"] = localA[offA + \" + a + \"*WG_NUM_ROWS]; \\\\\" + endLine;\n      }\n      for (var b = 0; b < kernel.microTileNumCols; b++) {\n        kStr += \"  rB[\" + b + \"] = localB[offB + \" + b + \"*WG_NUM_COLS]; \\\\\" + endLine;\n      }\n      kStr += \"  offA += (MACRO_TILE_NUM_ROWS+LOCAL_COL_PAD); \\\\\" + endLine;\n      kStr += \"  offB += (MACRO_TILE_NUM_COLS+LOCAL_ROW_PAD); \\\\\" + endLine;\n      for (var a = 0; a < kernel.microTileNumRows; a++) {\n        for (var b = 0; b < kernel.microTileNumCols; b++) {\n          kStr += \"  TYPE_MAD(rA[\" + a + \"],rB[\" + b + \"],rC[\" + a + \"][\" + b + \"]); \\\\\" + endLine;\n\n        }\n      }\n      kStr += \"  mem_fence(CLK_LOCAL_MEM_FENCE);\" + endLine;\n      kStr += endLine;\n\n      ////////////////////////////////////////////////////////////////////////\n      // function signature\n      ////////////////////////////////////////////////////////////////////////\n      kStr += \"__attribute__((reqd_work_group_size(WG_NUM_COLS,WG_NUM_ROWS,1)))\" + endLine;\n      kStr += \"__kernel void kernel_func\"// + ( kernel.getName() ) // for sushi_cl function name restriction\n      kStr += \"(\" + endLine;\n      // arguments\n      kStr += (\n        \"  __global DATA_TYPE_STR const * restrict A,\" + endLine +\n        \"  __global DATA_TYPE_STR const * restrict B,\" + endLine +\n        \"  __global DATA_TYPE_STR       *          C,\" + endLine +\n        \"  DATA_TYPE_STR const alpha,\" + endLine +\n        \"  DATA_TYPE_STR const beta,\" + endLine +\n        \"  uint const M,\" + endLine +\n        \"  uint const N,\" + endLine +\n        \"  uint const K,\" + endLine +\n        \"  uint const lda,\" + endLine +\n        \"  uint const ldb,\" + endLine +\n        \"  uint const ldc,\" + endLine +\n        \"  uint const offsetA,\" + endLine +\n        \"  uint const offsetB,\" + endLine +\n        \"  uint const offsetC\" + endLine +\n        \") {\" + endLine);\n\n      ////////////////////////////////////////////////////////////////////////\n      // apply offsets\n      kStr += endLine;\n      kStr += (\n        \"  /* apply offsets */\" + endLine +\n        \"  A += offsetA;\" + endLine +\n        \"  B += offsetB;\" + endLine +\n        \"  C += offsetC;\" + endLine);\n\n      ////////////////////////////////////////////////////////////////////////\n      // allocate registers\n      kStr += endLine;\n      kStr += (\n        \"  /* allocate registers */\" + endLine +\n        \"  DATA_TYPE_STR rC[MICRO_TILE_NUM_ROWS][MICRO_TILE_NUM_COLS] = { {0} };\" + endLine +\n        \"  DATA_TYPE_STR rA[MICRO_TILE_NUM_ROWS];\" + endLine +\n        \"  DATA_TYPE_STR rB[MICRO_TILE_NUM_COLS];\" + endLine);\n\n      ////////////////////////////////////////////////////////////////////////\n      // allocate local memory\n      kStr += endLine;\n      kStr += (\n        \"  /* allocate local memory */\" + endLine +\n        \"  __local DATA_TYPE_STR localA[NUM_UNROLL_ITER*(MACRO_TILE_NUM_ROWS+LOCAL_COL_PAD)];\" + endLine +\n        \"  __local DATA_TYPE_STR localB[NUM_UNROLL_ITER*(MACRO_TILE_NUM_COLS+LOCAL_ROW_PAD)];\" + endLine);\n\n      ////////////////////////////////////////////////////////////////////////\n      // work item indices\n      kStr += endLine;\n      kStr += \"  /* work item indices */\" + endLine;\n      if (kernel.isRowKernel()) {\n        kStr += \"  uint groupRow = M / \" + (kernel.workGroupNumRows * kernel.microTileNumRows) + \"; // last row\" + endLine;\n      } else {\n        kStr += \"  uint groupRow = get_group_id(0);\" + endLine;\n      }\n      if (kernel.isColKernel()) {\n        kStr += \"  uint groupCol = N / \" + (kernel.workGroupNumCols * kernel.microTileNumCols) + \"; // last column\" + endLine;\n      } else {\n        kStr += \"  uint groupCol = get_group_id(1);\" + endLine;\n      }\n\n      ////////////////////////////////////////////////////////////////////////\n      // z-order - TODO doesn't improve caching, only lowers occupancy\n      if (false) {\n        kStr += (\n          \"  // convert work-group order to z-order\" + endLine +\n          \"  unsigned int morton = get_group_id(1) * get_num_groups(0) + get_group_id(0);\" + endLine +\n          \"  groupRow = morton;\" + endLine +\n          \"  groupCol = ( groupRow >> 1 );\" + endLine +\n          \"  groupRow &= 0x55555555;\" + endLine +\n          \"  groupCol &= 0x55555555;\" + endLine +\n          \"  groupRow |= ( groupRow >> 1 );\" + endLine +\n          \"  groupCol |= ( groupCol >> 1 );\" + endLine +\n          \"  groupRow &= 0x33333333;\" + endLine +\n          \"  groupCol &= 0x33333333;\" + endLine +\n          \"  groupRow |= ( groupRow >> 2 );\" + endLine +\n          \"  groupCol |= ( groupCol >> 2 );\" + endLine +\n          \"  groupRow &= 0x0f0f0f0f;\" + endLine +\n          \"  groupCol &= 0x0f0f0f0f;\" + endLine +\n          \"  groupRow |= ( groupRow >> 4 );\" + endLine +\n          \"  groupCol |= ( groupCol >> 4 );\" + endLine +\n          \"  groupRow &= 0x00ff00ff;\" + endLine +\n          \"  groupCol &= 0x00ff00ff;\" + endLine +\n          \"  groupRow |= ( groupRow >> 8 );\" + endLine +\n          \"  groupCol |= ( groupCol >> 8 );\" + endLine +\n          \"  groupRow &= 0x0000ffff;\" + endLine +\n          \"  groupCol &= 0x0000ffff;\" + endLine + endLine\n          );\n      }\n\n      kStr += (\n        \"  uint localRow = get_local_id(0);\" + endLine +\n        \"  uint localCol = get_local_id(1);\" + endLine +\n        \"  uint localSerial = localRow + localCol*WG_NUM_ROWS;\" + endLine);\n\n      ////////////////////////////////////////////////////////////////////////\n      // global indices being loaded\n      kStr += endLine;\n      kStr += \"  /* global indices being loaded */\" + endLine;\n      if ((kernel.order == \"clblasColumnMajor\") == (kernel.transA == \"N\")) {\n        kStr += (\n          \"#define globalARow(LID) (groupRow*MACRO_TILE_NUM_ROWS + (localSerial+(LID)*WG_NUM_ROWS*WG_NUM_COLS)%MACRO_TILE_NUM_ROWS)\" + endLine +\n          \"#define globalACol(LID) ((localSerial+(LID)*WG_NUM_ROWS*WG_NUM_COLS)/MACRO_TILE_NUM_ROWS)\" + endLine);\n      } else {\n        kStr += (\n          \"#define globalARow(LID) (groupRow*MACRO_TILE_NUM_ROWS + (localSerial+(LID)*WG_NUM_ROWS*WG_NUM_COLS)/NUM_UNROLL_ITER)\" + endLine +\n          \"#define globalACol(LID) ((localSerial+(LID)*WG_NUM_ROWS*WG_NUM_COLS)%NUM_UNROLL_ITER)\" + endLine);\n      }\n      if ((kernel.order == \"clblasColumnMajor\") == (kernel.transB == \"N\")) {\n        kStr += (\n          \"#define globalBRow(LID) ((localSerial+(LID)*WG_NUM_ROWS*WG_NUM_COLS)%NUM_UNROLL_ITER)\" + endLine +\n          \"#define globalBCol(LID) (groupCol*MACRO_TILE_NUM_COLS + (localSerial+(LID)*WG_NUM_ROWS*WG_NUM_COLS)/NUM_UNROLL_ITER)\" + endLine);\n      } else {\n        kStr += (\n          \"#define globalBRow(LID) ((localSerial+(LID)*WG_NUM_ROWS*WG_NUM_COLS)/MACRO_TILE_NUM_COLS)\" + endLine +\n          \"#define globalBCol(LID) (groupCol*MACRO_TILE_NUM_COLS + (localSerial+(LID)*WG_NUM_ROWS*WG_NUM_COLS)%MACRO_TILE_NUM_COLS)\" + endLine);\n      }\n  \n      //kStr += (\n      //  \"  A += GET_GLOBAL_INDEX_A( globalARow, globalACol );\" + endLine +\n      //  \"  B += GET_GLOBAL_INDEX_B( globalBRow, globalBCol );\" + endLine )\n\n      ////////////////////////////////////////////////////////////////////////\n      // loop over k\n      kStr += endLine;\n      kStr += (\n        \"  /* loop over k */\" + endLine +\n        \"  uint block_k = K / NUM_UNROLL_ITER;\" + endLine +\n        \"  do {\" + endLine);\n\n      ////////////////////////////////////////////////////////////////////////\n      // local indices being written\n      kStr += endLine;\n      kStr += \"    /* local indices being written */\" + endLine;\n      if ((kernel.order == \"clblasColumnMajor\") == (kernel.transA == \"N\")) {\n        kStr += (\n          \"#define localARow (localSerial % MACRO_TILE_NUM_ROWS)\" + endLine +\n          \"#define localACol (localSerial / MACRO_TILE_NUM_ROWS)\" + endLine +\n          \"#define localAStride (WG_NUM_ROWS*WG_NUM_COLS)\" + endLine);\n      } else {\n        kStr += (\n          \"#define localARow (localSerial / NUM_UNROLL_ITER)\" + endLine +\n          \"#define localACol (localSerial % NUM_UNROLL_ITER)\" + endLine +\n          \"#define localAStride (WG_NUM_ROWS*WG_NUM_COLS/NUM_UNROLL_ITER)\" + endLine);\n      }\n\n      if ((kernel.order == \"clblasColumnMajor\") == (kernel.transB == \"N\")) {\n        kStr += (\n          \"#define localBRow ( localSerial % NUM_UNROLL_ITER )\" + endLine +\n          \"#define localBCol ( localSerial / NUM_UNROLL_ITER )\" + endLine +\n          \"#define localBStride (WG_NUM_ROWS*WG_NUM_COLS/NUM_UNROLL_ITER)\" + endLine);\n      } else {\n        kStr += (\n          \"#define localBRow ( localSerial / MACRO_TILE_NUM_COLS )\" + endLine +\n          \"#define localBCol ( localSerial % MACRO_TILE_NUM_COLS )\" + endLine +\n          \"#define localBStride  (WG_NUM_ROWS*WG_NUM_COLS)\" + endLine);\n      }\n\n\n      kStr += (\n        \"    __local DATA_TYPE_STR *lA = localA + GET_LOCAL_INDEX_A(localARow, localACol);\" + endLine +\n        \"    __local DATA_TYPE_STR *lB = localB + GET_LOCAL_INDEX_B(localBRow, localBCol);\" + endLine +\n        \"    barrier(CLK_LOCAL_MEM_FENCE);\" + endLine);\n\n      ////////////////////////////////////////////////////////////////////////\n      // load global -> local\n      // threads to do loading = (workGroupNumRows*workGroupNumCols)\n      // A elements to be loaded = workGroupNumRows*microTileNumRows*unroll\n      // B elements to be loaded = workGroupNumCols*microTileNumCols*unroll\n      kStr += endLine;\n      kStr += \"    /* load global -> local */\" + endLine;\n      var numALoads = Math.floor((kernel.workGroupNumRows * kernel.microTileNumRows * kernel.unroll) / (kernel.workGroupNumRows * kernel.workGroupNumCols));\n      var numALoadsR = (kernel.workGroupNumRows * kernel.microTileNumRows * kernel.unroll) % (kernel.workGroupNumRows * kernel.workGroupNumCols);\n      var numBLoads = Math.floor((kernel.workGroupNumCols * kernel.microTileNumCols * kernel.unroll) / (kernel.workGroupNumRows * kernel.workGroupNumCols));\n      var numBLoadsR = (kernel.workGroupNumCols * kernel.microTileNumCols * kernel.unroll) % (kernel.workGroupNumRows * kernel.workGroupNumCols);\n\n      // TODO - zeroString for real and complex\n      var zeroString;\n      if (kernel.precision == \"c\") {\n        zeroString = \"(float2)(0.f, 0.f)\";\n      } else if (kernel.precision == \"z\") {\n        zeroString = \"(double2)(0.0, 0.0)\";\n      } else {\n        zeroString = \"0.0\";\n      }\n      for (var a = 0; a < numALoads; a++) {\n        kStr += \"    lA[ \" + a + \"*localAStride ] = \";\n        if (kernel.isRowKernel()) {\n          kStr += \"( globalARow(\" + a + \") >= M) ? \" + zeroString + \" : \";\n        }\n        kStr += \"A[ GET_GLOBAL_INDEX_A( globalARow(\" + a + \"), globalACol(\" + a + \") ) ];\" + endLine;\n      }\n      if (numALoadsR > 0) {\n        kStr += \"    if ( localSerial + \" + (numALoads) + \"*WG_NUM_ROWS*WG_NUM_COLS < (WG_NUM_ROWS*MICRO_TILE_NUM_ROWS*NUM_UNROLL_ITER) ) {\" + endLine;\n        kStr += \"      lA[ \" + numALoads + \"*localAStride ] = \";\n        if (kernel.isRowKernel()) {\n          kStr += \"( globalARow(\" + numALoads + \") >= M) ? \" + zeroString + \" : \";\n        }\n        kStr += \"A[ GET_GLOBAL_INDEX_A( globalARow(\" + numALoads + \"), globalACol(\" + numALoads + \") ) ];\" + endLine;\n        kStr += \"    }\" + endLine;\n      }\n\n      for (var b = 0; b < numBLoads; b++) {\n        kStr += \"    lB[ \" + b + \"*localBStride ] = \";\n        if (kernel.isColKernel()) {\n          kStr += \"( globalBCol(\" + b + \") >= N) ? \" + zeroString + \" : \";\n        }\n        kStr += \"B[ GET_GLOBAL_INDEX_B( globalBRow(\" + b + \"), globalBCol(\" + b + \") ) ];\" + endLine;\n\n      }\n      if (numBLoadsR > 0) {\n        kStr += \"    if ( localSerial + \" + (numBLoads) + \"*WG_NUM_ROWS*WG_NUM_COLS < (WG_NUM_COLS*MICRO_TILE_NUM_COLS*NUM_UNROLL_ITER) ) {\" + endLine;\n        kStr += \"      lB[ \" + numBLoads + \"*localBStride ] = \";\n        if (kernel.isColKernel()) {\n          kStr += \"(globalBCol(\" + numBLoads + \") >= N) ? \" + zeroString + \" : \";\n        }\n        kStr += \"B[ GET_GLOBAL_INDEX_B( globalBRow(\" + numBLoads + \"), globalBCol(\" + numBLoads + \") ) ];\" + endLine;\n        kStr += \"    }\" + endLine;\n      }\n      kStr += (\n        \"    barrier(CLK_LOCAL_MEM_FENCE);\" + endLine +\n        \"    uint offA = localRow;\" + endLine +\n        \"    uint offB = localCol;\" + endLine);\n\n      ////////////////////////////////////////////////////////////////////////\n      // do mads\n      kStr += endLine;\n      kStr += \"    /* do mads */\" + endLine;\n      for (var u = 0; u < kernel.unroll; u++) {\n        kStr += \"    MICRO_TILE\" + endLine;\n      }\n\n      ////////////////////////////////////////////////////////////////////////\n      // shift to next k block\n      kStr += endLine;\n      kStr += \"    /* shift to next k block */\" + endLine;\n      if ((kernel.order == \"clblasColumnMajor\") == (kernel.transA == \"N\")) {\n        kStr += \"    A += lda*NUM_UNROLL_ITER;\" + endLine;\n      } else {\n        kStr += \"    A += NUM_UNROLL_ITER;\" + endLine;\n      }\n      if ((kernel.order == \"clblasColumnMajor\") == (kernel.transB == \"N\")) {\n        kStr += \"    B += NUM_UNROLL_ITER;\" + endLine;\n      } else {\n        kStr += \"    B += ldb*NUM_UNROLL_ITER;\" + endLine;\n      }\n\n      ////////////////////////////////////////////////////////////////////////\n      // end loop\n      kStr += endLine;\n      kStr += \"  } while (--block_k > 0);\" + endLine;\n      kStr += endLine;\n\n      ////////////////////////////////////////////////////////////////////////\n      // which global Cij index\n      kStr += endLine;\n      kStr += \"  /* which global Cij index */\" + endLine;\n      kStr += \"  uint globalCRow = groupRow * MACRO_TILE_NUM_ROWS + localRow;\" + endLine;\n      kStr += \"  uint globalCCol = groupCol * MACRO_TILE_NUM_COLS + localCol;\" + endLine;\n\n      ////////////////////////////////////////////////////////////////////////\n      // write global Cij\n      kStr += endLine;\n      kStr += \"  /* write global Cij */\" + endLine;\n      if (kernel.precision == \"c\") {\n        kStr += \"  float type_mad_tmp;\" + endLine;\n      }\n      if (kernel.precision == \"z\") {\n        kStr += \"  double type_mad_tmp;\" + endLine;\n      }\n\n      for (var a = 0; a < kernel.microTileNumRows; a++) {\n        for (var b = 0; b < kernel.microTileNumCols; b++) {\n          if (kernel.isRowKernel()) {\n            kStr += \"  if (globalCRow+\" + a + \"*WG_NUM_ROWS < M)\";\n          }\n          if (kernel.isColKernel()) {\n            kStr += \"  if (globalCCol+\" + b + \"*WG_NUM_COLS < N)\";\n          }\n          if (kernel.isRowKernel() || kernel.isColKernel()) {\n            kStr += \"{\";\n          }\n          kStr += \"  TYPE_MAD_WRITE( C[ GET_GLOBAL_INDEX_C( globalCRow+\" + a + \"*WG_NUM_ROWS, globalCCol+\" + b + \"*WG_NUM_COLS) ], alpha, rC[\" + a + \"][\" + b + \"], beta )\";\n          if (kernel.isRowKernel() || kernel.isColKernel()) {\n            kStr += \"}\";\n          }\n          kStr += endLine;\n        }\n      }\n\n      ////////////////////////////////////////////////////////////////////////\n      // end kernel\n      kStr += endLine;\n      kStr += \"}\" + endLine;\n\n      return kStr;\n    }\n\n    return function (name) {\n      var kernel;\n      if (!(name in kernels)) {\n        var kp = new KernelParameters(name);\n        var kernelstr = makeOpenCLKernelString(kp);\n        //var compile_begin = new Date();\n        kernel = $CL.createKernel(kernelstr);\n        //var compile_end = new Date();\n        //console.log('compiling ' + name + ': ' + (compile_end - compile_begin) + 'ms');\n        kernels[name] = kernel;\n      } else {\n        kernel = kernels[name];\n      }\n      return kernel;\n    }\n  } ();\n\n})();\n", "'use strict';\n// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\n// overwrites functions in $M by opencl-aware version\n\nvar $M = require('../../sushi');\nvar util = require('../../util');\nmodule.exports = $M;\n\n(function () {\n  if ($M.CL) {\n    return;\n  }\n  var $CL = require('./driver');\n  $M.CL = $CL;\n\n  var Matrix = require('../../matrix');\n  var MatrixCL = require('../matrix_cl');\n  $M.CL.MatrixCL = MatrixCL;\n  var WebCL = $M.CL.WebCL;\n\n  $M.gpuArray = function (A) {\n    if (A instanceof MatrixCL) {\n      return A.copy();\n    }\n    A = util.as_mat(A);\n    var mat = new MatrixCL(A._size, A._klass);\n    mat.write(A._data);\n    return mat;\n  };\n\n  $M.gather = function (A) {\n    if (!(A instanceof MatrixCL)) {\n      return A.copy();\n    }\n    var mat = new Matrix(A._size, A._klass);\n    A.read(mat._data);\n    return mat;\n  };\n\n  $M.devicetype = function (A) {\n    if (A instanceof MatrixCL) {\n      return 'cl';\n    } else if (A instanceof Matrix) {\n      return 'cpu';\n    }\n    return null;\n  }\n\n  var zeros_native = $M.zeros;\n  $M.zeros = function () {\n    //generate gpuArray if final argument is 'gpuArray'\n    if (arguments[arguments.length - 1] == 'gpuArray') {\n      var format = util.calc_zeros_size(Array.prototype.slice.call(arguments, 0, -1));\n      var mat = new MatrixCL(format.size, format.klass);\n      mat._fill(0);\n      return mat;\n    } else {\n      return zeros_native.apply(null, arguments);\n    }\n  };\n  var ones_native = $M.ones;\n  $M.ones = function () {\n    //generate gpuArray if final argument is 'gpuArray'\n    if (arguments[arguments.length - 1] == 'gpuArray') {\n      var format = util.calc_zeros_size(Array.prototype.slice.call(arguments, 0, -1));\n      var mat = new MatrixCL(format.size, format.klass);\n      mat._fill(1);\n      return mat;\n    } else {\n      return ones_native.apply(null, arguments);\n    }\n  };\n\n  require('./binary_arithmetic');\n  require('./unary_arithmetic');\n  require('./shape_converter_cl');\n  require('./reduction_cl');\n  require('./clblasgemm');\n})();\n", "// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\nimport polyfill = require('./polyfill');\nexport import Matrix = require('./matrix');\nexport import Colon = require('./colon');\nexport import colon = require('./colonwrap');\nimport util = require('./util');\nimport func_generator = require('./func_generator');\nimport shape_converter = require('./shape_converter');\nimport reduction = require('./reduction');\nimport mul = require('./mul');\nimport npy = require('./io/npy');\n//export import MatrixCL = require('./cl/matrix_cl');\nexport var CL: any = null;// for webcl\n\npolyfill.polyfill();\n\nexport var end = -1;\nexport type MatrixOrNumber = util.MatrixOrNumber;\nexport type MatrixLike = Matrix | number | number[] | number[][];\n\ndeclare var require;\nvar initcl_result: boolean = null;\nexport function initcl(): boolean {\n  if (initcl_result != null) {\n    return initcl_result;\n  }\n  try {\n    var dummy: any = require('../src/cl/handwrittenjs/sushi_cl');\n    initcl_result = true;\n  } catch (ex) {\n    console.error(ex);\n    initcl_result = false;\n  }\n  return initcl_result;\n}\n\nexport function devicetype(A: Matrix): string {\n  if (A instanceof Matrix) {\n    return 'cpu';\n  }\n  return null;\n}\n\nexport function autodestruct(f: () => any): any {\n  Matrix.autodestruct_push();\n  var mats_to_save = [];\n  try {\n    mats_to_save = f();\n  } finally {\n    if (typeof (mats_to_save) === 'object') {\n      var mats_list;\n      if (mats_to_save instanceof Matrix) {\n        // single matrix return\n        mats_list = [mats_to_save];\n      } else if (mats_to_save.length !== undefined) {\n        //array-like\n        mats_list = mats_to_save.filter((v) => (v instanceof Matrix));\n      } else {\n        //dictionary\n        mats_list = [];\n        for (var k in mats_to_save) {\n          if (mats_to_save[k] instanceof Matrix) {\n            mats_list.push(mats_to_save[k]);\n          }\n        }\n      }\n\n      var stack_top = Matrix._autodestruct_stack_top;\n      var stack_second_top = Matrix._autodestruct_stack[Matrix._autodestruct_stack.length - 2];\n      for (var i = 0; i < mats_list.length; i++) {\n        var mat = mats_list[i];\n        var delete_idx = stack_top.indexOf(mat);\n        if (delete_idx >= 0) {\n          stack_top.splice(delete_idx, 1);\n          if (stack_second_top) {\n            stack_second_top.push(mat);//maybe destructed in nested autodestruct\n          }\n        }\n      }\n    }\n    Matrix.autodestruct_pop();\n  }\n  return mats_to_save;\n}\n\nexport var typedarray2mat = Matrix.typedarray2mat;\n\nexport function zeros(...args: any[]): Matrix {\n  var format = util.calc_zeros_size(args);\n  return new Matrix(format.size, format.klass);\n}\n\nexport function ones(...args: any[]): Matrix {\n  var mat = zeros(...args);\n  mat._data.fill(1);\n  return mat;\n}\n\nexport function rand(...args: any[]): Matrix {\n  var mat = zeros(...args);\n  var data = mat._data;\n  for (var i = 0, length = data.length; i < length; i++) {\n    data[i] = Math.random();\n  }\n  return mat;\n}\n\nexport function randi(imax: number | number[], ...args: any[]): Matrix {\n  //first argument: imax or [imin, imax]\n  var _imin = 1, _imax = 1;\n  if ((<any>imax).length != null) {\n    if ((<any>imax).length === 2) {\n      _imin = imax[0];\n      _imax = imax[1];\n    } else {\n      throw new Error('Invalid imax');\n    }\n  } else {\n    _imax = <number>imax;\n  }\n\n  var mat = zeros(...args);\n  var data = mat._data;\n  for (var i = 0, length = data.length; i < length; i++) {\n    data[i] = Math.floor(Math.random() * (_imax - _imin + 1)) + _imin;\n  }\n  return mat;\n}\n\nexport function randn(...args: any[]): Matrix {\n  var mat = zeros(...args);\n  var data = mat._data;\n  for (var i = 0, length = data.length; i < length; i++) {\n    var alpha = Math.random();\n    var beta = Math.random();\n    data[i] = Math.sqrt(-2 * Math.log(alpha)) * Math.sin(2 * Math.PI * beta);\n  }\n  return mat;\n}\n\nexport function eye(...args: any[]): Matrix {\n  var mat = zeros(...args);\n  var min_dim = Math.min(mat._size[0], mat._size[1]);\n  for (var i = 1; i <= min_dim; i++) {\n    mat.set(i, i, 1);\n  }\n  return mat;\n}\n\nexport function size(X: Matrix): Matrix;\nexport function size(X: Matrix, dim: number): number;\nexport function size(X: Matrix, dim?: number): any {\n  if (dim === void 0) {\n    // return as row vector\n    return jsa2mat([X._size], false, 'int32');//int32 to represent value > 8M accurately\n  } else {\n    if (dim <= 0 || !Matrix._isinteger(dim)) {\n      throw new Error('Invalid dimension');\n    }\n\n    return X._size[dim - 1] || 1;\n  }\n}\n\nexport function sizejsa(X: Matrix): number[] {\n  return X._size;\n}\n\nexport function jsa2mat(A: any[], one_d_column?: boolean, klass?: string): Matrix {\n  return Matrix.jsa2mat(A, one_d_column, klass);\n}\n\nexport function mat2jsa(A: Matrix, one_d_flatten: boolean = false): any[] {\n  return A.mat2jsa(one_d_flatten);\n}\n\nexport function length(X: Matrix): number {\n  return Math.max.apply(null, X._size);\n}\n\nexport function ndims(X: Matrix): number {\n  return X._ndims;\n}\n\nexport function numel(X: Matrix): number {\n  return X._numel;\n}\n\nexport function iscolumn(A: Matrix): boolean {\n  return A._ndims == 2 && A._size[1] == 1;\n}\nexport function isrow(A: Matrix): boolean {\n  return A._ndims == 2 && A._size[0] == 1;\n}\nexport function isvector(A: Matrix): boolean {\n  return A._ndims == 2 && (A._size[0] == 1 || A._size[1] == 1);\n}\nexport function isempty(A: Matrix): boolean {\n  return A._numel == 0;\n}\nexport function ismatrix(A: Matrix): boolean {\n  return A._ndims == 2;\n}\nexport function isscalar(A: Matrix): boolean {\n  // currently, number is not supported\n  return A._numel == 1;\n}\n\nexport function klass(object: Matrix): string {\n  return object._klass;\n}\n\nexport function gpuArray(A: MatrixLike): Matrix {\n  //overriden by sushi_cl\n  return util.as_mat(A).copy();\n}\n\nexport function gather(A: Matrix): Matrix {\n  //overriden by sushi_cl\n  return A.copy();\n}\n\nfunction jsaequal(a: any[], b: any[]): boolean {\n  if (a.length != b.length) {\n    return false;\n  }\n\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] != b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// If input is 1x1 matrix, returns number\nfunction _singlemat2number(A: MatrixOrNumber): MatrixOrNumber {\n  if ((A instanceof Matrix) && isscalar(A)) {\n    return A.get_scalar([1]);\n  }\n\n  return A;\n}\n\n\n//equality http://jp.mathworks.com/help/matlab/relational-operators.html\n/**\n * Compares elements of two matrices. One of the input can be scalar number.\n *\n * @param A Input matrix.\n * @param B Input matrix.\n * @return logical matrix. 1 if A(i) == B(i).\n */\nexport var eq = function (A: MatrixOrNumber, B: MatrixOrNumber): Matrix {\n  throw new Error();\n};\neq = func_generator.make_compare_func_all('Number(%a == %b)');\n/**\n * Compares elements of two matrices. One of the input can be scalar number.\n *\n * @param A Input matrix.\n * @param B Input matrix.\n * @return logical matrix. 1 if A(i) >= B(i).\n */\nexport var ge = function (A: MatrixOrNumber, B: MatrixOrNumber): Matrix {\n  throw new Error();\n};\nge = func_generator.make_compare_func_all('Number(%a >= %b)');\n/**\n * Compares elements of two matrices. One of the input can be scalar number.\n *\n * @param A Input matrix.\n * @param B Input matrix.\n * @return logical matrix. 1 if A(i) > B(i).\n */\nexport var gt = function (A: MatrixOrNumber, B: MatrixOrNumber): Matrix {\n  throw new Error();\n};\ngt = func_generator.make_compare_func_all('Number(%a > %b)');\n/**\n * Compares elements of two matrices. One of the input can be scalar number.\n *\n * @param A Input matrix.\n * @param B Input matrix.\n * @return logical matrix. 1 if A(i) <= B(i).\n */\nexport var le = function (A: MatrixOrNumber, B: MatrixOrNumber): Matrix {\n  throw new Error();\n};\nle = func_generator.make_compare_func_all('Number(%a <= %b)');\n/**\n * Compares elements of two matrices. One of the input can be scalar number.\n *\n * @param A Input matrix.\n * @param B Input matrix.\n * @return logical matrix. 1 if A(i) < B(i).\n */\nexport var lt = function (A: MatrixOrNumber, B: MatrixOrNumber): Matrix {\n  throw new Error();\n};\nlt = func_generator.make_compare_func_all('Number(%a < %b)');\n/**\n * Compares elements of two matrices. One of the input can be scalar number.\n *\n * @param A Input matrix.\n * @param B Input matrix.\n * @return logical matrix. 1 if A(i) != B(i).\n */\nexport var ne = function (A: MatrixOrNumber, B: MatrixOrNumber): Matrix {\n  throw new Error();\n};\nne = func_generator.make_compare_func_all('Number(%a != %b)');\n/**\n * Checks if all matrices are equal. Assumes NaN is not equal to NaN.\n *\n * @param As Input matrices.\n * @return true if all matrices are the same regarding both size and value of elements.\n */\nexport var isequal = function (...As: Matrix[]): boolean {\n  throw new Error();\n};\nisequal = func_generator.isequal;\n/**\n * Checks if all matrices are equal. Assumes NaN is equal to NaN.\n *\n * @param As Input matrices.\n * @return true if all matrices are the same regarding both size and value of elements.\n */\nexport var isequaln = function (...As: Matrix[]): boolean {\n  throw new Error();\n};\nisequaln = func_generator.isequaln;\n/**\n * Compares if elements of two matrices are close. One of the input can be scalar number.\n *\n * @param A Input matrix.\n * @param B Input matrix.\n * @return logical matrix. 1 if abs(A(i) - B(i)) <= atol + rtol * abs(B(i)).\n */\nexport var isclose = function (A: MatrixOrNumber, B: MatrixOrNumber, rtol: number = 1e-5, atol: number = 1e-8, equal_nan: boolean = false): Matrix {\n  throw new Error();\n};\nisclose = func_generator.isclose;\n/**\n * Compares if all the elements of two matrices are close. One of the input can be scalar number. See also [[isclose]]\n *\n * @param A Input matrix.\n * @param B Input matrix.\n * @return true if all elements of isclose(A, B) are 1.\n */\nexport var allclose = function (A: MatrixOrNumber, B: MatrixOrNumber, rtol?: number, atol?: number, equal_nan?: boolean): boolean {\n  throw new Error();\n};\nallclose = func_generator.allclose;\n\nexport var plus = func_generator.make_binary_arith_func_all('%a + %b');\nexport var minus = func_generator.make_binary_arith_func_all('%a - %b');\nexport var times = func_generator.make_binary_arith_func_all('%a * %b');\nexport var rdivide = func_generator.make_binary_arith_func_all('%a / %b');\nexport var ldivide = func_generator.make_binary_arith_func_all('%b / %a');\nexport var power = func_generator.make_binary_arith_func_all('Math.pow(%a,%b)');\nexport var floor = func_generator.make_unary_arith_func_all('Math.floor(%a)');\nexport var fix = func_generator.make_unary_arith_func_all('(%a > 0 ? Math.floor(%a) : Math.ceil(%a))');\nexport var ceil = func_generator.make_unary_arith_func_all('Math.ceil(%a)');\nexport var uplus = func_generator.make_unary_arith_func_all('+%a');\nexport var uminus = func_generator.make_unary_arith_func_all('-%a');\nexport var exp = func_generator.make_unary_arith_func_all('Math.exp(%a)');\nexport var log = func_generator.make_unary_arith_func_all('Math.log(%a)');\n\nexport var max = reduction.max;\nexport var min = reduction.min;\nexport var argmax = reduction.argmax;\nexport var argmin = reduction.argmin;\nexport var sum = reduction.sum;\nexport var mean = reduction.mean;\nexport var prod = reduction.prod;\nexport var std = reduction.std;\nexport var variance = reduction.variance;\n\nexport var mtimes = mul.mtimes;\n\nexport function reshape(A: Matrix, ...sz: any[]): Matrix {\n  var dst = A.copy();\n  try {\n    dst.reshape_inplace(...sz);\n    return dst;\n  } catch (error) {\n    dst.destruct();\n    throw error;\n  }\n}\n\nexport function squeeze(A: Matrix): Matrix {\n  var dst = A.copy();\n  dst.squeeze_inplace();\n  return dst;\n}\n\nexport var transpose = shape_converter.transpose;\nexport var t = transpose;//alias\n\nexport var repmat = shape_converter.repmat;\nexport var cat = shape_converter.cat;\nexport var horzcat = shape_converter.horzcat;\nexport var vertcat = shape_converter.vertcat;\nexport var permute = shape_converter.permute;\nexport var ipermute = shape_converter.ipermute;\n\nexport var npyread = npy.npyread;\nexport var npysave = npy.npysave;\n\n//indexing\n//TODO:test\nexport function sub2ind(matrixSize: Matrix | number[], ...dimSub: number[]): number {\n  //note: 'end' cannot be used in matlab sub2ind; only positive index is valid\n  var msizejsa: number[];\n  if (matrixSize instanceof Matrix) {\n    if (!isrow(matrixSize) || matrixSize._numel < 2) {\n      throw new Error('matrixSize must be row vector');\n    }\n    msizejsa = matrixSize.mat2jsa(true);\n  } else {\n    msizejsa = <number[]>matrixSize;\n  }\n\n  var stride = 1;\n  var idx = 1;\n  for (var i = 0; i < msizejsa.length; i++) {\n    idx += ((dimSub[i] || 1) - 1) * stride;\n    stride *= msizejsa[i];\n  }\n\n  return idx;\n}\n\nexport function colonvec(start: number, stop_step: number, stop?: number, klass = 'single'): Matrix {\n  // make row vector by i:j:k\n  var step;\n  if (stop == null) {\n    stop = stop_step;\n    step = 1;\n  } else {\n    step = stop_step;\n  }\n\n  var n_item = Math.max(Math.floor((stop - start) / step) + 1, 0);\n  var vec = new Matrix([1, n_item], klass);\n  var vec_data = vec._data;\n  for (var i = 0; i < n_item; i++) {\n    vec_data[i] = start + step * i;\n  }\n  return vec;\n}\n", "// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\nimport Sushi = require('./src/sushi');\nexport = Sushi;\n"],
  "mappings": "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",
  "names": ["exports", "i", "Colon", "Matrix", "i", "dim", "s", "module", "Colon", "colon", "module", "Matrix", "exports", "i", "operation", "dst_klass", "a_mat", "b_mat", "f", "i", "prod", "Matrix", "i", "exports", "i", "f", "Matrix", "i", "sum", "exports", "exports", "Matrix", "i", "exports", "module", "WebCL", "i", "exports", "module", "env", "WebCL", "i", "exports", "module", "Matrix", "Colon", "WebCL", "MatrixCL", "dst_klass", "i", "module", "exports", "module", "Matrix", "WebCL", "i", "util", "Matrix", "WebCL", "dst_klass", "i", "util", "Matrix", "WebCL", "dst_klass", "util", "Matrix", "WebCL", "i", "util", "Matrix", "WebCL", "i", "argmax", "util", "Matrix", "WebCL", "exports", "module", "util", "Matrix", "WebCL", "exports", "util", "func_generator", "f", "i", "length", "klass", "module"]
}
